Структура проекта и содержимое файлов:

[DIR] migrations
    [DIR] models
        [DIR] __pycache__
            [FILE] 0_20250119163110_init.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/migrations/models/__pycache__/0_20250119163110_init.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] 0_20250119163110_init.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/migrations/models/0_20250119163110_init.py ---
from tortoise import BaseDBAsyncClient


async def upgrade(db: BaseDBAsyncClient) -> str:
    return """
        CREATE TABLE IF NOT EXISTS `users` (
    `user_id` BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `uid_code` VARCHAR(50) NOT NULL UNIQUE,
    `status_block` VARCHAR(255) NOT NULL  DEFAULT 'Active',
    `name` VARCHAR(50),
    `age` INT,
    `orientation` VARCHAR(255),
    `gender` VARCHAR(10),
    `medias` JSON,
    `about` LONGTEXT,
    `location` VARCHAR(255),
    `preferences` VARCHAR(255),
    `hobbies` JSON,
    `for_whom` VARCHAR(255),
    `subscription` VARCHAR(50) NOT NULL  DEFAULT 'Free',
    `localstatus` VARCHAR(50) NOT NULL  DEFAULT 'active',
    `subscription_start` DATETIME(6),
    `subscription_end` DATETIME(6),
    `referral_uid` VARCHAR(50)  UNIQUE,
    `balance` DECIMAL(10,2) NOT NULL  DEFAULT 0,
    `level` DECIMAL(5,2) NOT NULL  DEFAULT 0,
    `date_registered` DATETIME(6) NOT NULL  DEFAULT CURRENT_TIMESTAMP(6),
    `lang` VARCHAR(50) NOT NULL  DEFAULT 'nochoise'
) CHARACTER SET utf8mb4;
CREATE TABLE IF NOT EXISTS `blocks` (
    `block_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `can_message` BOOL NOT NULL  DEFAULT 0,
    `created_at` DATETIME(6) NOT NULL  DEFAULT CURRENT_TIMESTAMP(6),
    `from_user_id` BIGINT NOT NULL,
    `to_user_id` BIGINT NOT NULL,
    CONSTRAINT `fk_blocks_users_f69e9486` FOREIGN KEY (`from_user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_blocks_users_041aac48` FOREIGN KEY (`to_user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE
) CHARACTER SET utf8mb4;
CREATE TABLE IF NOT EXISTS `likes` (
    `like_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `is_superlike` BOOL NOT NULL  DEFAULT 0,
    `message` LONGTEXT,
    `created_at` DATETIME(6) NOT NULL  DEFAULT CURRENT_TIMESTAMP(6),
    `from_user_id` BIGINT NOT NULL,
    `to_user_id` BIGINT NOT NULL,
    CONSTRAINT `fk_likes_users_0e2e7347` FOREIGN KEY (`from_user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_likes_users_5172e914` FOREIGN KEY (`to_user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE
) CHARACTER SET utf8mb4;
CREATE TABLE IF NOT EXISTS `statements` (
    `statement_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `referral_count` INT NOT NULL  DEFAULT 0,
    `subscription_level` VARCHAR(20) NOT NULL  DEFAULT 'basic',
    `price` DECIMAL(10,2) NOT NULL  DEFAULT 0,
    `referral_percentage` DECIMAL(5,2) NOT NULL  DEFAULT 0,
    `payment_method` VARCHAR(50),
    `transaction_id` VARCHAR(255),
    `status` VARCHAR(20) NOT NULL  DEFAULT 'pending',
    `created_at` DATETIME(6) NOT NULL  DEFAULT CURRENT_TIMESTAMP(6),
    `user_id` BIGINT NOT NULL,
    CONSTRAINT `fk_statemen_users_32a21656` FOREIGN KEY (`user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE
) CHARACTER SET utf8mb4;
CREATE TABLE IF NOT EXISTS `aerich` (
    `id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `version` VARCHAR(255) NOT NULL,
    `app` VARCHAR(100) NOT NULL,
    `content` JSON NOT NULL
) CHARACTER SET utf8mb4;"""


async def downgrade(db: BaseDBAsyncClient) -> str:
    return """
        """


[FILE] config.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/config.py ---
BOT_TOKEN = "6137952629:AAENt0V0fK9pwDNo2NRxP4_GiiLNdXqKtHk"


TORTOISE_ORM = {
    "connections": {
        # Использование вашего IPv6-адреса и учетных данных
        "default": "mysql://maxemidate:id!125678!@platina.pro:3306/emidate_db"
    },
    "apps": {
        "models": {
            "models": ["src.models", "aerich.models"],  # Пути к вашим моделям
            "default_connection": "default",
        },
    },
}


# aerich init -t config.TORTOISE_ORM
# aerich init-db

[FILE] requirements.txt

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/requirements.txt ---
aiogram>=3.0
tortoise-orm
aiomysql


[DIR] .pytest_cache
    [FILE] CACHEDIR.TAG

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/CACHEDIR.TAG ---
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html


    [FILE] README.md

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/README.md ---
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


    [FILE] .gitignore

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/.gitignore ---
# Created by pytest automatically.
*


    [DIR] v
        [DIR] cache
            [FILE] nodeids

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/v/cache/nodeids ---
[
  "reg_test.py::test_block_command",
  "reg_test.py::test_callback_handler_lang_selection",
  "reg_test.py::test_choise_lang",
  "reg_test.py::test_choise_lang_ru",
  "reg_test.py::test_del_command",
  "reg_test.py::test_handle_message_age_prompt",
  "reg_test.py::test_handle_message_for_whom_prompt",
  "reg_test.py::test_handle_message_gender_prompt",
  "reg_test.py::test_handle_message_name_prompt",
  "reg_test.py::test_handle_message_orientation_prompt",
  "reg_test.py::test_handle_message_preferences_prompt",
  "reg_test.py::test_start_handler_new_user",
  "reg_test.py::test_start_handler_user_all_filled_till_media",
  "reg_test.py::test_start_handler_user_no_gender",
  "reg_test.py::test_start_handler_user_no_name",
  "reg_test.py::test_start_handler_user_no_orientation"
]

            [FILE] lastfailed

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/v/cache/lastfailed ---
{
  "reg_test.py::test_handle_message_name_prompt": true,
  "reg_test.py::test_handle_message_gender_prompt": true,
  "reg_test.py::test_handle_message_orientation_prompt": true,
  "reg_test.py::test_handle_message_for_whom_prompt": true,
  "reg_test.py::test_handle_message_age_prompt": true,
  "reg_test.py::test_handle_message_preferences_prompt": true,
  "reg_test.py::test_choise_lang": true,
  "reg_test.py::test_start_handler_new_user": true,
  "reg_test.py::test_start_handler_user_no_name": true,
  "reg_test.py::test_start_handler_user_no_gender": true,
  "reg_test.py::test_start_handler_user_no_orientation": true,
  "reg_test.py::test_start_handler_user_all_filled_till_media": true,
  "reg_test.py::test_block_command": true,
  "reg_test.py::test_del_command": true,
  "reg_test.py::test_choise_lang_ru": true,
  "reg_test.py::test_callback_handler_lang_selection": true
}

            [FILE] stepwise

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/v/cache/stepwise ---
[]

[FILE] pyproject.toml

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/pyproject.toml ---
[tool.aerich]
tortoise_orm = "config.TORTOISE_ORM"
location = "./migrations"
src_folder = "./."


[FILE] reg_test.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/reg_test.py ---
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext

# Импортируем ваши хендлеры и состояния
from src.bot.handlers.registration import (
    handle_message,
    choise_lang,
    callback_handler
)

# Импортируем ваше состояние
from src.utils.state import RegState
# Импортируем модель User (или же мокируем её внутри теста)
from src.models import User


@pytest.mark.asyncio
async def test_start_handler_new_user(mocker):
    """
    Тестируем ситуацию, когда пользователь впервые нажимает /start
    и в БД ещё нет записи о нём (user=None).
    """
    # Мокаем объект message
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/start"
    # Мокаем метод answer (будет вызван при отправке сообщения)
    message.answer = AsyncMock()
    
    # Мокаем FSMContext
    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()
    
    # Переопределим lang и user, user_none (как в ваших аргументах)
    # Допустим, user=None, user_none=True
    user = None
    user_none = True
    lang = "ru"

    # Вызываем тестируемую функцию
    await handle_message(message=message, state=state, lang=lang, user=user, user_none=user_none)

    # Проверяем, что state.set_state НЕ вызван,
    # так как в вашем коде нет явной логики, если user=None (и стоит user_none=True),
    # но вы можете добавить проверку в код или в тестах.
    state.set_state.assert_not_awaited()

    # Проверяем, что было отправлено какое-то приветственное сообщение или нет
    # (зависит от вашей логики). Предположим, что при user=None ничего не происходит —
    # тогда проверяем, что message.answer тоже не вызывается:
    message.answer.assert_not_awaited()
    

@pytest.mark.asyncio
async def test_start_handler_user_no_name(mocker):
    """
    Тестируем ситуацию, когда в БД есть user, но у него нет имени (user.name = None).
    По коду вы проверяете: если user.name is None -> спросить имя
    """
    # Мокаем message
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/start"
    message.answer = AsyncMock()

    # Мокаем FSMContext
    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()

    # Создаём тестового user (мок)
    user = MagicMock(spec=User)
    user.name = None
    user.gender = None
    user.orientation = None
    user.for_whom = None
    user.age = None
    user.preferences = None
    user.location = None
    user.about = None
    user.hobbies = None
    user.medias = None

    # Вызываем хендлер
    await handle_message(message=message, state=state, lang="ru", user=user, user_none=False)

    # Проверяем, что мы установили состояние на RegState.name
    state.set_state.assert_awaited_once_with(RegState.name)
    
    # Проверяем, что отправили сообщение с инструкцией указать имя
    message.answer.assert_awaited_once()
    args, kwargs = message.answer.call_args
    # Можем дополнительно проверить текст:
    assert "Укажи свое имя" in args[0]  # если lang="ru"


@pytest.mark.asyncio
async def test_start_handler_user_no_gender(mocker):
    """
    Тестируем ситуацию, когда у user есть имя, но не указан пол
    (user.gender = None).
    """
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/start"
    message.answer = AsyncMock()

    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()

    # Допустим, имя есть
    user = MagicMock(spec=User)
    user.name = "Тест"
    user.gender = None
    user.orientation = None
    user.for_whom = None
    user.age = None
    user.preferences = None
    user.location = None
    user.about = None
    user.hobbies = None
    user.medias = None

    await handle_message(message=message, state=state, lang="ru", user=user, user_none=False)

    state.set_state.assert_awaited_once_with(RegState.gender)
    message.answer.assert_awaited_once()
    args, kwargs = message.answer.call_args
    # Проверяем текст
    assert "имя указано! ✅" in args[0]
    assert "укажи свой пол" in args[0]


@pytest.mark.asyncio
async def test_start_handler_user_no_orientation(mocker):
    """
    Тестируем ситуацию, когда user.name и user.gender есть,
    но orientation=None
    """
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.answer = AsyncMock()

    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()

    user = MagicMock(spec=User)
    user.name = "Тест"
    user.gender = "mal"
    user.orientation = None
    user.for_whom = None
    user.age = None

    await handle_message(message=message, state=state, lang="ru", user=user, user_none=False)

    state.set_state.assert_awaited_once_with(RegState.orientation)
    message.answer.assert_awaited_once()
    args, kwargs = message.answer.call_args
    assert "Теперь укажи свою ориентацию" in args[0]


@pytest.mark.asyncio
async def test_start_handler_user_all_filled_till_media(mocker):
    """
    Предположим, что у пользователя заполнено всё до момента,
    когда нужно отправить медиа (user.medias=None).
    Проверяем, что мы переходим на состояние RegState.media.
    """
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.answer = AsyncMock()
    # В коде на этом этапе вызывается message.bot.send_message для медиа,
    # Поэтому замокаем и его:
    message.bot.send_message = AsyncMock()

    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()
    state.get_data = AsyncMock(return_value={})
    state.update_data = AsyncMock()

    user = MagicMock(spec=User)
    user.name = "Тест"
    user.gender = "mal"
    user.orientation = "hetero"
    user.for_whom = "girls"
    user.age = 30
    user.preferences = "romance"
    user.location = "SomeLocation"
    user.about = "Текст о себе"
    user.hobbies = ["1", "2", "3", "4", "5"]  # типа уже 5 увлечений
    user.medias = None  # нет медиа

    await handle_message(message=message, state=state, lang="ru", user=user, user_none=False)

    # Должно установиться состояние media
    state.set_state.assert_awaited_once_with(RegState.media)

    # Проверяем, что бот отправил сообщение с предложением выслать медиа
    message.bot.send_message.assert_awaited_once()
    args, kwargs = message.bot.send_message.call_args
    assert "Теперь отправьте от <b>1 до 3 медиа</b>" in args[1]


@pytest.mark.asyncio
async def test_block_command(mocker):
    """
    Тестируем команду /block.
    """
    from src.bot.handlers.registration import handle_message as block_handler

    # Мокаем message
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/block"

    # Создадим мок для User.get_or_none
    async def mock_get_or_none(user_id):
        mock_user = MagicMock(spec=User)
        mock_user.status_block = None
        async def mock_save():
            pass
        mock_user.save = mock_save
        return mock_user

    with patch("src.handlers.main_handlers.User.get_or_none", side_effect=mock_get_or_none):
        await block_handler(message=message, user=None, user_none=False)
    
    # Проверяем, что у найденного пользователя проставился status_block = "Deactive"
    # В нашем mock_get_or_none мы возвращаем mock_user, у которого изначально status_block = None.
    # После вызова команды /block должно стать "Deactive".
    # Также вызывается mock_user.save().
    # Мы можем проверить это так:
    # Но придётся чуть усложнить реализацию с учётом patch-а.
    # Проще проверить внутри mock-а:

    # Или проверка через spy:
    # (Если используете pytest-mock, можно использовать mocker.spy и т.д.)
    

@pytest.mark.asyncio
async def test_del_command(mocker):
    """
    Тестируем команду /del, которая обнуляет user.medias.
    """
    from src.bot.handlers.registration import handle_message as del_handler


    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/del"

    async def mock_get_or_none(user_id):
        mock_user = MagicMock(spec=User)
        mock_user.medias = ["some_media"]
        async def mock_save():
            pass
        mock_user.save = mock_save
        return mock_user

    state = MagicMock(spec=FSMContext)

    with patch("src.handlers.main_handlers.User.get_or_none", side_effect=mock_get_or_none):
        await del_handler(message=message, state=state, user=None, user_none=False)

    # Здесь проверяем, что medias = None
    # Аналогично предыдущему тесту.
    

@pytest.mark.asyncio
async def test_choise_lang_ru(mocker):
    """
    Тестируем функцию choise_lang, которая отправляет кнопки выбора языка.
    """
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.answer = AsyncMock()
    
    # Проверяем, что при lang['lang']="ru" отсылается русский текст
    await choise_lang(message=message, lang={"lang": "ru"})
    message.answer.assert_awaited_once()
    args, kwargs = message.answer.call_args
    assert "Привет!" in args[0]
    assert "🇷🇺 Русский" in str(kwargs["reply_markup"])  # проверяем, что есть кнопка русского языка
    

@pytest.mark.asyncio
async def test_callback_handler_lang_selection(mocker):
    """
    Тестируем callback_handler, когда приходит выбор языка.
    """
    callback_query = MagicMock(spec=CallbackQuery)
    callback_query.data = "lang_ru"
    callback_query.from_user.id = 12345678
    callback_query.message.message_id = 98765
    callback_query.bot.edit_message_text = AsyncMock()

    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()

    # Мокаем базу
    async def mock_user_get_or_none(user_id):
        mock_user = MagicMock(spec=User)
        mock_user.lang = None
        async def mock_save():
            pass
        mock_user.save = mock_save
        mock_user.name = None
        return mock_user

    with patch("src.handlers.main_handlers.User.get_or_none", side_effect=mock_user_get_or_none), \
         patch("src.handlers.main_handlers.User.save", new_callable=AsyncMock):
        await callback_handler(callback_query=callback_query, state=state, lang="ru")

    # Проверяем, что edit_message_text вызвался с нужным текстом
    callback_query.bot.edit_message_text.assert_awaited_once()
    args, kwargs = callback_query.bot.edit_message_text.call_args
    assert "Нажми /start, чтобы быстрее найти интересных людей" in args[0]

    # Проверяем, что у пользователя выставился lang="ru" и user.save() был вызван
    # (в нашем patch-е в mock_user_get_or_none мы создали mock_user)
    # Можно также проверить через spy, но в данном упрощённом варианте —
    # главное, что исключений нет и вызов edit_message_text корректен.


[FILE] checkk.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/checkk.py ---
import os

def scan_directory_and_save_code(directory, output_file="project_structure_and_code.txt", depth=0):
    """Сканирует директорию, записывает структуру и содержимое файлов в указанный файл."""
    indent = ' ' * (depth * 4)
    try:
        for item in os.listdir(directory):
            path = os.path.join(directory, item)
            if os.path.isdir(path):
                with open(output_file, 'a', encoding='utf-8') as f:
                    f.write(f"{indent}[DIR] {item}\n")
                scan_directory_and_save_code(path, output_file, depth + 1)
            else:
                with open(output_file, 'a', encoding='utf-8') as f:
                    f.write(f"{indent}[FILE] {item}\n")
                save_file_content(path, output_file)
    except Exception as e:
        with open(output_file, 'a', encoding='utf-8') as f:
            f.write(f"{indent}Ошибка доступа к {directory}: {e}\n")

def save_file_content(file_path, output_file):
    """Сохраняет содержимое файла в указанный файл."""
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()
        with open(output_file, 'a', encoding='utf-8') as f:
            f.write(f"\n--- Содержимое файла: {file_path} ---\n")
            f.write(content)
            f.write("\n\n")
    except Exception as e:
        with open(output_file, 'a', encoding='utf-8') as f:
            f.write(f"Ошибка при чтении файла {file_path}: {e}\n")

if __name__ == "__main__":
    # Укажите корневую директорию проекта
    root_dir = os.getcwd()
    output_file = "project_structure_and_code.txt"

    # Очистить файл перед записью
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("Структура проекта и содержимое файлов:\n\n")

    # Сканирование директории и сохранение данных
    scan_directory_and_save_code(root_dir, output_file)

    print(f"Сканирование завершено. Результаты сохранены в {output_file}")


[FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/__init__.py ---


[DIR] __pycache__
    [FILE] config.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/__pycache__/config.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
    [FILE] reg_test.cpython-312-pytest-8.3.4.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/__pycache__/reg_test.cpython-312-pytest-8.3.4.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
[FILE] README.md

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/README.md ---
# EMI-Date Bot

This is a Telegram bot built with aiogram 3.x, designed for user matching and social interactions.

## Features:
- User registration
- Profile search and matching
- Likes and superlikes
- Chats for matches

## How to Run:
1. Install dependencies:


[DIR] dj_emi
    [FILE] config.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/config.py ---
TORTOISE_ORM = {
    "connections": {
        "default": "mysql://maxemidate:id!125678!@platina.pro:3306/emidate_db"
    },
    "apps": {
        "models": {
            "models": ["src.models", "aerich.models"],
            "default_connection": "default",
        },
    },
}


    [DIR] profile__card
        [DIR] migrations
            [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/migrations/__init__.py ---


        [FILE] models.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/models.py ---
from django.db import models

# Create your models here.


        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__init__.py ---


        [DIR] __pycache__
            [FILE] views.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/views.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] urls.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/urls.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] models.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/models.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] admin.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/admin.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] apps.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/apps.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] apps.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/apps.py ---
from django.apps import AppConfig


class ProfileCardConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'profile__card'


        [FILE] admin.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/admin.py ---
from django.contrib import admin

# Register your models here.


        [DIR] templates
            [DIR] profile__card
                [FILE] cards.html

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/templates/profile__card/cards.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Profile Cards</title>
    <style>
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            margin: 10px auto;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        .card img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div id="cards-container"></div>

    <script>
        async function fetchCards() {
            const response = await fetch('/profile/cards/');
            const data = await response.json();

            const container = document.getElementById('cards-container');

            data.users.forEach(user => {
                const card = document.createElement('div');
                card.classList.add('card');

                const img = user.medias.length > 0 ? `<img src="https://api.telegram.org/file/bot<YOUR_BOT_TOKEN>/${user.medias[0].file_id}" alt="${user.name}" />` : '';
                
                card.innerHTML = `
                    ${img}
                    <h3>${user.name}</h3>
                    <p>Age: ${user.age}</p>
                    <p>About: ${user.about}</p>
                `;
                container.appendChild(card);
            });
        }

        fetchCards();
    </script>
</body>
</html>


        [FILE] tests.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/tests.py ---
from django.test import TestCase

# Create your tests here.


        [FILE] urls.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/urls.py ---
from django.urls import path
from . import views

urlpatterns = [
    path('cards/', views.get_user_cards, name='user_cards'),
]

        [FILE] views.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/views.py ---
from django.http import JsonResponse
import asyncio
from tortoise import Tortoise
from config import TORTOISE_ORM
from src.models import User

async def init_db():
    if not Tortoise._inited:
        await Tortoise.init(config=TORTOISE_ORM)
        await Tortoise.generate_schemas()

def get_user_cards(request):
    # Инициализация базы данных
    asyncio.run(init_db())

    # Получение данных
    async def fetch_users():
        current_user_id = request.GET.get('user_id')
        return await User.filter(localstatus="active").exclude(user_id=current_user_id).values(
            "name", "age", "about", "medias"
        )

    users = asyncio.run(fetch_users())

    return JsonResponse({"users": list(users)})


    [FILE] db.sqlite3
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/db.sqlite3: 'utf-8' codec can't decode byte 0x8b in position 99: invalid start byte
    [DIR] __pycache__
        [FILE] config.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/__pycache__/config.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
    [FILE] manage.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/manage.py ---
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dj_emi.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


    [DIR] dj_emi
        [FILE] asgi.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/asgi.py ---
import os
from django.core.asgi import get_asgi_application
from tortoise import Tortoise
from config import TORTOISE_ORM

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dj_emi.settings')

async def init_db():
    if not Tortoise._inited:
        await Tortoise.init(config=TORTOISE_ORM)
        await Tortoise.generate_schemas()

application = get_asgi_application()


        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__init__.py ---


        [DIR] __pycache__
            [FILE] urls.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/urls.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] settings.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/settings.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] asgi.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/asgi.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] wsgi.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/wsgi.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] settings.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/settings.py ---
# Удалите или закомментируйте:
WSGI_APPLICATION = 'dj_emi.wsgi.application'

# Добавьте:
ASGI_APPLICATION = 'dj_emi.asgi.application'

ROOT_URLCONF = 'dj_emi.urls'

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Ваши приложения:
    'profile__card',
]

        [FILE] urls.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/urls.py ---
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('profile/', include('profile__card.urls')),
]


        [FILE] wsgi.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/wsgi.py ---
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dj_emi.settings')

application = get_wsgi_application()


    [DIR] src
        [FILE] models.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/models.py ---
from tortoise.models import Model
from tortoise import fields



class User(Model):
    user_id = fields.BigIntField(pk=True, unique=True)  # Уникальный Telegram ID пользователя
    uid_code = fields.CharField(max_length=50, unique=True)  # Уникальный код пользователя
    status_block = fields.CharField(max_length=255, default="Active")  # Статус (например, "Active", "Blocked")
    name = fields.CharField(max_length=50, null=True)  # Имя
    age = fields.IntField(null=True)  # Возраст
    orientation = fields.CharField(max_length=255, null=True)
    gender = fields.CharField(max_length=10, null=True)  # Пол (например, "male", "female", "other")
    medias = fields.JSONField(null=True)  # Ссылки на медиа (фото/видео)
    about = fields.TextField(null=True)  # Описание "О себе"
    location = fields.CharField(max_length=255, null=True)  # Локация
    preferences = fields.CharField(max_length=255, null=True)  # Кого ищет (например, "friends", "relationship")
    hobbies = fields.JSONField(null=True)  # Список увлечений (до 5)
    for_whom = fields.CharField(max_length=255, null=True)  # Кого показывать (например, "all", "man" , 'girl')
    subscription = fields.CharField(max_length=50, default="Free") 
    localstatus = fields.CharField(max_length=50, default="active") 

     # Тариф подписки (например, "Free", "Premium")
    subscription_start = fields.DatetimeField(null=True)  # Дата начала подписки (только для платных)
    subscription_end = fields.DatetimeField(null=True)  # Дата окончания подписки
    referral_uid = fields.CharField(max_length=50, unique=True, null=True)  # Telegram ID реферера
    balance = fields.DecimalField(max_digits=10, decimal_places=2, default=0.0)  # Баланс
    level = fields.DecimalField(max_digits=5, decimal_places=2, default=0.0)  # % от реферальной программы
    date_registered = fields.DatetimeField(auto_now_add=True)  # Дата регистрации
    lang = fields.CharField(max_length=50, default="nochoise") #язык поользователя
    class Meta:
        table = "users"





class Like(Model):
    like_id = fields.IntField(pk=True)  # Уникальный ID лайка
    from_user = fields.ForeignKeyField("models.User", related_name="sent_likes")  # Кто лайкнул
    to_user = fields.ForeignKeyField("models.User", related_name="received_likes")  # Кто получил лайк
    is_superlike = fields.BooleanField(default=False)  # Это суперлайк или обычный лайк
    message = fields.TextField(null=True)  # Сообщение, если было отправлено
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата создания лайка

    class Meta:
        table = "likes"


class Block(Model):
    block_id = fields.IntField(pk=True)  # Уникальный ID блокировки
    from_user = fields.ForeignKeyField("models.User", related_name="blocked_users")  # Кто заблокировал
    to_user = fields.ForeignKeyField("models.User", related_name="blocked_by")  # Кто заблокирован
    can_message = fields.BooleanField(default=False)  # Разрешены ли сообщения
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата блокировки

    class Meta:
        table = "blocks"


class Statement(Model):
    statement_id = fields.IntField(pk=True)  # Уникальный ID записи
    user = fields.ForeignKeyField("models.User", related_name="statements")  # Пользователь
    referral_count = fields.IntField(default=0)  # Количество рефералов
    subscription_level = fields.CharField(max_length=20, default="basic")  # Уровень подписки
    price = fields.DecimalField(max_digits=10, decimal_places=2, default=0.0)  # Цена подписки/транзакции
    referral_percentage = fields.DecimalField(max_digits=5, decimal_places=2, default=0.0)  # Процент отчислений за реферал
    payment_method = fields.CharField(max_length=50, null=True)  # Метод оплаты (например, "card", "paypal")
    transaction_id = fields.CharField(max_length=255, null=True)  # Уникальный ID транзакции
    status = fields.CharField(max_length=20, default="pending")  # Статус транзакции (успешно, ошибка)
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата создания записи

    class Meta:
        table = "statements"


        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/__init__.py ---


        [DIR] utils
            [FILE] generate_uid.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/generate_uid.py ---
import random
import string

async def generate_uid_code(uids ):
    length=5
    uid=""
    while uid =="":

        """
        Генерирует уникальный код указанной длины, содержащий латинские заглавные и строчные буквы и цифры.

        :param length: Длина кода (по умолчанию 5).
        :return: Сгенерированный код.
        """
        characters = string.ascii_letters + string.digits  # Латинские буквы (верхний и нижний регистр) + цифры
        x_code=''.join(random.choices(characters, k=length))
        if x_code not in uids:
            uid = x_code
        else:
            continue
    return uid

# Пример использования



            [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__init__.py ---


            [DIR] __pycache__
                [FILE] album.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/album.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] generate_uid.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/generate_uid.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] state.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/state.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] comands.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/comands.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] add_profile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/add_profile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] middleware.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/middleware.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] album.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/album.py ---
from aiogram import BaseMiddleware, types
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from typing import Callable, Awaitable, Dict, Any, List, Optional
from cachetools import TTLCache
from asyncio import sleep
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType
from src.utils.comands import set_user_specific_commands


DEFAULT_LATENCY = 0.2
DEFAULT_TTL = 0.600

router = Router()
# Middleware для обработки меди-альбомов
class AlbumMiddleware(BaseMiddleware):
    def __init__(
        self,
        groupmedia_handler: Callable[[Message, List[Dict[str, str]], List[int]], Awaitable[Any]],
        latency: float = DEFAULT_LATENCY,
        ttl: float = DEFAULT_TTL,
    ) -> None:
        super().__init__()
        self.groupmedia_handler = groupmedia_handler
        self.latency = latency
        self.cache: TTLCache = TTLCache(maxsize=10_000, ttl=ttl)

    @staticmethod
    async def get_media_data(message: Message) -> Optional[Dict[str, str]]:
        if message.photo:
            return {"file_id": message.photo[-1].file_id, "type": "photo", "message_id": message.message_id}
        if message.video:
            return {"file_id": message.video.file_id, "type": "video", "message_id": message.message_id}
        return None

    async def __call__(
        self,
        handler: Callable[[types.TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: types.TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        if isinstance(event, Message) and event.media_group_id is not None:
            state: FSMContext = data.get("state")

            if not state:
                return await handler(event, data)

            current_state: Optional[State] = await state.get_state()

            # Проверяем, находится ли пользователь в состоянии RegState.media
            if current_state != "RegState:media":
                return 403

            key = event.media_group_id
            media_data = await self.get_media_data(event)

            if not media_data:
                return await handler(event, data)

            # Если альбом уже собирается, добавляем текущий файл
            if key in self.cache:
                self.cache[key]["media_data"].append(media_data)
                return None

            # Создаем новый альбом в кэше
            self.cache[key] = {
                "media_data": [media_data]
            }

            # Ждем, пока все части альбома дойдут
            await sleep(self.latency)

            # Передаем собранный альбом и message_id для удаления в groupmedia_handler
            media_data_list = self.cache.pop(key)["media_data"]
            message_ids = [media["message_id"] for media in media_data_list]
            return await self.groupmedia_handler(event, media_data_list, message_ids, state)

        return await handler(event, data)
    




# Функция для обработки одиночного медиа
@router.message(RegState.media)
async def set_media(message: types.Message, user: User, state: FSMContext, lang: str):
    if message.media_group_id is None and (message.photo or message.video):  
        # Проверяем одиночные фото/видео
        if user:
            media = user.medias or []
            if len(media) < 3:
                media_data = {
                    "file_id": message.photo[-1].file_id if message.photo else message.video.file_id,
                    "type": "photo" if message.photo else "video"
                }
                await message.bot.delete_message(message.from_user.id, message.message_id)
                media.append(media_data)
                user.medias = media
                await user.save()

                

                # Обновляем сообщение прогресса
                data = await state.get_data()
                msg_id = None
                if "idmsg_media" in data:
                    msg_id=data["idmsg_media"]
                count = len(media)
                if count ==3:
                    txt = (
                    f"Сохранено {count}/3 медиа. Нажмите 'Сохранить'." 
                    if lang == "ru" 
                    else f"Saved {count}/3 media. Click 'Save'."
                )
                else:   
                    txt = (
                        f"Сохранено {count}/3 медиа. Отправьте ещё одно или нажмите 'Сохранить'." 
                        if lang == "ru" 
                        else f"Saved {count}/3 media. Send another one or click 'Save'."
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="Сохранить ✅" if lang == "ru" else "Save ✅", callback_data="save_album")]
                ])

                if msg_id:
                    try:
                        await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
                    except:
                        sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                        await state.update_data(idmsg_media=sent_message.message_id)
                else:
                    sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                    await state.update_data(idmsg_media=sent_message.message_id)
            else:
                txt = "Вы уже отправили максимальное количество медиа! 📸" if lang == "ru" else "You have already sent the maximum amount of media! 📸"
                await message.answer(txt)

# Функция для обработки меди-альбомов
async def groupmedia(message: Message, media_data_list: List[Dict[str, str]], message_ids , state: FSMContext):
    
    chat_id = message.chat.id  # Или используйте другой chat_id, если нужно
    print(message_ids)
    # Проверяем количество файлов в базе данных
    for id in message_ids:
        await message.bot.delete_message(message.from_user.id, id)
    user = await User.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer("Ошибка: пользователь не найден.")
        return
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Сохранить ✅" if user.lang == "ru" else "Save ✅", callback_data="save_album")]
    ])
    existing_files = user.medias or []

    # Если уже есть 2 файла, добавляем только первый файл из альбома
    if len(existing_files) == 2:
        existing_files.append(media_data_list[0])
        user.medias = existing_files
        await user.save()

        # Удаляем сообщение с медиа

        # Обновляем сообщение прогресса
        txt = (
            "Сохранён только первый файл из альбома. Теперь у вас 3/3 медиа. Нажмите 'Сохранить'." 
            if user.lang == "ru" 
            else "Only the first file from the album has been saved. You now have 3/3 media. Click 'Save'."
        )
        data = await state.get_data()
        msg_id = None
        if "idmsg_media" in data:
            msg_id=data["idmsg_media"]

        if msg_id:
            try:
                await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
            except:
                sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                await state.update_data(idmsg_media=sent_message.message_id)
        else:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
        return

    # Если альбом содержит больше 3 файлов, сохраняем только первые 3
    if len(existing_files) + len(media_data_list) > 3:
        remaining_slots = 3 - len(existing_files)
        existing_files.extend(media_data_list[:remaining_slots])
        user.medias = existing_files
        await user.save()

        # Удаляем сообщение с медиа
        # await message.delete()

        # Обновляем сообщение прогресса
        txt = (
            f"Сохранены только первые {remaining_slots} файла из альбома. Теперь у вас 3/3 медиа. Нажмите 'Сохранить'."
            if user.lang == "ru" 
            else f"Only the first {remaining_slots} files from the album have been saved. You now have 3/3 media. Click 'Save'."
        )
        data = await state.get_data()
        msg_id = None
        if "idmsg_media" in data:
            msg_id=data["idmsg_media"]

        if msg_id:
            try:
                await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
            except:
                sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                await state.update_data(idmsg_media=sent_message.message_id)
        else:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
        return

    # Если всё в порядке, сохраняем весь альбом
    existing_files.extend(media_data_list)
    user.medias = existing_files
    await user.save()

    # Удаляем сообщение с медиа

    # Обновляем сообщение прогресса
    if existing_files==3:
        txt = (
        f"Сохранено {len(existing_files)}/3 медиа. Нажать 'Сохранить'."
        if user.lang == "ru" 
        else f"Saved {len(existing_files)}/3 media. Click 'Save'."
    )
    else:
        txt = (
            f"Сохранено {len(existing_files)}/3 медиа. Можете отправить ещё одно или нажать 'Сохранить'."
            if user.lang == "ru" 
            else f"Saved {len(existing_files)}/3 media. You can send another one or click 'Save'."
        )

    

    # await message.answer(txt, reply_markup=keyboard)÷
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]

    if msg_id:
        try:
            await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
        except:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)


def create_start_search_keyboard(lang: str) -> ReplyKeyboardMarkup:
    """
    Создает клавиатуру с кнопкой "Начать поиск" на русском или английском языке.

    :param lang: Язык клавиатуры ('ru' или 'en').
    :return: Объект ReplyKeyboardMarkup.
    """
    if lang == "ru":
        button_text = "🚀 Начать поиск"
    else:
        button_text = "🚀 Start Search"

    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=button_text)]
        ],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    return keyboard

@router.callback_query(lambda c: "skip_album" in c.data, RegState.media)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    # print()
    await state.set_state(RegState.done)
    media = user.medias or []
    file_id='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'
    media_data = {
                    "file_id": file_id,
                    "type": "photo" 
                }
    media.append(media_data)
    user.medias = media
    await user.save()
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]
    txt='''🎉 <b>Профиль успешно заполнен! ✅</b>  

Теперь вы готовы начать находить интересных людей! 🌟  
➡️ Используйте меню внизу и нажмите "Начать поиск", чтобы приступить.  
Удачи! 🍀''' if lang == 'ru' else '''🎉 <b>Profile successfully completed! ✅</b>  

You’re now ready to start finding interesting people! 🌟  
➡️ Use the menu below and tap "Start Search" to begin.  
Good luck! 🍀
'''

    keyboard = create_start_search_keyboard(lang)
    await set_user_specific_commands(callback_query.bot, callback_query.from_user.id, lang )

    if msg_id:
        try:
            await callback_query.bot.edit_message_text(chat_id=callback_query.from_user.id, message_id=msg_id, text=txt, reply_markup=keyboard)
        except:
            sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)


@router.callback_query(lambda c: "save_album" in c.data, RegState.media)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
    await state.set_state(RegState.done)
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]
    txt='''🎉 <b>Профиль успешно заполнен! ✅</b>  

Теперь вы готовы начать находить интересных людей! 🌟  
➡️ Используйте меню внизу и нажмите "Начать поиск", чтобы приступить.  
Удачи! 🍀''' if lang == 'ru' else '''🎉 <b>Profile successfully completed! ✅</b>  

You’re now ready to start finding interesting people! 🌟  
➡️ Use the menu below and tap "Start Search" to begin.  
Good luck! 🍀
'''

    keyboard = create_start_search_keyboard(lang)
    await set_user_specific_commands(callback_query.bot, callback_query.from_user.id, lang )
    if msg_id:
        try:
            try:
                await callback_query.message.edit_reply_markup(reply_markup=None)
                sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)

            except:
                await callback_query.message.delete()
                sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
                
                
        except:
            sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)

            [FILE] comands.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/comands.py ---
from aiogram import Bot, Dispatcher, types
from aiogram.types import BotCommand, BotCommandScopeChat
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType


router = Router()



@router.message(Command("lang"))
async def set_name(message: types.Message, state: FSMContext, lang: str):
    user = await User.get_or_none(user_id=message.from_user.id)
    if user.lang:
        if user.lang=="ru":
            lang='en'
            user.lang=lang
            await user.save()
        else:
            lang='ru'
            user.lang=lang
            await user.save()
        await set_user_specific_commands(message.bot, message.from_user.id, lang)
        if lang == "ru":
            button_text = "🚀 Начать поиск"
        else:
            button_text = "🚀 Start Search"

        keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text=button_text)]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        txt ="""Вы измменили язык ✅
        
ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль.""" if lang=='ru' else"""You have changed the language ✅

ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."""

        await message.answer(txt, reply_markup=keyboard)





async def set_user_specific_commands(bot:Bot, user_id, lang):
    # Определяем команды для пользователя
    user_specific_commands = [
        
        BotCommand(command="myprofile", description="Профиль" if lang=='ru' else "Profile"),
        BotCommand(command="help", description="Помощь"if lang=='ru' else "Help"),
        BotCommand(command="subs", description="Подписка" if lang=='ru' else "Subscription"),
        BotCommand(command="ref", description="Реф. программа" if lang=='ru' else "Ref. program"),
        BotCommand(command="lang", description="Изменить язык" if lang=='ru' else "Change language")
    ]

    # Устанавливаем команды только для указанного пользователя
    await bot.set_my_commands(
        commands=user_specific_commands,
        scope=BotCommandScopeChat(chat_id=user_id)
    )

async def delete_user_specific_commands(bot: Bot, user_id: int):
    """
    Удаляет команды, установленные для конкретного пользователя.
    """
    await bot.delete_my_commands(
        scope=BotCommandScopeChat(chat_id=user_id)
    )

            [FILE] add_profile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/add_profile.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.types import InputMediaPhoto, InputMediaVideo
from src.utils.state import RegState
from src.utils.comands import set_user_specific_commands, delete_user_specific_commands

async def add_profile(message: types.Message, state: FSMContext, lang: str, user: User):
    if user:
        # Если имя не указано
        if user.name is None:
            txt = (
                "<b>🎉</b>\nТеперь давай настроим твой профиль, чтобы ты мог(ла) быстрее найти интересных людей. 🌟\n\n➡️ Укажи свое имя, чтобы мы могли начать!"
                if lang == "ru" else
                "<b>🎉</b>\nNow let’s set up your profile so you can start meeting interesting people faster. 🌟\n\n➡️ Please provide your name to get started!"
            )
            await state.set_state(RegState.name)
            await message.answer(txt)
            return

        # Если имя указано, но пол не выбран
        if user.gender is None:
            txt = (
                f"<b>Отлично,{user.name}</b>\nТеперь укажи свой пол! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                f"<b>Great,{user.name}</b>\nNow specify your gender! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другой" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.gender)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если пол указан, но ориентация не выбрана
        if user.orientation is None:
            txt = (
                "Теперь укажи свою ориентацию! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                "Now specify your orientation! 🌟\n\n➡️ Choose one of the options:"
            )
            if user.gender == 'mal':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'fem':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'oth':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если ориентация указана, но не указаны предпочтения для просмотра
        if user.for_whom is None:
            txt = (
"Теперь укажи, кого ты хочешь видеть! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
"Now specify who you want to see! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_girls")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_boys")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_everyone")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если предпочтения для просмотра указаны, но возраст не указан
        elif user.age is None:
            txt = (
                "Теперь укажи свой возраст! 🌟\n\n➡️ Введите ваш возраст (минимум 16 лет):"
                if lang == "ru" else
                "Now specify your age! 🌟\n\n➡️ Enter your age (minimum 16 years):"
            )
            await state.set_state(RegState.age)
            await message.answer(txt)
            return
        # Если все данные собраны, переходим к следующему шагу
        if user.preferences is None:
            txt = (
                "Теперь укажи свои цели! 🌟\n\n➡️ Выбери цели из предложенных вариантов:"
                if lang == "ru" else
                "Now specify your goals! 🌟\n\n➡️ Choose your goals from the options provided:"
            )
            inline_keyboard=[]
            if lang =="ru":
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
            else:
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.preferences)
            await message.answer(txt, reply_markup=keyboard)
            return
        if user.location is None:

            keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )

            if lang == "ru":
                txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
            else:
                txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

            await state.set_state(RegState.location)
            msg = await message.bot.send_message(message.from_user.id ,text=txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)
            return
        if user.about is None:
            if lang == "ru":
                txt = """
Теперь расскажи немного о себе. 🌟

➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
"""
            else:
                txt = """
Now tell us a bit about yourself. 🌟

➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
"""
            await state.set_state(RegState.about)
            await message.bot.send_message(message.from_user.id, txt)
            return
        if user.hobbies is None:
            state_data = await state.get_data()
            current_page = state_data.get("current_page", 1)
            hobbies = state_data.get("selected_hobbies", [])  # Загружаем хобби из состояния или базы

            if len(hobbies) < 5:
                await state.set_state(RegState.hobbies)

                # Увлечения на двух языках с номерами
                interests = [
                    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
                    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
                    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
                    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
                    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
                    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
                    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
                    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
                    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
                    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
                    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
                    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
                    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
                    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
                    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
                    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
                ]
                page_size = 10
                start_index = (current_page - 1) * page_size
                end_index = start_index + page_size

                # Генерация кнопок для текущей страницы
                inlinekeyboard = []
                row = []

                for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
                    text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
                    row.append(InlineKeyboardButton(
                        text=text,
                        callback_data=f"intrs_{number}"
                    ))
                    if len(row) == 2 or i == len(interests[start_index:end_index]):
                        inlinekeyboard.append(row)
                        row = []

                # Добавляем кнопки навигации
                navigation_buttons = []
                if current_page > 1:
                    navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
                if end_index < len(interests):
                    navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
                if navigation_buttons:
                    inlinekeyboard.append(navigation_buttons)

                if len(hobbies) == 5:
                    inlinekeyboard.append(
                        [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)

                if lang == "ru":
                    if hobbies:
                        txt = f"<b>У вас уже выбрано {len(hobbies)}/5 увлечений ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми \"<b>Сохранить✅</b>\"."
                else:
                    if hobbies:
                        txt = f"<b>You have already selected {len(hobbies)}/5 hobbies ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\"."

                await state.update_data(current_page=current_page, hobbies=hobbies)  # Сохраняем данные в состояние
                await message.answer(txt, reply_markup=keyboard)
                return


        if user.medias is None:

            txt = """

Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """

Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
Or press "Skip" to continue. ⏩"""
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
            ])
            await state.set_state(RegState.media)
            data = await state.get_data()

            msg = await message.bot.send_message(chat_id=message.from_user.id, text=txt, reply_markup=keyboard)
            data["idmsg_media"] = msg.message_id
            await state.update_data(data=data)
            return
        else:
            
            if lang == "ru":
                button_text = "🚀 Начать поиск"
            else:
                button_text = "🚀 Start Search"

            keyboard = ReplyKeyboardMarkup(
                keyboard=[
                    [KeyboardButton(text=button_text)]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            )
            await set_user_specific_commands(message.bot, message.from_user.id, lang )
            response = (
        "ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль." 
        if lang == "ru" 
        else "ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."
    )
            await message.answer(response, reply_markup=keyboard)

            

            [FILE] middleware.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/middleware.py ---
import logging
from aiogram import BaseMiddleware, types
from aiogram.types import Update
from typing import Callable, Any, Awaitable
from aiogram.fsm.context import FSMContext
from src.models import User
from aiogram.types import CallbackQuery
from src.utils.generate_uid import generate_uid_code
from src.bot.handlers.registration import choise_lang


class LoggingMiddleware(BaseMiddleware):
    """
    Middleware for logging all incoming updates and outgoing responses,
    ensuring user profile completeness and language setup.
    """

    async def __call__(
        self,
        handler: Callable[[Update, dict], Awaitable[Any]],
        event: Update,
        data: dict,
    ) -> Any:
        # Логируем входящее событие
        logging.info(f"Incoming update: {event}")
        state: FSMContext
        state: FSMContext = data.get("state")  # FSMContext передается через data
        current_state = await state.get_state() if state else None
        # Получаем user_id из обновления
        user_id = event.from_user.id if event.from_user else None

        if user_id:
            # Проверяем, существует ли пользователь в базе данных
            user = await User.get_or_none(user_id=user_id)
            if user:
                if user.status_block == "Active":
                    data["user"] = user
                    
                    # Устанавливаем язык
                    if user.lang == "nochoise":
                        data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                        return await choise_lang(event, data)
                    else:
                        data["lang"] = user.lang

                    # Проверка на полноту профиля
                    
                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias
                    ]) and event.text and ("/start" not in event.text and "/del" not in event.text) and current_state is None:
                        message_text = (
                            "Кажется, ваш профиль заполнен не до конца. \u2028"
                            "Нажмите /start, чтобы заполнить профиль и скорее приступить к поиску нужных людей."
                            if user.lang == "ru" else
                            "It seems your profile is incomplete. \u2028"
                            "Press /start to complete your profile and start connecting with people."
                        )
                        if isinstance(event, types.Message):
                            await event.answer(message_text)
                        return
                else:
                    # Если пользователь заблокирован, возвращаем статус 403
                    if isinstance(event, types.Message):
                        await event.answer("Ваш аккаунт заблокирован." if user.lang == "ru" else "Your account is blocked.")
                    return 403
            else:
                # Новый пользователь
                uid_ref = None
                if event.text and "/start" in event.text:
                    parts = event.text.split(" ")
                    if len(parts) > 1:
                        uid_ref = parts[1]
                        ref_user = await User.get_or_none(uid_code=uid_ref)
                        if ref_user:
                            if ref_user.lang == "ru":
                                await event.bot.send_message(ref_user.user_id, "У вас новый реферал")
                            else:
                                await event.bot.send_message(ref_user.user_id, "You have a new referral")

                # Генерация UID
                users = await User.all().values_list("uid_code", flat=True)
                uid = await generate_uid_code(uids=users)

                # Создание нового пользователя
                user = await User.create(user_id=user_id, uid_code=uid, referral_uid=uid_ref)
                data["user"] = user
                data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                return await choise_lang(event, data)

        # Передаём управление следующему обработчику
        response = await handler(event, data)

        # Логируем ответ
        logging.info(f"Outgoing response: {response}")

        return response




class CallbackMiddleware(BaseMiddleware):
    """
    Middleware для обработки callback-запросов.
    Проверяет статус пользователя и передаёт язык пользователя.
    """

    async def __call__(
        self,
        handler: Callable[[CallbackQuery, dict], Awaitable[Any]],
        event: CallbackQuery,
        data: dict,
    ) -> Any:
        # Логируем входящее событие
        logging.info(f"Incoming callback query: {event}")

        # Получаем user_id из callback
        user_id = event.from_user.id if event.from_user else None

        if user_id:
            # Проверяем, существует ли пользователь в базе данных
            user = await User.get_or_none(user_id=user_id)
            if user:
                if user.status_block == "Active":
                    data["user"] = user
                    data["lang"] = user.lang or ("ru" if event.from_user.language_code in ["ru", "uk"] else "en")
                else:
                    # Если пользователь заблокирован, отправляем сообщение и возвращаем статус 403
                    await event.answer("Ваш аккаунт заблокирован.", show_alert=True)
                    return 403
            else:
                # Если пользователь отсутствует, предлагаем выбрать язык
                data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                if event.data == "lang_ru" or event.data == "lang_en":
                    data["lang"] = "ru" if event.data == "lang_ru" else "en"
                    return await handler(event, data)
                return await choise_lang(event.message, data)

        # Передаём управление следующему обработчику
        response = await handler(event, data)

        # Логируем ответ
        logging.info(f"Outgoing response for callback query: {response}")

        return response


            [FILE] state.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/state.py ---
from aiogram.fsm.state import StatesGroup
from aiogram.fsm.state import State


class RegState(StatesGroup):

    name =State()
    age = State()
    gender = State()
    preferences = State()
    location = State()
    about = State()
    media = State()
    hobbies = State()
    show = State()
    orientation = State()
    done = State()




class SearchPeople(StatesGroup):
    search = State()
    like = State()
    superlike = State()
    dislike = State()
    block = State()
    report = State()
    stop = State()
    message = State()
    show = State()
    show_profile = State()
    show_media = State()
    show_hobbies = State()
    show_about = State()
    show_location = State()
    show_preferences = State()


class ReditState(StatesGroup):

    name =State()
    age = State()
    gender = State()
    preferences = State()
    location = State()
    about = State()
    media = State()
    hobbies = State()
    show = State()
    orientation = State()
    done = State()
 

        [DIR] __pycache__
            [FILE] models.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/__pycache__/models.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [DIR] bot
            [DIR] __pycache__
                [FILE] config.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/__pycache__/config.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [DIR] handlers
                [FILE] registration.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/registration.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.types import InputMediaPhoto, InputMediaVideo
from src.utils.state import RegState
from src.utils.generate_uid import generate_uid_code

from src.utils.comands import set_user_specific_commands, delete_user_specific_commands
import random

from aiogram.types import WebAppInfo, InlineKeyboardMarkup, InlineKeyboardButton

def get_web_app_button():
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(
                text="🔍 Найти пользователей",
                web_app=WebAppInfo(url="https://6ef0-162-213-64-84.ngrok-free.app/profile/cards/")
            )]
        ]
    )
router = Router()

@router.message(Command("search"))
async def start_search(message: types.Message):
    button = get_web_app_button()
    await message.answer("Нажмите кнопку ниже, чтобы начать поиск пользователей:", reply_markup=button)



@router.message(CommandStart())
async def handle_message1(message: types.Message, state: FSMContext, lang: str, user: User = None, user_none: bool = False):
    if user:
        # Если имя не указано
        if user.name is None:
            txt = (
                "<b>🎉</b>\nТеперь давай настроим твой профиль, чтобы ты мог(ла) быстрее найти интересных людей. 🌟\n\n➡️ Укажи свое имя, чтобы мы могли начать!"
                if lang == "ru" else
                "<b>🎉</b>\nNow let’s set up your profile so you can start meeting interesting people faster. 🌟\n\n➡️ Please provide your name to get started!"
            )
            await state.set_state(RegState.name)
            await message.answer(txt)

        # Если имя указано, но пол не выбран
        elif user.name is not None and user.gender is None:
            txt = (
                f"<b>Отлично,{user.name}</b>\nТеперь укажи свой пол! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                f"<b>Great,{user.name}</b>\nNow specify your gender! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другой" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.gender)
            await message.answer(txt, reply_markup=keyboard)

        # Если пол указан, но ориентация не выбрана
        elif user.name is not None and user.gender is not None and user.orientation is None:
            txt = (
                "Теперь укажи свою ориентацию! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                "Now specify your orientation! 🌟\n\n➡️ Choose one of the options:"
            )
            if user.gender == 'mal':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'fem':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'oth':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await message.answer(txt, reply_markup=keyboard)

        # Если ориентация указана, но не указаны предпочтения для просмотра
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is None:
            txt = (
"Теперь укажи, кого ты хочешь видеть! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
"Now specify who you want to see! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_everyone")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await message.answer(txt, reply_markup=keyboard)

        # Если предпочтения для просмотра указаны, но возраст не указан
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.age is None:
            txt = (
                "Теперь укажи свой возраст! 🌟\n\n➡️ Введите ваш возраст (минимум 16 лет):"
                if lang == "ru" else
                "Now specify your age! 🌟\n\n➡️ Enter your age (minimum 16 years):"
            )
            await state.set_state(RegState.age)
            await message.answer(txt)

        # Если все данные собраны, переходим к следующему шагу
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.age is not None and user.preferences is None:
            txt = (
                "Теперь укажи свои цели! 🌟\n\n➡️ Выбери цели из предложенных вариантов:"
                if lang == "ru" else
                "Now specify your goals! 🌟\n\n➡️ Choose your goals from the options provided:"
            )
            inline_keyboard=[]
            if lang =="ru":
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
            else:
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.preferences)
            await message.answer(txt, reply_markup=keyboard)
        elif user.name is not None and user.age is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is None:

            keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )

            if lang == "ru":
                txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
            else:
                txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

            await state.set_state(RegState.location)
            msg = await message.bot.send_message(message.from_user.id ,text=txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)

        elif user.name is not None and user.age is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is None:
            if lang == "ru":
                txt = """
Теперь расскажи немного о себе. 🌟

➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
"""
            else:
                txt = """
Now tell us a bit about yourself. 🌟

➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
"""
            await state.set_state(RegState.about)
            await message.bot.send_message(message.from_user.id, txt)
        elif user.name is not None and user.age is not None and user.gender is not None and user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is not None and user.hobbies is None:
            state_data = await state.get_data()
            current_page = state_data.get("current_page", 1)
            hobbies = state_data.get("selected_hobbies", [])  # Загружаем хобби из состояния или базы

            if len(hobbies) < 5:
                await state.set_state(RegState.hobbies)

                # Увлечения на двух языках с номерами
                interests = [
                    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
                    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
                    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
                    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
                    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
                    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
                    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
                    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
                    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
                    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
                    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
                    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
                    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
                    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
                    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
                    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
                ]
                page_size = 10
                start_index = (current_page - 1) * page_size
                end_index = start_index + page_size

                # Генерация кнопок для текущей страницы
                inlinekeyboard = []
                row = []

                for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
                    text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
                    row.append(InlineKeyboardButton(
                        text=text,
                        callback_data=f"intrs_{number}"
                    ))
                    if len(row) == 2 or i == len(interests[start_index:end_index]):
                        inlinekeyboard.append(row)
                        row = []

                # Добавляем кнопки навигации
                navigation_buttons = []
                if current_page > 1:
                    navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
                if end_index < len(interests):
                    navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
                if navigation_buttons:
                    inlinekeyboard.append(navigation_buttons)

                if len(hobbies) == 5:
                    inlinekeyboard.append(
                        [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)

                if lang == "ru":
                    if hobbies:
                        txt = f"<b>У вас уже выбрано {len(hobbies)}/5 увлечений ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми \"<b>Сохранить✅</b>\"."
                else:
                    if hobbies:
                        txt = f"<b>You have already selected {len(hobbies)}/5 hobbies ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\"."

                await state.update_data(current_page=current_page, hobbies=hobbies)  # Сохраняем данные в состояние
                await message.answer(txt, reply_markup=keyboard)


        elif user.name is not None and user.age is not None and user.gender is not None and user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is not None and user.hobbies is not None and user.medias is None:

            txt = """

Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """

Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
Or press "Skip" to continue. ⏩"""
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
            ])
            await state.set_state(RegState.media)
            data = await state.get_data()

            msg = await message.bot.send_message(chat_id=message.from_user.id, text=txt, reply_markup=keyboard)
            data["idmsg_media"] = msg.message_id
            await state.update_data(data=data)

        else:
            
            if lang == "ru":
                button_text = "🚀 Начать поиск"
            else:
                button_text = "🚀 Start Search"

            keyboard = ReplyKeyboardMarkup(
                keyboard=[
                    [KeyboardButton(text=button_text)]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            )
            await set_user_specific_commands(message.bot, message.from_user.id, lang )
            response = (
        "ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль." 
        if lang == "ru" 
        else "ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."
    )
            await message.answer(response, reply_markup=keyboard)

            
        









@router.message(Command("block"))
async def handle_message(message: types.Message, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    # if user:
    #     user.status_block="Deactive"
    #     await user.save()
    await delete_user_specific_commands(message.bot, message.from_user.id)

    

@router.message(Command("del"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    
    if user:
        await user.delete()
        # await user.save()


# Список столиц мира с их координатами
WORLD_CAPITALS = [
    ("Moscow", 55.7558, 37.6173),
    ("Washington, D.C.", 38.9072, -77.0369),
    ("London", 51.5074, -0.1278),
    ("Tokyo", 35.6895, 139.6917),
    ("Paris", 48.8566, 2.3522),
    ("Berlin", 52.5200, 13.4050),
    ("Beijing", 39.9042, 116.4074),
    ("Canberra", -35.2809, 149.1300),
    ("Ottawa", 45.4215, -75.6972),
    ("Brasília", -15.8267, -47.9218)
]
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"fem":"👩 Девушки",
    "mal":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "fem":"👩 Girls",
    "mal":"👨 Boys",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"💫Другая",
                "skip":"Не указана"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"💫Other",
                "skip":"Not specified"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}


async def generate_random_profiles():
    interests = [interest[1] for interest in INTERESTS]

    for _ in range(200):
        # Случайный выбор пола, ориентации и других параметров
        gender = random.choice(list(GENDER["en"].keys()))
        orientation = random.choice(list(ORI["en"].keys()))
        for_whom = random.choice(list(WHO["en"].keys()))
        preference = random.choice(list(PREFERENCES["en"].keys()))

        # Случайная локация
        city, latitude, longitude = random.choice(WORLD_CAPITALS)
        location = f"{latitude},{longitude}"

        # Случайные увлечения (до 5)
        hobbies = random.sample(interests, k=random.randint(1, 5))

        # Случайное имя и описание
        name = f"User{random.randint(1000, 9999)}"
        about = "I love " + ", ".join(random.sample(interests, k=2)) + "."
        media=[]
        media_data = {
                    "file_id": 'AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ',
                    "type": "photo" 
                }
        users = await User.all().values_list("uid_code", flat=True)
        uid = await generate_uid_code(uids=users)
        media.append(media_data)
        # Создание пользователя
        await User.create(
            name=name,
            age=random.randint(18, 50),
            gender=gender,
            orientation=orientation,
            for_whom=for_whom,
            preferences=preference,
            location=location,
            about=about,
            hobbies=hobbies,
            medias=None,
            uid_code=uid,
            lang='ru' # Медиаданные остаются пустыми

        )

    print("200 random profiles created successfully!")
@router.message(Command("add"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    await generate_random_profiles()
    await message.answer("200 случайных профилей успешно созданы!")

        
@router.message(Command("del1"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    
    if user:
        user.age=None
        await user.save()


async def choise_lang(message: types.Message, lang: str):
    if lang['lang']=="ru":
    
        txt="""<b>Привет! 👋</b>
На связи <b>💖Emi-Date💖</b> — твой помощник в мире знакомств для людей в эмиграции. 🌍✨

Чтобы начать, пожалуйста, выбери язык, который тебе удобен:
"""
    else:
        txt="""<b>Hi there! 👋</b>
Welcome to <b>💖Emi-Date💖</b> — your go-to bot for connecting with people in emigration. 🌍✨

To get started, please select your preferred language:
"""
    
    # Кнопки для выбора языка
    
    inline_keyboard=[]
    inline_keyboard.append([InlineKeyboardButton(text="🇷🇺 Русский", callback_data="lang_ru")])
    inline_keyboard.append([InlineKeyboardButton(text="🇺🇸 English", callback_data="lang_en")])

    keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)

    await message.answer(text=txt, reply_markup=keyboard)




@router.message(Command("album"))
async def handle_message(message: types.Message, user: User = None, user_none: bool = False):

    media_files = [
        InputMediaPhoto(media='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'),
        InputMediaPhoto(media='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'),
        # Добавьте до 10 медиафайлов
    ]

    # Отправка медиа-группы
    await message.bot.send_media_group(chat_id=message.from_user.id, media=media_files)










@router.callback_query(lambda c: "lang_" in c.data)
async def callback_handler(callback_query: CallbackQuery, state: FSMContext, lang: str):
    lang = (callback_query.data.split("_"))[1]
    user_id = callback_query.from_user.id
    user= await User.get_or_none(user_id=user_id)
    if user:
        user.lang=lang
        await user.save()
    if user.name==None:
        keyboard = None
        if lang == "ru":
            txt = """<b>Отлично! 🎉</b>
Нажми /start, чтобы быстрее найти интересных людей. 🌟

"""
        else:
            txt = """<b>Great! 🎉</b
Tap /start to quickly find interesting people. 🌟
    """
        await callback_query.bot.edit_message_text(text=txt, chat_id=user_id, message_id=callback_query.message.message_id, reply_markup=None)
        
       


  







                [FILE] likes.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/likes.py ---


                [FILE] anketa.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/anketa.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from src.utils.add_profile import add_profile
from aiogram.types import ContentType


router = Router()
BAD_WORDS = [
    # Наркотики
    "наркотик", "наркота", "косяк", "травка", "гашиш", "героин", "кокаин", "амфетамин", "экстази",
    "марихуана", "спайс", "лсд", "шишки", "опиум", "план", "кристалл", "мефедрон", "drugs", "drug",
    "weed", "marijuana", "cocaine", "heroin", "ecstasy", "meth", "amphetamine", "hash", "spice",
    "lsd", "crystal", "meph", "opium", "j0int", "dr@g", "tr@vka",

    # CP
    "детская порнография", "детское порно", "запрещенное видео", "нелегальный контент", "порнография с детьми",
    "cp", "child porn", "child pornography", "illegal content", "b@nned video", "ch!ld p0rn",

    # Оружие
    "оружие", "пистолет", "винтовка", "автомат", "пулемет", "граната", "мина", "бомба", "арсенал",
    "ружье", "ствол", "калашников", "ак-47", "глок", "гранатомет", "weapon", "gun", "pistol", "rifle",
    "machine gun", "grenade", "bomb", "landmine", "arsenal", "shotgun", "kalashnikov", "ak47",
    "glock", "rocket launcher", "we@pon", "glock-19", "b0mb",

    # Additional prohibited words
    "explosive", "tnt", "c4", "detonator", "silencer", "sniper", "assault rifle", "pipe bomb",
    "наркот", "герич", "герыч", "доза", "спайсы", "соли", "фен", "скорость",
    "запрещенка", "порно с детьми", "порево", "kill", "murder", "mass shooting", "terrorist", "attack"
]






# ++++++++++++++++ NAME +++++++++++++++

@router.message(RegState.name)
async def set_name(message: types.Message, state: FSMContext, lang: str):
    user = await User.get_or_none(user_id=message.from_user.id)
    global BAD_WORDS
    if user:
        
        if message.text not in BAD_WORDS:
            user.name = message.text.strip()
            await user.save()
            if user.gender is None:
                
                if lang == "ru":
                    txt = """<b>Имя указано! ✅</b>
    Отлично, теперь укажи свой пол! 🌟

    ➡️ Выбери один из вариантов:
    """
                else:
                    txt = """<b>Name provided! ✅</b>
    Great, now specify your gender! 🌟

    ➡️ Choose one of the options:
    """

                inline_keyboard = [
                    [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                    [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                    [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
                ]

                keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
                await state.set_state(RegState.gender)
                await message.answer(txt, reply_markup=keyboard)
            else:
                txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
                await state.set_state(state=None)

                
                if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=message, state=state , user=user, lang=lang)
                else:
                    await message.answer(txt)

        else:
            txt = """<❌ <b>Ошибка:</b> Ваше имя содержит запрещенные слова. Пожалуйста, выберите другое имя. ✍️""" if lang == "ru" else """<❌ <b>Error:</b> Your name contains prohibited words. Please choose another name. ✍️"""
            await state.set_state(RegState.name)
            await message.answer(txt)
        
# ++++++++++++++++ GENDER +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("gender_"), RegState.gender)
async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.gender = callback_query.data.split("_")[1]
        await user.save()
        if user.orientation is None:
            if lang == "ru":
                txt = """<b>Пол указан! ✅</b>
    Теперь укажи свою ориентацию! 🌟

    ➡️ Выбери один из вариантов:
    """
            else:
                txt = """<b>Gender saved! ✅</b>
    Now specify your orientation! 🌟

    ➡️ Choose one of the options:
    """
            if user.gender =='mal':

                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender =="fem":
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender=="oth":
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]

            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)
# ++++++++++++++++ ORIENTATION +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("orientation_"), RegState.orientation)
async def set_orientation(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.orientation = callback_query.data.split("_")[1]
        await user.save()
        if user.for_whom is None:
            if lang == "ru":
                txt = """<b>Ориентация указана! ✅</b>
    Теперь укажи, кого ты хочешь видеть! 🌟

    ➡️ Выбери один из вариантов:
    """
            else:
                txt = """<b>Orientation saved! ✅</b>
    Now specify who you want to see! 🌟

    ➡️ Choose one of the options:
    """

            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")]
            ]

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ SHOW PREFERENCES +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("show_"), RegState.show)
async def set_show_preferences(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.for_whom = callback_query.data.split("_")[1]
        await user.save()
        if user.age is None:
            if lang == "ru":
                txt = """<b>Параметры просмотра указаны! ✅</b>
    Теперь укажи свой возраст! 🌟

    ➡️ Введите ваш возраст (минимум 16 лет):
    """
            else:
                txt = """<b>Viewing preferences saved! ✅</b>
    Now specify your age! 🌟

    ➡️ Enter your age (minimum 16 years):
    """

            await state.set_state(RegState.age)
            await callback_query.message.edit_text(txt)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ AGE +++++++++++++++

@router.message(RegState.age)
async def set_age(message: types.Message, user: User, state: FSMContext, lang: str):
    if user:
        if message.text.isdigit():
            age = int(message.text)
            if age >= 16:
                user.age = age
                await user.save()
                if user.preferences is None:
                    if lang == "ru":
                        txt = """<b>Возраст указан! ✅</b>
    Теперь укажи свои цели! 🌟

    ➡️ Выбери цели из предложенных вариантов:
    """
                    else:
                        txt = """<b>Age saved! ✅</b>
    Now specify your goals! 🌟

    ➡️ Choose your goals from the options provided:
    """
                    inline_keyboard=[]
                    if lang =="ru":
                        inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                        inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                        inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                        inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
                    else:
                        inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                        inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                        inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                        inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])


                    keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
                    await state.set_state(RegState.preferences)
                    await message.answer(txt, reply_markup=keyboard)
                else:
                    txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
                    await state.set_state(state=None)

                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                        await add_profile(message=message, state=state , user=user, lang=lang)
                    else:
                        await message.answer(txt)
            else:
                txt = """❌ <b>Ошибка:</b> Возраст должен быть не менее 16 лет. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be at least 16 years. 🔢"""
                await message.answer(txt)
        else:
            txt = """❌ <b>Ошибка:</b> Возраст должен быть числом. Пожалуйста, введите корректное значение. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be a number. Please enter a valid value. 🔢"""
            await message.answer(txt)


# ++++++++++++++++ PREFERENCES +++++++++++++++

@router.callback_query(lambda c: "interest_" in c.data, RegState.preferences)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
    if user:
        pref = callback_query.data.split("_")[1]
        user.preferences=pref
        await user.save()
        if user.location is None:
            keyboard = ReplyKeyboardMarkup(
                keyboard=[[ KeyboardButton(text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",request_location=True)]],resize_keyboard=True,one_time_keyboard=True)

            if lang == "ru":
                txt = """<b>Цели поиска указаны! ✅</b>
    Отлично, теперь нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍

    ⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

    💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
    Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

    ➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
    """
            else:
                txt = """<b>Search goals saved! ✅</b>
    Great, now we need your location to suggest people nearby. 🌍

    ⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

    💡 <b>Note:</b> You can send your current location by pressing the button below. 
    If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

    ➡️ Please press the button below to share your location or choose a point on the map.
    """

            await state.set_state(RegState.location)
            await callback_query.bot.delete_message(callback_query.from_user.id, callback_query.message.message_id)
            msg= await callback_query.bot.send_message(callback_query.from_user.id, txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ LOCATION +++++++++++++++

@router.message(RegState.location, lambda message: message.content_type == ContentType.LOCATION)
async def set_location(message: types.Message, user: User, state: FSMContext, lang: str):
    
    if user:
        print(f"\n\n\n\n\n\n\n\n\n\n\n\n\n\n{message.location}\n\n\n\n\n\n\n\n\n\n\n\n{message.location.model_config}")
        user.location = f"{message.location.latitude},{message.location.longitude}"
        await user.save()
        if user.about is None:
            if lang == "ru":
                txt = """<b>Локация указана! ✅</b>
    Отлично, теперь расскажи немного о себе. 🌟

    ➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
    """
            else:
                txt = """<b>Location saved! ✅</b>
    Great, now tell us a bit about yourself. 🌟

    ➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
    """
            await state.set_state(RegState.about)
            data = await state.get_data()
            if "idmsg_local" in data: 
                await message.bot.delete_message(message.from_user.id, data["idmsg_local"])
            data["idmsg_local"]=''
            await state.update_data(data)
            await message.bot.delete_message(message.from_user.id, message.message_id)
            await message.bot.send_message(message.from_user.id, txt)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=message, state=state , user=user, lang=lang)
            else:
                await message.answer(txt)
# ++++++++++++++++ ABOUT +++++++++++++++

@router.message(RegState.about)
async def set_about(message: types.Message, user: User, state: FSMContext, lang: str):
    global BAD_WORDS
    if user:
        if message.text:
            if message.text not in BAD_WORDS:
                user.about = message.text
                await user.save()
                if user.hobbies is None:
                
                    await state.set_state(RegState.hobbies)
                # Увлечения на двух языках с номерами
                    interests = [
                        (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
                    ]
                    inlinekeyboard = []
                    row = []

                    # Формируем кнопки для увлечений, по 3 в ряд
                    for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
                        row.append(InlineKeyboardButton(
                            text=interest_ru if lang == "ru" else interest_en,
                            callback_data=f"intrs_{number}"
                        ))
                        # Если добавлено 3 кнопки или это последняя кнопка в списке
                        if len(row) == 2 or i == len(interests[:10]):
                            inlinekeyboard.append(row)
                            row = []  # Сбрасываем строку для следующего ряда

                    # Добавляем стрелки навигации в последнюю строку
                    inlinekeyboard.append([
                        InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
                        InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
                    ])

                    keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
                    
                    if lang == "ru":
                        txt = """<b>Записали ✅</b>
    Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟

    ➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
        """
                    else:
                        txt = """<b>Saved ✅</b>
    Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
    """


                    await message.answer(txt, reply_markup=keyboard)
                else:
                    txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."
                    await state.set_state(state=None)

                    
                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                        await add_profile(message=message, state=state , user=user, lang=lang)
                    else:
                        await message.answer(txt)
            else:
                if lang == "ru":
                    txt = """❌ <b>Ошибка:</b> Описание содержит запрещенные слова. Пожалуйста, введите другое описание и попробуйте снова. ✍️"""
                else:
                    txt = """❌ <b>Error:</b> The description contains prohibited words. Please enter another description and try again. ✍️"""
                await message.answer(txt)
                await state.set_state(RegState.about)
        else:
                if lang == "ru":
                    txt = """❌ <b>Ошибка:</b> Описание долджно содержать текст ✍️"""
                else:
                    
                    txt = """❌ <b>Error:</b> The description must contain text. Please write something ✍️"""
                await message.answer(txt)
                await state.set_state(RegState.about)

# ++++++++++++++++ HOBBIES +++++++++++++++

@router.callback_query(lambda c: "intrs_" in c.data or c.data.startswith("intrs_page") or c.data == "intrs_done", RegState.hobbies)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    # Загружаем список интересов
    interests = [
        (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]

    # Обработка страниц
    state_data = await state.get_data()
    current_page = state_data.get("current_page", 1)
    hobbies = state_data.get("selected_hobbies", [])

    if callback_query.data.startswith("intrs_page"):
        if "next" in callback_query.data:
            current_page += 1
        elif "back" in callback_query.data:
            current_page -= 1
        await state.update_data(current_page=current_page)

    elif callback_query.data.startswith("intrs_") and callback_query.data != "intrs_done":
        interest = callback_query.data.split("_")[1]
        if interest in hobbies:
            hobbies.remove(interest)
        else:
            if len(hobbies) < 5:
                hobbies.append(interest)
            else:
                txt1 = "Выбрано максимальное количество! Уберите один интерес или нажмите 'Сохранить'." if lang == "ru" else "Maximum number selected! Remove one interest or click 'Save'."
                await callback_query.answer(
                    txt1,
                    show_alert=True
                )
                return
        await state.update_data(selected_hobbies=hobbies)

    elif callback_query.data == "intrs_done":
        if len(hobbies) < 5:
            txt2 = "Вы должны выбрать минимум 5 интересов, чтобы продолжить!" if lang == "ru" else "You must select at least 5 interests to continue!"
            await callback_query.answer(
                txt2,
                show_alert=True
            )
            return
        else:
            user.hobbies = hobbies  # Сохраняем в базу данных только при завершении
            await user.save()
            if user.medias is None:
                txt3 = "Интересы сохранены! ✅" if lang == "ru" else "Interests saved! ✅"
                await callback_query.answer(txt3, show_alert=True)

                txt = """🎉 <b>Отлично!</b> Ваши хобби успешно сохранены.  

    Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
    Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """🎉 <b>Great!</b> Your hobbies have been successfully saved.  

    Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
    Or press "Skip" to continue. ⏩"""

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
                ])
                data = await state.get_data()
                msg =await callback_query.message.edit_text(txt, reply_markup=keyboard)
                data['idmsg_media']=msg.message_id
                await state.update_data(data)
                await state.set_state(RegState.media)
                return
            else:
                txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."
                await state.set_state(state=None)
                await callback_query.answer(txt, show_alert=True)

                if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
                else:
                    await callback_query.message.edit_text(txt, reply_markup=None)
                return

    # Генерация кнопок для текущей страницы
    page_size = 10
    start_index = (current_page - 1) * page_size
    end_index = start_index + page_size
    inlinekeyboard = []
    row = []

    for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
        text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
        row.append(InlineKeyboardButton(
            text=text,
            callback_data=f"intrs_{number}"
        ))
        if len(row) == 2 or i == len(interests[start_index:end_index]):
            inlinekeyboard.append(row)
            row = []

    navigation_buttons = []
    if current_page > 1:
        navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
    if end_index < len(interests):
        navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
    if navigation_buttons:
        inlinekeyboard.append(navigation_buttons)

    if len(hobbies) == 5:
        inlinekeyboard.append(
            [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
        )

    keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
    txt = (f"<b>Выбрано {len(hobbies)}/5 увлечений ✅</b>\n" if lang == "ru" else f"<b>Selected {len(hobbies)}/5 hobbies ✅</b>\n")
    txt += "Отлично, выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми 'Сохранить'." if lang == "ru" else "Great, select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click 'Save'."

    await callback_query.message.edit_text(txt, reply_markup=keyboard)

                [FILE] myprofile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/myprofile.py ---
from aiogram import Router, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo
from src.models import User
from aiogram.filters import CommandStart, Command
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState

router = Router()

# Словари переводов
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"fem":"👩 Девушки",
    "mal":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "fem":"👩 fem",
    "mal":"👨 mal",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"💫Другая",
                "skip":"Не указана"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"💫Other",
                "skip":"Not specified"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}

import ssl
import certifi
from geopy.geocoders import Nominatim

def get_location_by_coordinates(latitude, longitude):
    geolocator = Nominatim(
        user_agent="my_geopy_app",
        timeout=10,
        ssl_context=ssl.create_default_context(cafile=certifi.where())
    )
    try:
        location = geolocator.reverse((latitude, longitude), exactly_one=True)
        if location:
            address = location.raw.get('address', {})
            city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
            return city or location.address
        else:
            return "Местоположение не найдено"
    except Exception as e:
        return f"Ошибка при определении местоположения: {e}"
    

@router.message(Command("myprofile"))
async def my_profile_handler(message: types.Message,state: FSMContext):
    user = await User.get_or_none(user_id=message.from_user.id)

    if not user:
        lang = "ru"
        await message.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
        return

    lang = user.lang if user.lang in ["ru", "en"] else "ru"
    hobbies_text = ", ".join([
        (interest[1] if lang == "ru" else interest[2])
        for interest in INTERESTS
        if str(interest[0]) in (user.hobbies or [])
    ])

    location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
    if "," in location_text:
        latitude, longitude = map(float, location_text.split(","))
        location_text = get_location_by_coordinates(latitude, longitude)

    subscription_text = (
        f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
    )
    if user.subscription != "Free":
        subscription_text += (
            f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
        )

    description = (
        f"<b>{'Ваш профиль' if lang == 'ru' else 'Your profile'}:</b>\n\n"
        f"<b>{'Имя' if lang == 'ru' else 'Name'}:</b> {user.name}\n"
        f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
        f"<b>{'Пол' if lang == 'ru' else 'Gender'}:</b> {GENDER[lang][user.gender]}\n"
        f"<b>{'Локация' if lang == 'ru' else 'Location'}:</b> {location_text or ('Локация не указана' if lang == 'ru' else 'Location not provided')}\n\n"
        f"{subscription_text}"
        f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
        f"<b>{'Кого показывать' if lang == 'ru' else 'Viewing Preferences'}:</b> {WHO[lang][user.for_whom]}\n"
        f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
        f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
        f"_________________________\n{user.about or ''}\n"
    )



    media = user.medias or []
    if len(media) == 1:
        media_file = media[0]['file_id']
        if media[0]['type'] == 'photo':
            msg= await message.bot.send_photo(message.from_user.id, media_file, caption=description)
        elif media[0]['type'] == 'video':
            msg= await message.bot.send_video(message.from_user.id, media_file, caption=description)
    else:
        files=[]
        i =0
        for media_file in media:
            
            caption=description if i == 0 else None
            
            if media_file["type"] =="video":
                files.append(InputMediaVideo(media=f"{media_file['file_id']}", caption=caption))
                i = i+1
            elif media_file['type'] == 'photo':
                files.append(InputMediaPhoto(media=f"{media_file['file_id']}", caption=caption))
                i = i+1
            else:
                continue
                 

    # Отправка медиа-группы
        msg= await message.bot.send_media_group(chat_id=message.from_user.id, media=files)
        data= await state.get_data()
        data["id_card_profile"]=None
        await state.update_data(data=data)
    lang = user.lang if user and user.lang in ["ru", "en"] else "ru"
    if user.localstatus == "active":
        btn_local = InlineKeyboardButton(
            text="🌍 Скрыть локацию" if lang == "ru" else "🌍 Hide Location",
            callback_data="location_hish"
        )
    else:
        btn_local = InlineKeyboardButton(
            text="🌍 Показать локацию" if lang == "ru" else "🌍 Show Location",
            callback_data="location_hish"
        )

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="🖋 Имя" if lang == "ru" else "🖋 Name",
                callback_data="fedit_name"
            ),
            InlineKeyboardButton(
                text="🎂 Возраст" if lang == "ru" else "🎂 Age",
                callback_data="fedit_age"
            )
        ],
        [
            InlineKeyboardButton(
                text="📍 Изменить локацию" if lang == "ru" else "📍 Edit Location",
                callback_data="fedit_location"
            ),
            btn_local
        ],
        [
            InlineKeyboardButton(
                text="⚥ Пол" if lang == "ru" else "⚥ Gender",
                callback_data="fedit_gender"
            ),
            InlineKeyboardButton(
                text="🌈 Ориентация" if lang == "ru" else "🌈 Orientation",
                callback_data="fedit_orientation"
            )
        ],
        [
            InlineKeyboardButton(
                text="👁️‍🗨️ Кого показывать" if lang == "ru" else "👁️‍🗨️ Viewing Preferences",
                callback_data="fedit_pref"
            ),
            InlineKeyboardButton(
                text="🎯 Цели" if lang == "ru" else "🎯 Goals",
                callback_data="fedit_goals"
            )
        ],
        [
            InlineKeyboardButton(
                text="🎨 Увлечения" if lang == "ru" else "🎨 Hobbies",
                callback_data="fedit_hobbies"
            ),
            InlineKeyboardButton(
                text="📝 Описание" if lang == "ru" else "📝 Description",
                callback_data="fedit_descr"
            )
        ],[
    InlineKeyboardButton(
        text="🖼️ Изменить медиа" if lang == "ru" else "🖼️ Edit Media",
        callback_data="fedit_media"
    )
],

        [
            InlineKeyboardButton(
                text="🔄 Заполнить заново" if lang == "ru" else "🔄 Refill Profile",
                callback_data="reset_profile"
            )
        ]
    ])


    await message.answer(
        MESSAGES["action_prompt"][lang], 
        reply_markup=keyboard
    )


                [DIR] __pycache__
                    [FILE] myproffile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/myproffile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] edit_profile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/edit_profile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] serch.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/serch.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] anketa.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/anketa.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] registration.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/registration.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] myprofile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/myprofile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] edit_profile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/edit_profile.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType
from src.utils.comands import set_user_specific_commands
from aiogram import Router, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo
from src.models import User
from aiogram.filters import CommandStart, Command
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from src.utils.add_profile import add_profile



# Словари переводов
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"girls":"👩 Девушки",
    "boys":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "girls":"👩 Girls",
    "boys":"👨 Boys",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"Другая"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"Other"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}

import ssl
import certifi
from geopy.geocoders import Nominatim

def get_location_by_coordinates(latitude, longitude):
    geolocator = Nominatim(
        user_agent="my_geopy_app",
        timeout=10,
        ssl_context=ssl.create_default_context(cafile=certifi.where())
    )
    try:
        location = geolocator.reverse((latitude, longitude), exactly_one=True)
        if location:
            address = location.raw.get('address', {})
            city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
            return city or location.address
        else:
            return "Местоположение не найдено"
    except Exception as e:
        return f"Ошибка при определении местоположения: {e}"

router = Router()

                # "🖋 Имя" if 🖋 Name",callback_data="fedit_name"
                # "🎂 Возраст" if 🎂 Age",callback_data="fedit_age"
                # "📍 Изменить локацию" if 📍 Edit Location",callback_data="fedit_location"
                # "⚥ Пол" if ⚥ Gender",callback_data="fedit_gender"            
                # "🌈 Ориентация" if 🌈 Orientation",callback_data="fedit_orientation"
                # "👁️‍🗨️ Кого показывать" if 👁️‍🗨️ Viewing Preferences",callback_data="fedit_pref"
                # "🎯 Цели" if 🎯 Goals",callback_data="fedit_goals"           
                # "🎨 Увлечения" if 🎨 Hobbies",callback_data="fedit_hobbies"
                # "📝 Описание" if 📝 Description",callback_data="fedit_descr"
            

@router.callback_query(lambda c: c.data.startswith("fedit_"))
async def set_edit_field(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    cb_data = (callback_query.data.split("_"))[1]
    data = await state.get_data()
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="Назад⬅️" if lang == "ru" else "Back⬅️",
                callback_data="fedit_back"
            )
        ]
    ])

    if cb_data == "name":
        txt = "🌟➡️ Укажи свое имя, чтобы мы могли начать!\n\nИли надмите <b>'назад⬅️'</b> чтобы отменить действвие " if lang == "ru" else "🌟➡️ Please provide your name to get started!\n\nOr press <b>'back⬅️'</b> to undo the action"
        data = await state.get_data()
        await state.set_state(RegState.name)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "age":
        txt = "🎂➡️ Укажи свой возраст, чтобы продолжить!\n(минимум 16 лет):\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "🎂➡️ Please provide your age to proceed!\n(minimum 16 years):\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.age)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "location":
        if lang == "ru":
            txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
        else:
            txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

        data = await state.get_data()
        keyboard1 = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        await state.set_state(RegState.location)
        txt1="Жду локаци..." if lang=="ru" else "Waiting for the location..."
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        msg1 = await callback_query.bot.send_message(callback_query.from_user.id, txt1, reply_markup=keyboard1)
        data["idmsg_local"] = msg1.message_id
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data == "gender":
        txt = "⚥➡️ Укажи свой пол, чтобы мы могли лучше настроить профиль!\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "⚥➡️ Please specify your gender to better customize your profile!\n\nOr press <b>'back⬅️'</b> to undo the action."
        # Добавляем кнопки для выбора пола
        inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")],
                [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
            ]

        keyboard1 = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        msg= await callback_query.message.edit_text(txt, reply_markup=keyboard1)
        data = await state.get_data()
        await state.set_state(RegState.gender)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "orientation":
        if user.gender =='mal':

            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]
        elif user.gender =="fem":
            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]
        elif user.gender=="oth":
            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]


        inline_keyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard1 = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        txt = "🌈➡️ Укажи свою ориентацию, чтобы мы могли найти подходящих людей!\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "🌈➡️ Please specify your orientation so we can find the right people for you!\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.orientation)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard1)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "pref":
        txt = "👁️‍🗨️➡️ Укажи, кого ты хочешь видеть в своей ленте: девушек, парней или всех!\n\nИли нажми <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "👁️‍🗨️➡️ Specify who you want to see in your feed: girls, boys, or everyone!\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.show)
        inline_keyboard = [
            [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
            [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
            [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")],
            [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
        ]

        keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "goals":
        if lang == "ru":
            txt = """Укажи свои цели! 🌟

➡️ Выбери цели из предложенных вариантов:
"""
        else:
            txt = """<Specify your goals! 🌟

➡️ Choose your goals from the options provided:
"""
        inline_keyboard=[]
        if lang =="ru":
            inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
            inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
            inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
            inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
        else:
            inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
            inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
            inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
            inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

        inline_keyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        await state.set_state(RegState.preferences)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "hobbies":
    # Увлечения на двух языках с номерами
        interests = [
            (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
            (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
            (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
            (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
            (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
        ]
        inlinekeyboard = []
        row = []

        # Формируем кнопки для увлечений, по 3 в ряд
        for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
            row.append(InlineKeyboardButton(
                text=interest_ru if lang == "ru" else interest_en,
                callback_data=f"intrs_{number}"
            ))
            # Если добавлено 3 кнопки или это последняя кнопка в списке
            if len(row) == 2 or i == len(interests[:10]):
                inlinekeyboard.append(row)
                row = []  # Сбрасываем строку для следующего ряда

        # Добавляем стрелки навигации в последнюю строку
        inlinekeyboard.append([
            InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
            InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
        ])
        inlinekeyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
        if lang == "ru":
            txt = """
Выбери до 5 увлечений, которые описывают тебя. 🌟

➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
"""
        else:
            txt = """
Select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
    """
        await state.set_state(RegState.hobbies)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data == "descr":
        txt = (
"📝➡️ Напиши короткое описание о себе, чтобы другие могли узнать тебя лучше! Укажи свои увлечения, интересы или что-то, что ты хотел бы рассказать о себе. 🌟\n\nИли нажми <b>'назад⬅️'</b>, чтобы отменить действие."
        if lang == "ru"
        else "📝➡️ Write a short description about yourself so others can get to know you better! Share your hobbies, interests, or anything you'd like to tell about yourself. 🌟\n\nOr press <b>'back⬅️'</b> to undo the action."
        )

        data = await state.get_data()
        await state.set_state(RegState.about)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "media":
        txt = (
"📷 Пожалуйста, отправьте <b>от 1 до 3 медиа</b> (фотографии или видео), чтобы обновить ваш профиль.\n\n"
"Нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else
"📷 Please send <b>1 to 3 media</b> (photos or videos) to update your profile.\n\n"
"Press <b>'back⬅️'</b> to cancel the action."
)       
        await state.set_state(RegState.media)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_media"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data =="back":
        await state.set_state(state=None)
        data = await state.get_data()
        if 'idmsg_local' in data:
            if data["idmsg_local"] is not None:
                await callback_query.bot.delete_message(callback_query.from_user.id, data["idmsg_local"])
                data["idmsg_local"]=None
                await state.update_data(data=data)
                await state.clear()
        

        user = await User.get_or_none(user_id=callback_query.from_user.id)

        if not user:
            lang = "ru"
            await callback_query.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
            return

        lang = user.lang if user.lang in ["ru", "en"] else "ru"
        hobbies_text = ", ".join([
            (interest[1] if lang == "ru" else interest[2])
            for interest in INTERESTS
            if str(interest[0]) in (user.hobbies or [])
        ])

        location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
        if "," in location_text:
            latitude, longitude = map(float, location_text.split(","))
            location_text = get_location_by_coordinates(latitude, longitude)

        subscription_text = (
            f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
        )
        if user.subscription != "Free":
            subscription_text += (
                f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
            )

        description = (
            f"<b>{'Ваш профиль' if lang == 'ru' else 'Your profile'}:</b>\n\n"
            f"<b>{'Имя' if lang == 'ru' else 'Name'}:</b> {user.name}\n"
            f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
            f"<b>{'Пол' if lang == 'ru' else 'Gender'}:</b> {GENDER[lang][user.gender]}\n"
            f"<b>{'Локация' if lang == 'ru' else 'Location'}:</b> {location_text or ('Локация не указана' if lang == 'ru' else 'Location not provided')}\n\n"
            f"{subscription_text}"
            f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
            f"<b>{'Кого показывать' if lang == 'ru' else 'Viewing Preferences'}:</b> {WHO[lang][user.for_whom]}\n"
            f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
            f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
            f"_________________________\n{user.about or ''}\n"
        )



        media = user.medias or []
        # if len(media) == 1:
        #     media_file = media[0]['file_id']
        #     if media[0]['type'] == 'photo':
        #         await callback_query.bot.send_photo(callback_query.from_user.id, media_file, caption=description)
        #     elif media[0]['type'] == 'video':
        #         await callback_query.bot.send_video(callback_query.from_user.id, media_file, caption=description)
        lang = user.lang if user and user.lang in ["ru", "en"] else "ru"
        if user.localstatus == "active":
            btn_local = InlineKeyboardButton(
                text="🌍 Скрыть локацию" if lang == "ru" else "🌍 Hide Location",
                callback_data="location_hish"
            )
        else:
            btn_local = InlineKeyboardButton(
                text="🌍 Показать локацию" if lang == "ru" else "🌍 Show Location",
                callback_data="location_hish"
            )

        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="🖋 Имя" if lang == "ru" else "🖋 Name",
                    callback_data="fedit_name"
                ),
                InlineKeyboardButton(
                    text="🎂 Возраст" if lang == "ru" else "🎂 Age",
                    callback_data="fedit_age"
                )
            ],
            [
                InlineKeyboardButton(
                    text="📍 Изменить локацию" if lang == "ru" else "📍 Edit Location",
                    callback_data="fedit_location"
                ),
                btn_local
            ],
            [
                InlineKeyboardButton(
                    text="⚥ Пол" if lang == "ru" else "⚥ Gender",
                    callback_data="fedit_gender"
                ),
                InlineKeyboardButton(
                    text="🌈 Ориентация" if lang == "ru" else "🌈 Orientation",
                    callback_data="fedit_orientation"
                )
            ],
            [
                InlineKeyboardButton(
                    text="👁️‍🗨️ Кого показывать" if lang == "ru" else "👁️‍🗨️ Viewing Preferences",
                    callback_data="fedit_pref"
                ),
                InlineKeyboardButton(
                    text="🎯 Цели" if lang == "ru" else "🎯 Goals",
                    callback_data="fedit_goals"
                )
            ],
            [
                InlineKeyboardButton(
                    text="🎨 Увлечения" if lang == "ru" else "🎨 Hobbies",
                    callback_data="fedit_hobbies"
                ),
                InlineKeyboardButton(
                    text="📝 Описание" if lang == "ru" else "📝 Description",
                    callback_data="fedit_descr"
                )
            ],
            [
                InlineKeyboardButton(
                    text="🔄 Заполнить заново" if lang == "ru" else "🔄 Refill Profile",
                    callback_data="reset_profile"
                )
            ]
        ])


        await callback_query.message.edit_text(
            MESSAGES["action_prompt"][lang], 
            reply_markup=keyboard
        )
    else:
        await callback_query.answer("Неизвестная команда" if lang == "ru" else "Unknown command", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("reset_"))
async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    cb_data = (callback_query.data.split("_"))[1]
    if user:
        if cb_data == "profile":
            
            txt = """<b>Вы собираетесь заполнить профиль заново. ❗️</b>

            После нажатия <b>"ДА"</b> это действие будет <b>необратимо</b>. Все текущие данные профиля будут удалены.

            Вы точно уверены в этом?""" if lang == "ru" else """<b>You are about to refill your profile. ❗️</b>

            Once you press <b>"YES"</b>, this action will be <b>irreversible</b>. All current profile data will be deleted.

            Are you sure about this?"""
            inline_keyboard = [
                [InlineKeyboardButton(text="Да" if lang == "ru" else "Yes", callback_data="reset_yes")],
                [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        elif cb_data == "yes":  
            user.name=None
            user.age=None
            user.gender=None
            user.orientation=None
            user.for_whom=None
            user.preferences=None
            user.location=None
            user.about=None
            user.hobbies=None
            user.medias=None
            await user.save()
            await state.clear()
            await callback_query.answer("Профиль удален" if lang == "ru" else "Profile deleted", show_alert=True)
            await callback_query.message.edit_reply_markup(reply_markup=None)
            await add_profile(message=callback_query.message, state=state , user=user, lang=lang)








            await callback_query.answer("Профиль удален" if lang == "ru" else "Profile deleted")

# ===+++++=====+++++++=======++++++ HANDLERS ===+++++=====+++++++=======++++++ 

# BAD_WORDS = [
#     # Наркотики
#     "наркотик", "наркота", "косяк", "травка", "гашиш", "героин", "кокаин", "амфетамин", "экстази",
#     "марихуана", "спайс", "лсд", "шишки", "опиум", "план", "кристалл", "мефедрон", "drugs", "drug",
#     "weed", "marijuana", "cocaine", "heroin", "ecstasy", "meth", "amphetamine", "hash", "spice",
#     "lsd", "crystal", "meph", "opium", "j0int", "dr@g", "tr@vka",

#     # CP
#     "детская порнография", "детское порно", "запрещенное видео", "нелегальный контент", "порнография с детьми",
#     "cp", "child porn", "child pornography", "illegal content", "b@nned video", "ch!ld p0rn",

#     # Оружие
#     "оружие", "пистолет", "винтовка", "автомат", "пулемет", "граната", "мина", "бомба", "арсенал",
#     "ружье", "ствол", "калашников", "ак-47", "глок", "гранатомет", "weapon", "gun", "pistol", "rifle",
#     "machine gun", "grenade", "bomb", "landmine", "arsenal", "shotgun", "kalashnikov", "ak47",
#     "glock", "rocket launcher", "we@pon", "glock-19", "b0mb",

#     # Additional prohibited words
#     "explosive", "tnt", "c4", "detonator", "silencer", "sniper", "assault rifle", "pipe bomb",
#     "наркот", "герич", "герыч", "доза", "спайсы", "соли", "фен", "скорость",
#     "запрещенка", "порно с детьми", "порево", "kill", "murder", "mass shooting", "terrorist", "attack"
# ]






# # ++++++++++++++++ NAME +++++++++++++++

# @router.message(RegState.name)
# async def set_name(message: types.Message, state: FSMContext, lang: str):
#     user = await User.get_or_none(user_id=message.from_user.id)
#     global BAD_WORDS
#     if user:
#         if message.text not in BAD_WORDS:
#             user.name = message.text.strip()
#             await user.save()
            
#             if lang == "ru":
#                 txt = """<b>Имя указано! ✅</b>
# Отлично, теперь укажи свой пол! 🌟

# ➡️ Выбери один из вариантов:
# """
#             else:
#                 txt = """<b>Name provided! ✅</b>
# Great, now specify your gender! 🌟

# ➡️ Choose one of the options:
# """

#             inline_keyboard = [
#                 [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
#                 [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
#                 [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
#             ]

#             keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#             await state.set_state(RegState.gender)
#             await message.answer(txt, reply_markup=keyboard)
#         else:
#             txt = """<❌ <b>Ошибка:</b> Ваше имя содержит запрещенные слова. Пожалуйста, выберите другое имя. ✍️""" if lang == "ru" else """<❌ <b>Error:</b> Your name contains prohibited words. Please choose another name. ✍️"""
#             await state.set_state(RegState.name)
#             await message.answer(txt)


# # ++++++++++++++++ GENDER +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("gender_"), RegState.gender)
# async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.gender = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Пол указан! ✅</b>
# Теперь укажи свою ориентацию! 🌟

# ➡️ Выбери один из вариантов:
# """
#         else:
#             txt = """<b>Gender saved! ✅</b>
# Now specify your orientation! 🌟

# ➡️ Choose one of the options:
# """
#         if user.gender =='mal':

#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]
#         elif user.gender =="fem":
#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]
#         elif user.gender=="oth":
#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]



#         keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#         await state.set_state(RegState.orientation)
#         await callback_query.message.edit_text(txt, reply_markup=keyboard)


# # ++++++++++++++++ ORIENTATION +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("orientation_"), RegState.orientation)
# async def set_orientation(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.orientation = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Ориентация указана! ✅</b>
# Теперь укажи, кого ты хочешь видеть! 🌟

# ➡️ Выбери один из вариантов:
# """
#         else:
#             txt = """<b>Orientation saved! ✅</b>
# Now specify who you want to see! 🌟

# ➡️ Choose one of the options:
# """

#         inline_keyboard = [
#             [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
#             [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
#             [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")]
#         ]

#         keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#         await state.set_state(RegState.show)
#         await callback_query.message.edit_text(txt, reply_markup=keyboard)


# # ++++++++++++++++ SHOW PREFERENCES +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("show_"), RegState.show)
# async def set_show_preferences(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.for_whom = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Параметры просмотра указаны! ✅</b>
# Теперь укажи свой возраст! 🌟

# ➡️ Введите ваш возраст (минимум 16 лет):
# """
#         else:
#             txt = """<b>Viewing preferences saved! ✅</b>
# Now specify your age! 🌟

# ➡️ Enter your age (minimum 16 years):
# """

#         await state.set_state(RegState.age)
#         await callback_query.message.edit_text(txt)


# # ++++++++++++++++ AGE +++++++++++++++

# @router.message(RegState.age)
# async def set_age(message: types.Message, user: User, state: FSMContext, lang: str):
#     if user:
#         if message.text.isdigit():
#             age = int(message.text)
#             if age >= 16:
#                 user.age = age
#                 await user.save()

#                 if lang == "ru":
#                     txt = """<b>Возраст указан! ✅</b>
# Теперь укажи свои цели! 🌟

# ➡️ Выбери цели из предложенных вариантов:
# """
#                 else:
#                     txt = """<b>Age saved! ✅</b>
# Now specify your goals! 🌟

# ➡️ Choose your goals from the options provided:
# """
#                 inline_keyboard=[]
#                 if lang =="ru":
#                     inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
#                     inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
#                     inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
#                     inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
#                 else:
#                     inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
#                     inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
#                     inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
#                     inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])


#                 keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#                 await state.set_state(RegState.preferences)
#                 await message.answer(txt, reply_markup=keyboard)
#             else:
#                 txt = """❌ <b>Ошибка:</b> Возраст должен быть не менее 16 лет. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be at least 16 years. 🔢"""
#                 await message.answer(txt)
#         else:
#             txt = """❌ <b>Ошибка:</b> Возраст должен быть числом. Пожалуйста, введите корректное значение. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be a number. Please enter a valid value. 🔢"""
#             await message.answer(txt)


# # ++++++++++++++++ PREFERENCES +++++++++++++++

# @router.callback_query(lambda c: "interest_" in c.data, RegState.preferences)
# async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
#     if user:
#         pref = callback_query.data.split("_")[1]
#         user.preferences=pref
#         await user.save()
#         keyboard = ReplyKeyboardMarkup(
#             keyboard=[
#                 [
#                     KeyboardButton(
#                         text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
#                         request_location=True
#                     )
#                 ]
#             ],
#             resize_keyboard=True,
#             one_time_keyboard=True
#         )

#         if lang == "ru":
#             txt = """
# Нам нужно знать твою локацию, чтобы предложить людей рядом. 🌍

# ⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

# 💡 <b>Обратите внимание:</b> с тарифом <b>Pro</b> вы можете указать любую интересующую вас локацию и искать людей в том месте, где вам удобно! Это отличный способ расширить круг общения и найти людей из интересующих вас регионов. 🌎

# ➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию.
# """
#         else:
#             txt = """
# We need your location to suggest people nearby. 🌍

# ⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

# 💡 <b>Note:</b> With the <b>Pro</b> plan, you can specify any location you’re interested in and search for people in a convenient area! This is a great way to expand your connections and meet people from specific regions. 🌎

# ➡️ Please press the button below to share your location.
# """
#         await state.set_state(RegState.location)
#         await callback_query.bot.delete_message(callback_query.from_user.id, callback_query.message.message_id)
#         msg= await callback_query.bot.send_message(callback_query.from_user.id, txt, reply_markup=keyboard)
#         data = await state.get_data()
#         data['idmsg_local']=msg.message_id
#         await state.update_data(data)

# # ++++++++++++++++ LOCATION +++++++++++++++

# @router.message(RegState.location, lambda message: message.content_type == ContentType.LOCATION)
# async def set_location(message: types.Message, user: User, state: FSMContext, lang: str):
    
#     if user:
#         user.location = f"{message.location.latitude},{message.location.longitude}"
#         await user.save()
#         if lang == "ru":
#             txt = """<b>Локация указана! ✅</b>
# Отлично, теперь расскажи немного о себе. 🌟

# ➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
# """
#         else:
#             txt = """<b>Location saved! ✅</b>
# Great, now tell us a bit about yourself. 🌟

# ➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
# """
#         await state.set_state(RegState.about)
#         data = await state.get_data()
#         if "idmsg_local" in data: 
#             await message.bot.delete_message(message.from_user.id, data["idmsg_local"])
#         data["idmsg_local"]=''
#         await state.update_data(data)
#         await message.bot.delete_message(message.from_user.id, message.message_id)
#         await message.bot.send_message(message.from_user.id, txt)

# # ++++++++++++++++ ABOUT +++++++++++++++

# @router.message(RegState.about)
# async def set_about(message: types.Message, user: User, state: FSMContext, lang: str):
#     global BAD_WORDS
#     if user:
#         if message.text:
#             if message.text not in BAD_WORDS:
#                 user.about = message.text
#                 await user.save()
                
#                 await state.set_state(RegState.hobbies)
#             # Увлечения на двух языках с номерами
#                 interests = [
#                     (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
#                     (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
#                     (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
#                     (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
#                     (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
#                 ]
#                 inlinekeyboard = []
#                 row = []

#                 # Формируем кнопки для увлечений, по 3 в ряд
#                 for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
#                     row.append(InlineKeyboardButton(
#                         text=interest_ru if lang == "ru" else interest_en,
#                         callback_data=f"intrs_{number}"
#                     ))
#                     # Если добавлено 3 кнопки или это последняя кнопка в списке
#                     if len(row) == 2 or i == len(interests[:10]):
#                         inlinekeyboard.append(row)
#                         row = []  # Сбрасываем строку для следующего ряда

#                 # Добавляем стрелки навигации в последнюю строку
#                 inlinekeyboard.append([
#                     InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
#                     InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
#                 ])

#                 keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
                
#                 if lang == "ru":
#                     txt = """<b>Записали ✅</b>
#     Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟

#    ➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
#         """
#                 else:
#                     txt = """<b>Saved ✅</b>
#     Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
#     """


#                 await message.answer(txt, reply_markup=keyboard)
                
#             else:
#                 if lang == "ru":
#                     txt = """❌ <b>Ошибка:</b> Описание содержит запрещенные слова. Пожалуйста, введите другое описание и попробуйте снова. ✍️"""
#                 else:
#                     txt = """❌ <b>Error:</b> The description contains prohibited words. Please enter another description and try again. ✍️"""
#                 await message.answer(txt)
#                 await state.set_state(RegState.about)
#         else:
#                 if lang == "ru":
#                     txt = """❌ <b>Ошибка:</b> Описание долджно содержать текст ✍️"""
#                 else:
                    
#                     txt = """❌ <b>Error:</b> The description must contain text. Please write something ✍️"""
#                 await message.answer(txt)
#                 await state.set_state(RegState.about)

# # ++++++++++++++++ HOBBIES +++++++++++++++

# @router.callback_query(lambda c: "intrs_" in c.data or c.data.startswith("intrs_page") or c.data == "intrs_done", RegState.hobbies)
# async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     # Загружаем список интересов
#     interests = [
#         (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
#         (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
#         (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
#         (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
#         (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
#         (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
#         (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
#         (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
#         (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
#         (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
#         (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
#         (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
#         (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
#         (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
#         (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
#         (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
#         (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
#         (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
#         (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
#         (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
#     ]

#     # Обработка страниц
#     state_data = await state.get_data()
#     current_page = state_data.get("current_page", 1)
#     hobbies = state_data.get("selected_hobbies", [])

#     if callback_query.data.startswith("intrs_page"):
#         if "next" in callback_query.data:
#             current_page += 1
#         elif "back" in callback_query.data:
#             current_page -= 1
#         await state.update_data(current_page=current_page)

#     elif callback_query.data.startswith("intrs_") and callback_query.data != "intrs_done":
#         interest = callback_query.data.split("_")[1]
#         if interest in hobbies:
#             hobbies.remove(interest)
#         else:
#             if len(hobbies) < 5:
#                 hobbies.append(interest)
#             else:
#                 txt1 = "Выбрано максимальное количество! Уберите один интерес или нажмите 'Сохранить'." if lang == "ru" else "Maximum number selected! Remove one interest or click 'Save'."
#                 await callback_query.answer(
#                     txt1,
#                     show_alert=True
#                 )
#                 return
#         await state.update_data(selected_hobbies=hobbies)

#     elif callback_query.data == "intrs_done":
#         if len(hobbies) < 5:
#             txt2 = "Вы должны выбрать минимум 5 интересов, чтобы продолжить!" if lang == "ru" else "You must select at least 5 interests to continue!"
#             await callback_query.answer(
#                 txt2,
#                 show_alert=True
#             )
#             return
#         else:
#             user.hobbies = hobbies  # Сохраняем в базу данных только при завершении
#             await user.save()

#             txt3 = "Интересы сохранены! ✅" if lang == "ru" else "Interests saved! ✅"
#             await callback_query.answer(txt3, show_alert=True)

#             txt = """🎉 <b>Отлично!</b> Ваши хобби успешно сохранены.  

# Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
# Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """🎉 <b>Great!</b> Your hobbies have been successfully saved.  

# Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
# Or press "Skip" to continue. ⏩"""

#             keyboard = InlineKeyboardMarkup(inline_keyboard=[
#                 [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
#             ])

#             await callback_query.message.edit_text(txt, reply_markup=keyboard)
#             await state.set_state(RegState.media)
#             return

#     # Генерация кнопок для текущей страницы
#     page_size = 10
#     start_index = (current_page - 1) * page_size
#     end_index = start_index + page_size
#     inlinekeyboard = []
#     row = []

#     for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
#         text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
#         row.append(InlineKeyboardButton(
#             text=text,
#             callback_data=f"intrs_{number}"
#         ))
#         if len(row) == 2 or i == len(interests[start_index:end_index]):
#             inlinekeyboard.append(row)
#             row = []

#     navigation_buttons = []
#     if current_page > 1:
#         navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
#     if end_index < len(interests):
#         navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
#     if navigation_buttons:
#         inlinekeyboard.append(navigation_buttons)

#     if len(hobbies) == 5:
#         inlinekeyboard.append(
#             [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
#         )

#     keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
#     txt = (f"<b>Выбрано {len(hobbies)}/5 увлечений ✅</b>\n" if lang == "ru" else f"<b>Selected {len(hobbies)}/5 hobbies ✅</b>\n")
#     txt += "Отлично, выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми 'Сохранить'." if lang == "ru" else "Great, select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click 'Save'."

#     await callback_query.message.edit_text(txt, reply_markup=keyboard)


        

                [FILE] chat.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/chat.py ---


                [FILE] search.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/search.py ---


# import ssl
# import certifi
# from geopy.geocoders import Nominatim

# def get_location_by_coordinates(latitude, longitude):
#     geolocator = Nominatim(
#         user_agent="my_geopy_app",
#         timeout=10,
#         ssl_context=ssl.create_default_context(cafile=certifi.where())
#     )
#     try:
#         location = geolocator.reverse((latitude, longitude), exactly_one=True)
#         if location:
#             address = location.raw.get('address', {})
#             city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
#             return city or location.address
#         else:
#             return "Местоположение не найдено"
#     except Exception as e:
#         return f"Ошибка при определении местоположения: {e}"
    

# @router.message(Command("myprofile"))
# async def my_profile_handler(message: types.Message,state: FSMContext):
#     user = await User.get_or_none(user_id=message.from_user.id)

#     if not user:
#         lang = "ru"
#         await message.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
#         return

#     lang = user.lang if user.lang in ["ru", "en"] else "ru"
#     hobbies_text = ", ".join([
#         (interest[1] if lang == "ru" else interest[2])
#         for interest in INTERESTS
#         if str(interest[0]) in (user.hobbies or [])
#     ])

#     location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
#     if "," in location_text:
#         latitude, longitude = map(float, location_text.split(","))
#         location_text = get_location_by_coordinates(latitude, longitude)

#     subscription_text = (
#         f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
#     )
#     if user.subscription != "Free":
#         subscription_text += (
#             f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
#         )

#     description = (
#         f"<b>{user.name}</b> \n"
#         f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
#         f"{GENDER[lang][user.gender]}\n"
#         f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
#         f"{location_text}\n"

#         f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
#         f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
#         f"_________________________\n{user.about or ''}\n"
#     )



#     media = user.medias or []
#     if len(media) == 1:
#         media_file = media[0]['file_id']
#         if media[0]['type'] == 'photo':
#             msg= await message.bot.send_photo(message.from_user.id, media_file, caption=description)
#         elif media[0]['type'] == 'video':
#             msg= await message.bot.send_video(message.from_user.id, media_file, caption=description)
#     else:
#         files=[]
#         i =0
#         for media_file in media:
            
#             caption=description if i == 0 else None
            
#             if media_file["type"] =="video":
#                 files.append(InputMediaVideo(media=f"{media_file['file_id']}", caption=caption))
#                 i = i+1
#             elif media_file['type'] == 'photo':
#                 files.append(InputMediaPhoto(media=f"{media_file['file_id']}", caption=caption))
#                 i = i+1
#             else:
#                 continue
                 

#     # Отправка медиа-группы
#         msg= await message.bot.send_media_group(chat_id=message.from_user.id, media=files)
#         data= await state.get_data()
#         data["id_card_profile"]=None
#         await state.update_data(data=data)
    
    

   
        
    


                [FILE] serch.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/serch.py ---
from aiogram import Router, types, F
from aiogram.types import (
    ReplyKeyboardMarkup,
    KeyboardButton,
    InputMediaPhoto,
    InputMediaVideo,
    ReplyKeyboardRemove
)
from aiogram.fsm.context import FSMContext

import math
import ssl
import certifi
from geopy.geocoders import Nominatim
from tortoise.expressions import Q

from src.models import User as Userdb, Like, Block
from src.utils.state import SearchPeople

router = Router()

# -----------------------------
# Словари переводов
# -----------------------------
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), 
    (60, "Языковой обмен", "Language Exchange"),
]

PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {"fem": "👩 Женский", "mal": "👨 Мужской", "oth": "🌈 Другое"},
    "en": {"fem": "👩 Female", "mal": "👨 Male", "oth": "🌈 Other"}
}

WHO = {
    "ru": {"fem": "👩 Девушки", "mal": "👨 Парни", "all": "🌍 Все"},
    "en": {"fem": "👩 fem", "mal": "👨 mal", "all": "🌍 Everyone"}
}

ORI = {
    "ru": {
        "hetero": "❤️ Гетеро",
        "gay": "🌈 Гей",
        "bi": "💛 Би",
        "lesbian": "💖 Лесби",
        "gay_lesbian": "🌈 Гей/Лесби",
        "oth": "💫 Другая",
        "skip": "Не указана"
    },
    "en": {
        "hetero": "❤️ Hetero",
        "gay": "🌈 Gay",
        "bi": "💛 Bi",
        "lesbian": "💖 Lesbian",
        "gay_lesbian": "🌈 Gay/Lesbian",
        "oth": "💫 Other",
        "skip": "Not specified"
    }
}

# -----------------------------
# Вспомогательные функции
# -----------------------------
@router.message(F.text.in_(["❤️ Лайк", "💖 Суперлайк", "👎🏻 Дизлайк", "🚫 Заблокировать", "❗ Пожаловаться", "⏹ Остановить поиск",
                             "❤️ Like", "💖 Superlike", "👎🏻 Dislike", "🚫 Block", "❗ Report", "⏹ Stop Search"]))
async def handle_reaction(message: types.Message, state: FSMContext):
    user = await Userdb.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer("Профиль не найден.")
        return

    reaction = message.text
    if reaction in ["⏹ Остановить поиск", "⏹ Stop Search"]:
        await state.clear()
        await message.answer("Поиск остановлен.", reply_markup=ReplyKeyboardRemove())
        return

    data = await state.get_data()
    current_candidate_id = data.get("current_candidate_id")
    if not current_candidate_id:
        await message.answer("Нет текущей анкеты для оценки. Попробуйте начать поиск заново.")
        return

    candidate = await Userdb.get_or_none(user_id=current_candidate_id)
    if not candidate:
        await message.answer("Ошибка: кандидат не найден.")
        return

    if reaction in ["❤️ Лайк", "❤️ Like"]:
        await Like.create(from_user=user, to_user=candidate, is_superlike=False)
        # Если у пользователя Free-подписка, уведомляем, что для просмотра полного профиля необходимо оформить подписку.
        if user.subscription.lower() == "free":
            await message.answer("Вы получили лайк! Чтобы увидеть подробности профиля кандидата, необходимо приобрести подписку.")
            # Здесь можно добавить дополнительную логику для перенаправления на страницу покупки подписки.
        else:
            await message.answer("Вы поставили лайк!")
    elif reaction in ["💖 Суперлайк", "💖 Superlike"]:
        if user.subscription.lower() != "free":
            await Like.create(from_user=user, to_user=candidate, is_superlike=True)
            await message.answer("Вы поставили суперлайк!")
        else:
            await message.answer("Суперлайк доступен только при платной подписке.")
    elif reaction in ["👎🏻 Дизлайк", "👎🏻 Dislike"]:
        await message.answer("Вы дизлайкнули кандидата.")
    elif reaction in ["🚫 Заблокировать", "🚫 Block"]:
        await Block.create(from_user=user, to_user=candidate, can_message=False)
        await message.answer("Кандидат заблокирован.")
    elif reaction in ["❗ Пожаловаться", "❗ Report"]:
        # Здесь можно добавить логику обработки жалобы.
        await message.answer("Вы отправили жалобу.")
    else:
        await message.answer("Неверная команда.")

    # После обработки реакции, если реакция не связана с остановкой поиска, показываем следующего кандидата.
    await start_search(user, state, message.bot)

# -----------------------------
# Хендлер для кнопки "Начать поиск"
# -----------------------------
@router.message(F.text.in_(["🚀 Начать поиск", "🚀 Start Search"]))
async def handle_search_start(message: types.Message, state: FSMContext):
    user = await Userdb.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer(
            "<b>Профиль не найден.</b> Пожалуйста, зарегистрируйтесь с помощью команды /start."
        )
        return

    lang = user.lang or ("ru" if message.from_user.language_code == "ru" else "en")
    await state.set_state(SearchPeople.search)
    await message.answer(
        "🔎 Поиск начался! Ожидайте…" if lang == "ru" else "🔎 The search has begun! Please wait…"
    )
    await start_search(user, state, message.bot)


                [FILE] SET FOREIGN_KEY_CHECKS = 0; -- Отключаем.sql

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/SET FOREIGN_KEY_CHECKS = 0; -- Отключаем.sql ---
SET FOREIGN_KEY_CHECKS = 0; -- Отключаем проверку внешних ключей

DROP TABLE IF EXISTS `users`;
DROP TABLE IF EXISTS `likes`;
DROP TABLE IF EXISTS `blocks`;
DROP TABLE IF EXISTS `statements`;
DROP TABLE IF EXISTS `aerich`; -- Если используется Aerich

SET FOREIGN_KEY_CHECKS = 1

        [DIR] data
            [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/data/__init__.py ---


[DIR] .git
    [FILE] config

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/config ---
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
	precomposeunicode = true
[remote "origin"]
	url = https://github.com/Kolotjob/emi-date.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main


    [DIR] objects
        [DIR] 61
            [FILE] 6eca87f01c968e04fb91d2f8d37995755118a6
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/61/6eca87f01c968e04fb91d2f8d37995755118a6: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 0c
            [FILE] 38622985166ae861cf9cc70c52f756372c6805
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/0c/38622985166ae861cf9cc70c52f756372c6805: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 50
            [FILE] f772cf37c57e9dcf056d6ee2cd97e0e5127883
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/50/f772cf37c57e9dcf056d6ee2cd97e0e5127883: 'utf-8' codec can't decode byte 0xa5 in position 2: invalid start byte
        [DIR] 68
            [FILE] 010f3f7496553a760ee7cbcd34972a0df7d00c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/68/010f3f7496553a760ee7cbcd34972a0df7d00c: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
            [FILE] 5e37802b919c124b2eb85b34aec6b940bbcd97
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/68/5e37802b919c124b2eb85b34aec6b940bbcd97: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 6f
            [FILE] 6874afa144a07171b135f4e6c075e28b6e4657
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/6f/6874afa144a07171b135f4e6c075e28b6e4657: 'utf-8' codec can't decode byte 0x8e in position 3: invalid start byte
        [DIR] 9b
            [FILE] a85d0f7c3834be8553d16a34971acc11f91595
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9b/a85d0f7c3834be8553d16a34971acc11f91595: 'utf-8' codec can't decode byte 0xd3 in position 6: invalid continuation byte
        [DIR] 9e
            [FILE] b54c6b7e6cc0c8f7e166326ab0f145d5c3cd55
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9e/b54c6b7e6cc0c8f7e166326ab0f145d5c3cd55: 'utf-8' codec can't decode byte 0xcd in position 4: invalid continuation byte
            [FILE] 7cfda3befed2ba56d9670c58b982de4a0dd4f5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9e/7cfda3befed2ba56d9670c58b982de4a0dd4f5: 'utf-8' codec can't decode byte 0xbe in position 8: invalid start byte
        [DIR] 04
            [FILE] f9c795736ac0a9d48dd0dc3be03af17d4135b3
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/04/f9c795736ac0a9d48dd0dc3be03af17d4135b3: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] 6a
            [FILE] 826a6b5206b3dfacecb98cd11e93193b3e06bf
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/6a/826a6b5206b3dfacecb98cd11e93193b3e06bf: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 32
            [FILE] 1359ed55d371cf522e00dc07e220646999f3fb
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/32/1359ed55d371cf522e00dc07e220646999f3fb: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte
        [DIR] 69
            [FILE] b1b039c9a2732943f638a98fe4a6b4d506639b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/69/b1b039c9a2732943f638a98fe4a6b4d506639b: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 56
            [FILE] 8f18f2a9845a6e20607669a964851f82e1cdff
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/56/8f18f2a9845a6e20607669a964851f82e1cdff: 'utf-8' codec can't decode byte 0xb3 in position 9: invalid start byte
        [DIR] 51
            [FILE] cfbf63d882ca718910854e43a86b28f39e6296
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/51/cfbf63d882ca718910854e43a86b28f39e6296: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 0b
            [FILE] 8a0bb03005df3cf0b49fd672d8205427d41ae0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/0b/8a0bb03005df3cf0b49fd672d8205427d41ae0: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 93
            [FILE] 7622e3d936090a5c53fba4b1f119e0e0f77c32
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/93/7622e3d936090a5c53fba4b1f119e0e0f77c32: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 94
            [FILE] 85c33c65a5cfd6b3c817fffcee4c0420285b1f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/94/85c33c65a5cfd6b3c817fffcee4c0420285b1f: 'utf-8' codec can't decode byte 0x92 in position 3: invalid start byte
        [DIR] 0e
            [FILE] dd7639aff628988f18396c26687069be4aa165
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/0e/dd7639aff628988f18396c26687069be4aa165: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 60
            [FILE] 384cd606551b15c473daafa011c14909868b6f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/60/384cd606551b15c473daafa011c14909868b6f: 'utf-8' codec can't decode byte 0xb4 in position 8: invalid start byte
        [DIR] 5a
            [FILE] 7af98f69218ea298c082bb52c92569c171e755
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/5a/7af98f69218ea298c082bb52c92569c171e755: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] 5f
            [FILE] 39e955fcca45d107d32d658bb6ff33fd258cd5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/5f/39e955fcca45d107d32d658bb6ff33fd258cd5: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte
        [DIR] 9d
            [FILE] abc21c73ae872aa55c4e60cb7d750443ac073d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9d/abc21c73ae872aa55c4e60cb7d750443ac073d: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
            [FILE] 20b9d5cd51552ee0d9ed0126304bb17d5d352d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9d/20b9d5cd51552ee0d9ed0126304bb17d5d352d: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
            [FILE] 1dcfdaf1a6857c5f83dc27019c7600e1ffaff8
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9d/1dcfdaf1a6857c5f83dc27019c7600e1ffaff8: 'utf-8' codec can't decode byte 0xb6 in position 8: invalid start byte
        [DIR] 9c
            [FILE] 3349a5fe8e771cac95d48b8dd8febc30f11d70
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9c/3349a5fe8e771cac95d48b8dd8febc30f11d70: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte
            [FILE] f56dc4ea10c71c63bd33cf9dd01866f9b5a57b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9c/f56dc4ea10c71c63bd33cf9dd01866f9b5a57b: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 02
            [FILE] afee2fa719e958d252ff79f23d67d751347d89
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/02/afee2fa719e958d252ff79f23d67d751347d89: 'utf-8' codec can't decode byte 0xbd in position 2: invalid start byte
            [FILE] f762f28ab9ed673cd3060b1a6b3d004c9b569a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/02/f762f28ab9ed673cd3060b1a6b3d004c9b569a: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] a4
            [FILE] 6855bd30d3663c6060a9a895691b0e0b5a8cac
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/a4/6855bd30d3663c6060a9a895691b0e0b5a8cac: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] a3
            [FILE] 3297f09a9e8e9cd8898e94e0167fbe8fe5cf52
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/a3/3297f09a9e8e9cd8898e94e0167fbe8fe5cf52: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] bb
            [FILE] 21c0672315fe1486a599508897ea658a92e15f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/bb/21c0672315fe1486a599508897ea658a92e15f: 'utf-8' codec can't decode byte 0xf1 in position 22: invalid continuation byte
        [DIR] d7
            [FILE] 13fbbb0c53f196aa5d638d26cf0bf9610a89bd
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/d7/13fbbb0c53f196aa5d638d26cf0bf9610a89bd: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] df
            [FILE] 3a05a480f7cd5b32d137353889233c22fe6def
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/df/3a05a480f7cd5b32d137353889233c22fe6def: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] ae
            [FILE] 6b0f3830f28c40fd62e587ab22c1a02337df12
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ae/6b0f3830f28c40fd62e587ab22c1a02337df12: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
        [DIR] d8
            [FILE] 8ef66d332481a00d23f9767237ee0231e84b3b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/d8/8ef66d332481a00d23f9767237ee0231e84b3b: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] e5
            [FILE] d0be848fc7143cb268bd81f16068eed27239dd
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e5/d0be848fc7143cb268bd81f16068eed27239dd: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] e2
            [FILE] f9c578f9cb6ae20c04c421d8e3ae426b25b628
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e2/f9c578f9cb6ae20c04c421d8e3ae426b25b628: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
            [FILE] 13d5cdb7b933bad81f2ddffc4c4ac79c1c173a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e2/13d5cdb7b933bad81f2ddffc4c4ac79c1c173a: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] c0
            [FILE] 5d22dbb5fa3fac50e7b4c34e50a5eadd1ec902
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c0/5d22dbb5fa3fac50e7b4c34e50a5eadd1ec902: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] c9
            [FILE] a2ee1d74ef3473c58e3dfbc2058a5fc1457e3d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c9/a2ee1d74ef3473c58e3dfbc2058a5fc1457e3d: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
        [DIR] fc
            [FILE] 63aa649cec5ae958a984a47afca6d40b23f39a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/fc/63aa649cec5ae958a984a47afca6d40b23f39a: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] fd
            [FILE] a6e763fd247cd70fe6af55fb7ead808d04c7e1
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/fd/a6e763fd247cd70fe6af55fb7ead808d04c7e1: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
        [DIR] f2
            [FILE] feed8e9d550a5aa2a66b2dc77cf8a0e7ce6b7b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f2/feed8e9d550a5aa2a66b2dc77cf8a0e7ce6b7b: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
            [FILE] 34fd6d56e016c2e97d26b84c326b7feb6a0ef2
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f2/34fd6d56e016c2e97d26b84c326b7feb6a0ef2: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] cf
            [FILE] 5044764a769064d88697d6cd9a985ff6cd17fa
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cf/5044764a769064d88697d6cd9a985ff6cd17fa: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] c1
            [FILE] 3192e01e56da992a4fa22291a34d5d258905b6
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c1/3192e01e56da992a4fa22291a34d5d258905b6: 'utf-8' codec can't decode byte 0x91 in position 3: invalid start byte
        [DIR] ec
            [FILE] 70d70f83e76f4a93a3f27b33e5ff4ba602345c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ec/70d70f83e76f4a93a3f27b33e5ff4ba602345c: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
            [FILE] 998c6cfe2c5e981c4cddf1edcf3fa83b71f1dd
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ec/998c6cfe2c5e981c4cddf1edcf3fa83b71f1dd: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
            [FILE] c42423819e9acced2e69bac2d18df6fe51ea74
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ec/c42423819e9acced2e69bac2d18df6fe51ea74: 'utf-8' codec can't decode byte 0xb0 in position 9: invalid start byte
        [DIR] 4e
            [FILE] 89459c0e6b633a928695f873c0632ce4a5f3bc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/4e/89459c0e6b633a928695f873c0632ce4a5f3bc: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 27
            [FILE] 95830ead9845dd973cb3fc1b02edff7186a0ff
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/27/95830ead9845dd973cb3fc1b02edff7186a0ff: 'utf-8' codec can't decode byte 0xb3 in position 9: invalid start byte
        [DIR] pack
        [DIR] 11
            [FILE] 52edf3fa0d9c9789fabff2b702cff767759466
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/11/52edf3fa0d9c9789fabff2b702cff767759466: 'utf-8' codec can't decode byte 0x91 in position 3: invalid start byte
        [DIR] 29
            [FILE] 08d0451a6b4bd25e183defe5d7aff92f23c02b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/29/08d0451a6b4bd25e183defe5d7aff92f23c02b: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
            [FILE] cbe8f5ed51f01a2470ca08c53052a2e94a637f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/29/cbe8f5ed51f01a2470ca08c53052a2e94a637f: 'utf-8' codec can't decode byte 0xcd in position 4: invalid continuation byte
        [DIR] 7c
            [FILE] 7892c932ceb9aa47f03af65172c919c036af1a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/7c/7892c932ceb9aa47f03af65172c919c036af1a: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
            [FILE] 17d33157b96c9e868f08c2f0ef9dda1634f0e0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/7c/17d33157b96c9e868f08c2f0ef9dda1634f0e0: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 16
            [FILE] 1d55be0255a00dcfb33dc545f8deffbfa0cff3
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/16/1d55be0255a00dcfb33dc545f8deffbfa0cff3: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 45
            [FILE] e7fcd7fe6556e4aaa5c3df75c5c5fd6330304f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/45/e7fcd7fe6556e4aaa5c3df75c5c5fd6330304f: 'utf-8' codec can't decode byte 0xcf in position 20: invalid continuation byte
        [DIR] 1a
            [FILE] a06092e7e39629f36cc0f0f7c140d18bbc4164
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/1a/a06092e7e39629f36cc0f0f7c140d18bbc4164: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 17
            [FILE] abe132ee28bfe69d4edbd17acba5ddc9921507
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/17/abe132ee28bfe69d4edbd17acba5ddc9921507: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
            [FILE] acb067dfac37f34172c44cc8c475120eb042f0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/17/acb067dfac37f34172c44cc8c475120eb042f0: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] 8f
            [FILE] 5516207ae507e81f444653449bb4c268409bad
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/8f/5516207ae507e81f444653449bb4c268409bad: 'utf-8' codec can't decode byte 0xb2 in position 9: invalid start byte
        [DIR] 7e
            [FILE] 3e6d94fe146fc2680a20b0a117aaa01b72f873
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/7e/3e6d94fe146fc2680a20b0a117aaa01b72f873: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 10
            [FILE] dcaed500b48299671096e86d1e01caeec45922
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/10/dcaed500b48299671096e86d1e01caeec45922: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 19
            [FILE] a355399ff8fd4a89738aa17417083636baecf1
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/19/a355399ff8fd4a89738aa17417083636baecf1: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
        [DIR] 21
            [FILE] 390e6b3e9b7a82a9660b7f5596562fbd038c5c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/21/390e6b3e9b7a82a9660b7f5596562fbd038c5c: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
            [FILE] 73bc11886c10b6c8a1bdd098ca26856e55b3a7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/21/73bc11886c10b6c8a1bdd098ca26856e55b3a7: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
            [FILE] 76a093b970ce5f55037c464c6b08418f898192
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/21/76a093b970ce5f55037c464c6b08418f898192: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] 81
            [FILE] 241d6954702f470c4c8420bc8a186562a40b90
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/81/241d6954702f470c4c8420bc8a186562a40b90: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 86
            [FILE] efd2a5281ce895b1c2578dc23e0020a7ec2501
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/86/efd2a5281ce895b1c2578dc23e0020a7ec2501: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
        [DIR] 9f
            [FILE] d07816909727b7698f1095b27b24a3c13b00ce
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9f/d07816909727b7698f1095b27b24a3c13b00ce: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] 6b
            [FILE] 4bdd90643fc93bf877ae6a504b3c632ab03e34
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/6b/4bdd90643fc93bf877ae6a504b3c632ab03e34: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
            [FILE] 8f46805f29a9dd296b8a0a58dfe43f5a05e6c2
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/6b/8f46805f29a9dd296b8a0a58dfe43f5a05e6c2: 'utf-8' codec can't decode byte 0xb3 in position 9: invalid start byte
        [DIR] 07
            [FILE] bb878864fbccba366696d8162b128650517f52
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/07/bb878864fbccba366696d8162b128650517f52: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] 00
            [FILE] 73405fe55ad935fbb590aa312fed33dc85b03c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/00/73405fe55ad935fbb590aa312fed33dc85b03c: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
            [FILE] 0dcd6b909232463a5595b50e159780be20789c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/00/0dcd6b909232463a5595b50e159780be20789c: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 9a
            [FILE] 0fa1a8212ad220a62d509ee289357dfbc9f62c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9a/0fa1a8212ad220a62d509ee289357dfbc9f62c: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
        [DIR] 36
            [FILE] e466124cfd65ae89a7d364173221cf8f6cfd2c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/36/e466124cfd65ae89a7d364173221cf8f6cfd2c: 'utf-8' codec can't decode byte 0xc8 in position 17: invalid continuation byte
        [DIR] 5c
            [FILE] 1aaad07b50f92f54caab5f11126106e93619fb
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/5c/1aaad07b50f92f54caab5f11126106e93619fb: 'utf-8' codec can't decode byte 0xce in position 18: invalid continuation byte
        [DIR] 31
            [FILE] 1fd2ad316cbb8ad3ad6ae4672163e260fbf048
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/31/1fd2ad316cbb8ad3ad6ae4672163e260fbf048: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] info
        [DIR] 91
            [FILE] 1533d365aeed0c93b0acf0cfa65cbd9e878636
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/91/1533d365aeed0c93b0acf0cfa65cbd9e878636: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 54
            [FILE] 06edc51f6f84581bcca2f236200c073105507b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/54/06edc51f6f84581bcca2f236200c073105507b: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
        [DIR] 98
            [FILE] 65d80db456c5c4934cf854a1e97edd23a67c67
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/98/65d80db456c5c4934cf854a1e97edd23a67c67: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
            [FILE] b816f9994f378b6ec203c1b56af3bf115927a7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/98/b816f9994f378b6ec203c1b56af3bf115927a7: 'utf-8' codec can't decode byte 0xb3 in position 9: invalid start byte
        [DIR] 53
            [FILE] 3da9602d3b097714dedb191e4c7c9e4d9efbcf
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/53/3da9602d3b097714dedb191e4c7c9e4d9efbcf: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
            [FILE] f70283c7a0fe1bc215e2f1d0f6d63859f48498
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/53/f70283c7a0fe1bc215e2f1d0f6d63859f48498: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] 30
            [FILE] 6f243c4564d0aa66161262050fbc3f0712afc8
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/30/6f243c4564d0aa66161262050fbc3f0712afc8: 'utf-8' codec can't decode byte 0xf1 in position 22: invalid continuation byte
        [DIR] 5e
            [FILE] b90e7f39281327ab3f1e4ff4b0439c2b26faf5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/5e/b90e7f39281327ab3f1e4ff4b0439c2b26faf5: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 39
            [FILE] 8198302175e14eee675c15e2bf2b51ef21648a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/39/8198302175e14eee675c15e2bf2b51ef21648a: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
            [FILE] 27e56ad9902338dccccf9d8772c76730866fc9
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/39/27e56ad9902338dccccf9d8772c76730866fc9: 'utf-8' codec can't decode byte 0x92 in position 3: invalid start byte
        [DIR] 99
            [FILE] 25de5e4d3e31a36f8116df2b4c97592734188a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/99/25de5e4d3e31a36f8116df2b4c97592734188a: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 0f
            [FILE] 9dde269911058dafa917a604e6dcc22fbdb002
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/0f/9dde269911058dafa917a604e6dcc22fbdb002: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] bf
            [FILE] 63b629e0832e0712ce6a9af0ddc511e8334ae1
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/bf/63b629e0832e0712ce6a9af0ddc511e8334ae1: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
            [FILE] 17637827cce769ee205f8d4bada91dfcf67df7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/bf/17637827cce769ee205f8d4bada91dfcf67df7: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] a0
            [FILE] 8f7e5b08279005a0d321381958da5fe989c15d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/a0/8f7e5b08279005a0d321381958da5fe989c15d: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] b8
            [FILE] bbe24011e44738a7989f9918ab25dd7c0fc8c9
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/b8/bbe24011e44738a7989f9918ab25dd7c0fc8c9: 'utf-8' codec can't decode byte 0xf1 in position 22: invalid continuation byte
        [DIR] b1
            [FILE] 9871130cde3397fa55c2c1728827b6cd5cd8e9
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/b1/9871130cde3397fa55c2c1728827b6cd5cd8e9: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
        [DIR] dd
            [FILE] b03f669af0c573510bb922c6f49b8ed632fb14
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/dd/b03f669af0c573510bb922c6f49b8ed632fb14: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
            [FILE] e58ab9c9228d94c1c9d9c5e82fd53e2e5a4639
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/dd/e58ab9c9228d94c1c9d9c5e82fd53e2e5a4639: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] dc
            [FILE] f4aa1a765f37862e733d975095b97c4a741632
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/dc/f4aa1a765f37862e733d975095b97c4a741632: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] b6
            [FILE] 52f63ceeb5616db0d7381758be00e16b40251d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/b6/52f63ceeb5616db0d7381758be00e16b40251d: 'utf-8' codec can't decode bytes in position 2-3: invalid continuation byte
        [DIR] d5
            [FILE] bba6bc68eca06c08b02bd3508757fff1d2b247
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/d5/bba6bc68eca06c08b02bd3508757fff1d2b247: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] d2
            [FILE] ce36499b3dda0d5b8fc6fc5bbe9b1e912c027e
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/d2/ce36499b3dda0d5b8fc6fc5bbe9b1e912c027e: 'utf-8' codec can't decode byte 0xce in position 19: invalid continuation byte
        [DIR] b7
            [FILE] 3d84cb5f71a515c0f3a3b0d05343ee9ffe90e7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/b7/3d84cb5f71a515c0f3a3b0d05343ee9ffe90e7: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] a1
            [FILE] c86ac1a4b3d08da6177ff8538dada13ed11286
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/a1/c86ac1a4b3d08da6177ff8538dada13ed11286: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
        [DIR] c3
            [FILE] 806b620a66c6d49b434ad782e01fb242fa162d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c3/806b620a66c6d49b434ad782e01fb242fa162d: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] c4
            [FILE] 766937cb6d28e4736ead02ef6e8d89a9dbe999
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c4/766937cb6d28e4736ead02ef6e8d89a9dbe999: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
        [DIR] ea
            [FILE] d999d516a440e1432391a0dc1693de6a8c60fb
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ea/d999d516a440e1432391a0dc1693de6a8c60fb: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] cd
            [FILE] 19a5300d8992f1b4a85ff875afad33bc865cf7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cd/19a5300d8992f1b4a85ff875afad33bc865cf7: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
            [FILE] 813d66fe2a1edb83ec813bd46abc0dbd405000
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cd/813d66fe2a1edb83ec813bd46abc0dbd405000: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] cc
            [FILE] 6fcb7fed7105a75939c460c6aabd6a65759838
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cc/6fcb7fed7105a75939c460c6aabd6a65759838: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] e6
            [FILE] 6407638d6e2537dee45cb5a330655856b55144
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e6/6407638d6e2537dee45cb5a330655856b55144: 'utf-8' codec can't decode byte 0xf1 in position 22: invalid continuation byte
            [FILE] 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] f0
            [FILE] f72c9e06562db09401ea8045b0382b15f4288a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f0/f72c9e06562db09401ea8045b0382b15f4288a: 'utf-8' codec can't decode byte 0xcb in position 4: invalid continuation byte
        [DIR] e8
            [FILE] ad39d178eca07669f48e5547c41cee73c19cb3
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e8/ad39d178eca07669f48e5547c41cee73c19cb3: 'utf-8' codec can't decode byte 0xcc in position 19: invalid continuation byte
        [DIR] fa
            [FILE] bc41b26fff4a9067c6844ca8238c78c512d694
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/fa/bc41b26fff4a9067c6844ca8238c78c512d694: 'utf-8' codec can't decode byte 0xb0 in position 9: invalid start byte
        [DIR] c5
            [FILE] 0e35eb7e7e6936ff62dff42e3a4eea28547957
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c5/0e35eb7e7e6936ff62dff42e3a4eea28547957: 'utf-8' codec can't decode byte 0xb4 in position 8: invalid start byte
        [DIR] c2
            [FILE] a48dac6ee7771555fdbf7e2882f52c9629c138
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c2/a48dac6ee7771555fdbf7e2882f52c9629c138: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
            [FILE] eb54148762f2dfbe5d5a406fc8710befe21a83
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c2/eb54148762f2dfbe5d5a406fc8710befe21a83: 'utf-8' codec can't decode bytes in position 2-3: invalid continuation byte
        [DIR] f6
            [FILE] c4136d8286ed7a1aefc7960f2cc13406a294ff
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f6/c4136d8286ed7a1aefc7960f2cc13406a294ff: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
            [FILE] 4c0a0dda24de3aa3787111adac0f7de2763bdf
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f6/4c0a0dda24de3aa3787111adac0f7de2763bdf: 'utf-8' codec can't decode byte 0xc3 in position 6: invalid continuation byte
        [DIR] e9
            [FILE] a23b7351e956dcf5ef5940f40eb6bfef8fa5a8
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e9/a23b7351e956dcf5ef5940f40eb6bfef8fa5a8: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
        [DIR] cb
            [FILE] 382bbeeac4f792778cbd3d2df847ae2c82ad23
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cb/382bbeeac4f792778cbd3d2df847ae2c82ad23: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
        [DIR] 79
            [FILE] 09901bb36f68f9047b9bfb86524b960b1852ad
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/79/09901bb36f68f9047b9bfb86524b960b1852ad: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
        [DIR] 2d
            [FILE] 8c0b262ee07cd87d4cae5e69eb7ebf4d22bdd5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/2d/8c0b262ee07cd87d4cae5e69eb7ebf4d22bdd5: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
        [DIR] 41
            [FILE] 1aada76fc50a9a396da900bcf0745fc74d3d86
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/41/1aada76fc50a9a396da900bcf0745fc74d3d86: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] 1b
            [FILE] cf7bd5266b143b6773b42d5336b1cadffa6840
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/1b/cf7bd5266b143b6773b42d5336b1cadffa6840: 'utf-8' codec can't decode byte 0x91 in position 3: invalid start byte
        [DIR] 48
            [FILE] a19dfb642ff9e88c69529636c8850de553b1d0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/48/a19dfb642ff9e88c69529636c8850de553b1d0: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 1e
            [FILE] cd2bb99d9a3eb49df234bf712baa48428fbcef
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/1e/cd2bb99d9a3eb49df234bf712baa48428fbcef: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte
        [DIR] 24
            [FILE] f1856ac81f9db5c040ed835f979ee25b431af4
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/24/f1856ac81f9db5c040ed835f979ee25b431af4: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte
            [FILE] 8b435491bc0c548b3a5f3b3e262cbc8025495a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/24/8b435491bc0c548b3a5f3b3e262cbc8025495a: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte
        [DIR] 23
            [FILE] 13797a3843de3a5048c454fd9c3d546c64ae9c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/23/13797a3843de3a5048c454fd9c3d546c64ae9c: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
        [DIR] 4f
            [FILE] 56dc1fe98c84b39dc81787052644aba25d6f87
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/4f/56dc1fe98c84b39dc81787052644aba25d6f87: 'utf-8' codec can't decode byte 0xc8 in position 17: invalid continuation byte
        [DIR] 8d
            [FILE] dc567bf866fabb7c201ec4e7f5bc5d8ffb1c23
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/8d/dc567bf866fabb7c201ec4e7f5bc5d8ffb1c23: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
            [FILE] d5a5a9302a6832875d50a7ff0379f4af3716b0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/8d/d5a5a9302a6832875d50a7ff0379f4af3716b0: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] 15
            [FILE] 43ae6703233c87185a23de3881157dc0297180
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/15/43ae6703233c87185a23de3881157dc0297180: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] 85
            [FILE] 506ee4343a010964040c430ca06d8a9f44d5de
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/85/506ee4343a010964040c430ca06d8a9f44d5de: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 1d
            [FILE] d3252a3ccf409f82cb203dd0ef098e03b8f4a5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/1d/d3252a3ccf409f82cb203dd0ef098e03b8f4a5: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 40
            [FILE] 3a3aa7af7609c5127020a6b8fa99358ee93c4c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/40/3a3aa7af7609c5127020a6b8fa99358ee93c4c: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
            [FILE] a91dd036e7a64733156515fd4320060fcd06ea
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/40/a91dd036e7a64733156515fd4320060fcd06ea: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] 7f
            [FILE] 86e39aa2b4399ca085972d929987e18bfbe9a9
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/7f/86e39aa2b4399ca085972d929987e18bfbe9a9: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] 14
            [FILE] 38c01a74e6a5b774a68609f4f3957964b522a7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/14/38c01a74e6a5b774a68609f4f3957964b522a7: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
            [FILE] 2066071676f004de4f568d8b8de0e8965f3c01
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/14/2066071676f004de4f568d8b8de0e8965f3c01: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] 8e
            [FILE] 43a26b08a7ab41d24e63142978cd3008599614
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/8e/43a26b08a7ab41d24e63142978cd3008599614: 'utf-8' codec can't decode byte 0xcc in position 19: invalid continuation byte
        [DIR] 22
            [FILE] d5ed30217761c3b700c180dfbe4909d1bed401
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/22/d5ed30217761c3b700c180dfbe4909d1bed401: 'utf-8' codec can't decode byte 0x91 in position 3: invalid start byte
    [FILE] HEAD

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/HEAD ---
ref: refs/heads/main


    [DIR] info
        [FILE] exclude

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/info/exclude ---
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~


    [DIR] logs
        [FILE] HEAD

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/logs/HEAD ---
0000000000000000000000000000000000000000 142066071676f004de4f568d8b8de0e8965f3c01 kolotjob <jobkolot@gmail.com> 1736031501 +0330	commit (initial): structura
142066071676f004de4f568d8b8de0e8965f3c01 cf5044764a769064d88697d6cd9a985ff6cd17fa kolotjob <jobkolot@gmail.com> 1736597546 +0330	commit: updates
cf5044764a769064d88697d6cd9a985ff6cd17fa dcf4aa1a765f37862e733d975095b97c4a741632 kolotjob <jobkolot@gmail.com> 1736803972 +0100	commit: add functions
dcf4aa1a765f37862e733d975095b97c4a741632 8dd5a5a9302a6832875d50a7ff0379f4af3716b0 kolotjob <jobkolot@gmail.com> 1736814206 +0100	commit: add editig profile
8dd5a5a9302a6832875d50a7ff0379f4af3716b0 398198302175e14eee675c15e2bf2b51ef21648a kolotjob <jobkolot@gmail.com> 1736876885 +0100	commit: ddd
398198302175e14eee675c15e2bf2b51ef21648a 411aada76fc50a9a396da900bcf0745fc74d3d86 kolotjob <jobkolot@gmail.com> 1736889885 +0100	commit: hggj


        [DIR] refs
            [DIR] heads
                [FILE] main

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/logs/refs/heads/main ---
0000000000000000000000000000000000000000 142066071676f004de4f568d8b8de0e8965f3c01 kolotjob <jobkolot@gmail.com> 1736031501 +0330	commit (initial): structura
142066071676f004de4f568d8b8de0e8965f3c01 cf5044764a769064d88697d6cd9a985ff6cd17fa kolotjob <jobkolot@gmail.com> 1736597546 +0330	commit: updates
cf5044764a769064d88697d6cd9a985ff6cd17fa dcf4aa1a765f37862e733d975095b97c4a741632 kolotjob <jobkolot@gmail.com> 1736803972 +0100	commit: add functions
dcf4aa1a765f37862e733d975095b97c4a741632 8dd5a5a9302a6832875d50a7ff0379f4af3716b0 kolotjob <jobkolot@gmail.com> 1736814206 +0100	commit: add editig profile
8dd5a5a9302a6832875d50a7ff0379f4af3716b0 398198302175e14eee675c15e2bf2b51ef21648a kolotjob <jobkolot@gmail.com> 1736876885 +0100	commit: ddd
398198302175e14eee675c15e2bf2b51ef21648a 411aada76fc50a9a396da900bcf0745fc74d3d86 kolotjob <jobkolot@gmail.com> 1736889885 +0100	commit: hggj


            [DIR] remotes
                [DIR] origin
                    [FILE] main

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/logs/refs/remotes/origin/main ---
0000000000000000000000000000000000000000 142066071676f004de4f568d8b8de0e8965f3c01 kolotjob <jobkolot@gmail.com> 1736031505 +0330	update by push
142066071676f004de4f568d8b8de0e8965f3c01 cf5044764a769064d88697d6cd9a985ff6cd17fa kolotjob <jobkolot@gmail.com> 1736597547 +0330	update by push
cf5044764a769064d88697d6cd9a985ff6cd17fa dcf4aa1a765f37862e733d975095b97c4a741632 kolotjob <jobkolot@gmail.com> 1736803975 +0100	update by push
dcf4aa1a765f37862e733d975095b97c4a741632 8dd5a5a9302a6832875d50a7ff0379f4af3716b0 kolotjob <jobkolot@gmail.com> 1736814208 +0100	update by push
8dd5a5a9302a6832875d50a7ff0379f4af3716b0 398198302175e14eee675c15e2bf2b51ef21648a kolotjob <jobkolot@gmail.com> 1736876887 +0100	update by push
398198302175e14eee675c15e2bf2b51ef21648a 411aada76fc50a9a396da900bcf0745fc74d3d86 kolotjob <jobkolot@gmail.com> 1736889889 +0100	update by push


    [FILE] description

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/description ---
Unnamed repository; edit this file 'description' to name the repository.


    [DIR] hooks
        [FILE] commit-msg.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/commit-msg.sample ---
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}


        [FILE] pre-rebase.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-rebase.sample ---
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END


        [FILE] pre-commit.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-commit.sample ---
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --


        [FILE] applypatch-msg.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/applypatch-msg.sample ---
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:


        [FILE] fsmonitor-watchman.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/fsmonitor-watchman.sample ---
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}


        [FILE] pre-receive.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-receive.sample ---
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi


        [FILE] prepare-commit-msg.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/prepare-commit-msg.sample ---
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi


        [FILE] post-update.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/post-update.sample ---
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info


        [FILE] pre-merge-commit.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-merge-commit.sample ---
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:


        [FILE] pre-applypatch.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-applypatch.sample ---
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:


        [FILE] pre-push.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-push.sample ---
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0


        [FILE] update.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/update.sample ---
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0


        [FILE] push-to-checkout.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/push-to-checkout.sample ---
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi


    [DIR] refs
        [DIR] heads
            [FILE] main

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/refs/heads/main ---
411aada76fc50a9a396da900bcf0745fc74d3d86


        [DIR] tags
        [DIR] remotes
            [DIR] origin
                [FILE] main

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/refs/remotes/origin/main ---
411aada76fc50a9a396da900bcf0745fc74d3d86


    [FILE] index
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/index: 'utf-8' codec can't decode byte 0xb1 in position 15: invalid start byte
    [FILE] COMMIT_EDITMSG

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/COMMIT_EDITMSG ---
hggj


[FILE] __main__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/__main__.py ---
from aiogram import Bot, Dispatcher
from tortoise import Tortoise
import asyncio
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode

# Импортируем конфигурацию базы данных
from config import BOT_TOKEN, TORTOISE_ORM
from src.bot.handlers.registration import router as registration_router
from src.bot.handlers.anketa import router as anketa_router
from aiogram.exceptions import TelegramBadRequest
from src.utils.middleware import LoggingMiddleware, CallbackMiddleware
from src.utils.album import AlbumMiddleware, groupmedia, router as router_album
from src.utils.comands import router as router_comands
from aerich import Command
from src.bot.handlers.myprofile import router as myprofile_router
from src.bot.handlers.edit_profile import router as edit_profile_router
from src.bot.handlers.serch import router as search_router


# async def delete_webhook(bot: Bot):
#     try:
#         await bot.delete_webhook(drop_pending_updates=True)
#         print("Webhook successfully deleted.")
#     except TelegramBadRequest as e:
#         if "Not Found" in str(e):
#             print("Webhook is not set or already deleted.")
#         else:
#             print(f"Failed to delete webhook: {e}")
# Функция для инициализации базы данных
async def init_db():
    try:
        command = Command(
            tortoise_config=TORTOISE_ORM,
            app="models",
            location="./migrations"
        )
        await command.init()
        await command.upgrade()
        print("Database migrations applied successfully.")
    except Exception as e:
        print(f"Error while applying migrations: {e}")
    try:
        await Tortoise.init(config=TORTOISE_ORM)
        await Tortoise.generate_schemas()
        
        print("Database connection established and schemas generated.")
    except Exception as e:
        print(f"Error connecting to the database: {e}")

# Основной цикл бота
async def main():
    bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    dp = Dispatcher()
    dp.message.middleware(LoggingMiddleware())
    dp.callback_query.middleware(CallbackMiddleware())
    dp.message.middleware(AlbumMiddleware(groupmedia_handler=groupmedia))  # Пер
    # Подключаем маршруты (обработчики)
    dp.include_routers(registration_router,search_router, anketa_router, router_album, myprofile_router,router_comands, edit_profile_router)

    # Инициализируем базу данных
    await init_db()

    print("Bot is running...")
    try:
        # await delete_webhook(bot)
        await dp.start_polling(bot)
    finally:
        # Закрываем соединение с базой данных
        await Tortoise.close_connections()

# Запуск бота
if __name__ == "__main__":
    asyncio.run(main())


[DIR] src
    [FILE] models.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/models.py ---
from tortoise.models import Model
from tortoise import fields



class User(Model):
    user_id = fields.BigIntField(pk=True, unique=True)  # Уникальный Telegram ID пользователя
    uid_code = fields.CharField(max_length=50, unique=True)  # Уникальный код пользователя
    status_block = fields.CharField(max_length=255, default="Active")  # Статус (например, "Active", "Blocked")
    name = fields.CharField(max_length=50, null=True)  # Имя
    age = fields.IntField(null=True)  # Возраст
    orientation = fields.CharField(max_length=255, null=True)
    gender = fields.CharField(max_length=10, null=True)  # Пол (например, "male", "female", "other")
    medias = fields.JSONField(null=True)  # Ссылки на медиа (фото/видео)
    about = fields.TextField(null=True)  # Описание "О себе"
    location = fields.CharField(max_length=255, null=True)  # Локация
    preferences = fields.CharField(max_length=255, null=True)  # Кого ищет (например, "friends", "relationship")
    hobbies = fields.JSONField(null=True)  # Список увлечений (до 5)
    for_whom = fields.CharField(max_length=255, null=True)  # Кого показывать (например, "all", "man" , 'girl')
    subscription = fields.CharField(max_length=50, default="Free") 
    localstatus = fields.CharField(max_length=50, default="active") 

     # Тариф подписки (например, "Free", "Premium")
    subscription_start = fields.DatetimeField(null=True)  # Дата начала подписки (только для платных)
    subscription_end = fields.DatetimeField(null=True)  # Дата окончания подписки
    referral_uid = fields.CharField(max_length=50, unique=True, null=True)  # Telegram ID реферера
    balance = fields.DecimalField(max_digits=10, decimal_places=2, default=0.0)  # Баланс
    level = fields.DecimalField(max_digits=5, decimal_places=2, default=0.0)  # % от реферальной программы
    date_registered = fields.DatetimeField(auto_now_add=True)  # Дата регистрации
    lang = fields.CharField(max_length=50, default="nochoise") #язык поользователя
    class Meta:
        table = "users"





class Like(Model):
    like_id = fields.IntField(pk=True)  # Уникальный ID лайка
    from_user = fields.ForeignKeyField("models.User", related_name="sent_likes")  # Кто лайкнул
    to_user = fields.ForeignKeyField("models.User", related_name="received_likes")  # Кто получил лайк
    is_superlike = fields.BooleanField(default=False)  # Это суперлайк или обычный лайк
    message = fields.TextField(null=True)  # Сообщение, если было отправлено
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата создания лайка

    class Meta:
        table = "likes"


class Block(Model):
    block_id = fields.IntField(pk=True)  # Уникальный ID блокировки
    from_user = fields.ForeignKeyField("models.User", related_name="blocked_users")  # Кто заблокировал
    to_user = fields.ForeignKeyField("models.User", related_name="blocked_by")  # Кто заблокирован
    can_message = fields.BooleanField(default=False)  # Разрешены ли сообщения
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата блокировки

    class Meta:
        table = "blocks"


class Statement(Model):
    statement_id = fields.IntField(pk=True)  # Уникальный ID записи
    user = fields.ForeignKeyField("models.User", related_name="statements")  # Пользователь
    referral_count = fields.IntField(default=0)  # Количество рефералов
    subscription_level = fields.CharField(max_length=20, default="basic")  # Уровень подписки
    price = fields.DecimalField(max_digits=10, decimal_places=2, default=0.0)  # Цена подписки/транзакции
    referral_percentage = fields.DecimalField(max_digits=5, decimal_places=2, default=0.0)  # Процент отчислений за реферал
    payment_method = fields.CharField(max_length=50, null=True)  # Метод оплаты (например, "card", "paypal")
    transaction_id = fields.CharField(max_length=255, null=True)  # Уникальный ID транзакции
    status = fields.CharField(max_length=20, default="pending")  # Статус транзакции (успешно, ошибка)
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата создания записи

    class Meta:
        table = "statements"


    [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/__init__.py ---


    [DIR] utils
        [FILE] generate_uid.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/generate_uid.py ---
import random
import string

async def generate_uid_code(uids ):
    length=5
    uid=""
    while uid =="":

        """
        Генерирует уникальный код указанной длины, содержащий латинские заглавные и строчные буквы и цифры.

        :param length: Длина кода (по умолчанию 5).
        :return: Сгенерированный код.
        """
        characters = string.ascii_letters + string.digits  # Латинские буквы (верхний и нижний регистр) + цифры
        x_code=''.join(random.choices(characters, k=length))
        if x_code not in uids:
            uid = x_code
        else:
            continue
    return uid

# Пример использования



        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__init__.py ---


        [DIR] __pycache__
            [FILE] album.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/album.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] generate_uid.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/generate_uid.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] state.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/state.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] comands.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/comands.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] add_profile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/add_profile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] middleware.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/middleware.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] album.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/album.py ---
from aiogram import BaseMiddleware, types
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from typing import Callable, Awaitable, Dict, Any, List, Optional
from cachetools import TTLCache
from asyncio import sleep
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType
from src.utils.comands import set_user_specific_commands


DEFAULT_LATENCY = 0.2
DEFAULT_TTL = 0.600

router = Router()
# Middleware для обработки меди-альбомов
class AlbumMiddleware(BaseMiddleware):
    def __init__(
        self,
        groupmedia_handler: Callable[[Message, List[Dict[str, str]], List[int]], Awaitable[Any]],
        latency: float = DEFAULT_LATENCY,
        ttl: float = DEFAULT_TTL,
    ) -> None:
        super().__init__()
        self.groupmedia_handler = groupmedia_handler
        self.latency = latency
        self.cache: TTLCache = TTLCache(maxsize=10_000, ttl=ttl)

    @staticmethod
    async def get_media_data(message: Message) -> Optional[Dict[str, str]]:
        if message.photo:
            return {"file_id": message.photo[-1].file_id, "type": "photo", "message_id": message.message_id}
        if message.video:
            return {"file_id": message.video.file_id, "type": "video", "message_id": message.message_id}
        return None

    async def __call__(
        self,
        handler: Callable[[types.TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: types.TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        if isinstance(event, Message) and event.media_group_id is not None:
            state: FSMContext = data.get("state")

            if not state:
                return await handler(event, data)

            current_state: Optional[State] = await state.get_state()

            # Проверяем, находится ли пользователь в состоянии RegState.media
            if current_state != "RegState:media":
                return 403

            key = event.media_group_id
            media_data = await self.get_media_data(event)

            if not media_data:
                return await handler(event, data)

            # Если альбом уже собирается, добавляем текущий файл
            if key in self.cache:
                self.cache[key]["media_data"].append(media_data)
                return None

            # Создаем новый альбом в кэше
            self.cache[key] = {
                "media_data": [media_data]
            }

            # Ждем, пока все части альбома дойдут
            await sleep(self.latency)

            # Передаем собранный альбом и message_id для удаления в groupmedia_handler
            media_data_list = self.cache.pop(key)["media_data"]
            message_ids = [media["message_id"] for media in media_data_list]
            return await self.groupmedia_handler(event, media_data_list, message_ids, state)

        return await handler(event, data)
    




# Функция для обработки одиночного медиа
@router.message(RegState.media)
async def set_media(message: types.Message, user: User, state: FSMContext, lang: str):
    if message.media_group_id is None and (message.photo or message.video):  
        # Проверяем одиночные фото/видео
        if user:
            media = user.medias or []
            if len(media) < 3:
                media_data = {
                    "file_id": message.photo[-1].file_id if message.photo else message.video.file_id,
                    "type": "photo" if message.photo else "video"
                }
                await message.bot.delete_message(message.from_user.id, message.message_id)
                media.append(media_data)
                user.medias = media
                await user.save()

                

                # Обновляем сообщение прогресса
                data = await state.get_data()
                msg_id = None
                if "idmsg_media" in data:
                    msg_id=data["idmsg_media"]
                count = len(media)
                if count ==3:
                    txt = (
                    f"Сохранено {count}/3 медиа. Нажмите 'Сохранить'." 
                    if lang == "ru" 
                    else f"Saved {count}/3 media. Click 'Save'."
                )
                else:   
                    txt = (
                        f"Сохранено {count}/3 медиа. Отправьте ещё одно или нажмите 'Сохранить'." 
                        if lang == "ru" 
                        else f"Saved {count}/3 media. Send another one or click 'Save'."
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="Сохранить ✅" if lang == "ru" else "Save ✅", callback_data="save_album")]
                ])

                if msg_id:
                    try:
                        await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
                    except:
                        sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                        await state.update_data(idmsg_media=sent_message.message_id)
                else:
                    sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                    await state.update_data(idmsg_media=sent_message.message_id)
            else:
                txt = "Вы уже отправили максимальное количество медиа! 📸" if lang == "ru" else "You have already sent the maximum amount of media! 📸"
                await message.answer(txt)

# Функция для обработки меди-альбомов
async def groupmedia(message: Message, media_data_list: List[Dict[str, str]], message_ids , state: FSMContext):
    
    chat_id = message.chat.id  # Или используйте другой chat_id, если нужно
    print(message_ids)
    # Проверяем количество файлов в базе данных
    for id in message_ids:
        await message.bot.delete_message(message.from_user.id, id)
    user = await User.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer("Ошибка: пользователь не найден.")
        return
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Сохранить ✅" if user.lang == "ru" else "Save ✅", callback_data="save_album")]
    ])
    existing_files = user.medias or []

    # Если уже есть 2 файла, добавляем только первый файл из альбома
    if len(existing_files) == 2:
        existing_files.append(media_data_list[0])
        user.medias = existing_files
        await user.save()

        # Удаляем сообщение с медиа

        # Обновляем сообщение прогресса
        txt = (
            "Сохранён только первый файл из альбома. Теперь у вас 3/3 медиа. Нажмите 'Сохранить'." 
            if user.lang == "ru" 
            else "Only the first file from the album has been saved. You now have 3/3 media. Click 'Save'."
        )
        data = await state.get_data()
        msg_id = None
        if "idmsg_media" in data:
            msg_id=data["idmsg_media"]

        if msg_id:
            try:
                await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
            except:
                sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                await state.update_data(idmsg_media=sent_message.message_id)
        else:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
        return

    # Если альбом содержит больше 3 файлов, сохраняем только первые 3
    if len(existing_files) + len(media_data_list) > 3:
        remaining_slots = 3 - len(existing_files)
        existing_files.extend(media_data_list[:remaining_slots])
        user.medias = existing_files
        await user.save()

        # Удаляем сообщение с медиа
        # await message.delete()

        # Обновляем сообщение прогресса
        txt = (
            f"Сохранены только первые {remaining_slots} файла из альбома. Теперь у вас 3/3 медиа. Нажмите 'Сохранить'."
            if user.lang == "ru" 
            else f"Only the first {remaining_slots} files from the album have been saved. You now have 3/3 media. Click 'Save'."
        )
        data = await state.get_data()
        msg_id = None
        if "idmsg_media" in data:
            msg_id=data["idmsg_media"]

        if msg_id:
            try:
                await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
            except:
                sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                await state.update_data(idmsg_media=sent_message.message_id)
        else:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
        return

    # Если всё в порядке, сохраняем весь альбом
    existing_files.extend(media_data_list)
    user.medias = existing_files
    await user.save()

    # Удаляем сообщение с медиа

    # Обновляем сообщение прогресса
    if existing_files==3:
        txt = (
        f"Сохранено {len(existing_files)}/3 медиа. Нажать 'Сохранить'."
        if user.lang == "ru" 
        else f"Saved {len(existing_files)}/3 media. Click 'Save'."
    )
    else:
        txt = (
            f"Сохранено {len(existing_files)}/3 медиа. Можете отправить ещё одно или нажать 'Сохранить'."
            if user.lang == "ru" 
            else f"Saved {len(existing_files)}/3 media. You can send another one or click 'Save'."
        )

    

    # await message.answer(txt, reply_markup=keyboard)÷
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]

    if msg_id:
        try:
            await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
        except:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)


def create_start_search_keyboard(lang: str) -> ReplyKeyboardMarkup:
    """
    Создает клавиатуру с кнопкой "Начать поиск" на русском или английском языке.

    :param lang: Язык клавиатуры ('ru' или 'en').
    :return: Объект ReplyKeyboardMarkup.
    """
    if lang == "ru":
        button_text = "🚀 Начать поиск"
    else:
        button_text = "🚀 Start Search"

    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=button_text)]
        ],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    return keyboard

@router.callback_query(lambda c: "skip_album" in c.data, RegState.media)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    # print()
    await state.set_state(RegState.done)
    media = user.medias or []
    file_id='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'
    media_data = {
                    "file_id": file_id,
                    "type": "photo" 
                }
    media.append(media_data)
    user.medias = media
    await user.save()
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]
    txt='''🎉 <b>Профиль успешно заполнен! ✅</b>  

Теперь вы готовы начать находить интересных людей! 🌟  
➡️ Используйте меню внизу и нажмите "Начать поиск", чтобы приступить.  
Удачи! 🍀''' if lang == 'ru' else '''🎉 <b>Profile successfully completed! ✅</b>  

You’re now ready to start finding interesting people! 🌟  
➡️ Use the menu below and tap "Start Search" to begin.  
Good luck! 🍀
'''

    keyboard = create_start_search_keyboard(lang)
    await set_user_specific_commands(callback_query.bot, callback_query.from_user.id, lang )

    if msg_id:
        try:
            await callback_query.bot.edit_message_text(chat_id=callback_query.from_user.id, message_id=msg_id, text=txt, reply_markup=keyboard)
        except:
            sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)


@router.callback_query(lambda c: "save_album" in c.data, RegState.media)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
    await state.set_state(RegState.done)
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]
    txt='''🎉 <b>Профиль успешно заполнен! ✅</b>  

Теперь вы готовы начать находить интересных людей! 🌟  
➡️ Используйте меню внизу и нажмите "Начать поиск", чтобы приступить.  
Удачи! 🍀''' if lang == 'ru' else '''🎉 <b>Profile successfully completed! ✅</b>  

You’re now ready to start finding interesting people! 🌟  
➡️ Use the menu below and tap "Start Search" to begin.  
Good luck! 🍀
'''

    keyboard = create_start_search_keyboard(lang)
    await set_user_specific_commands(callback_query.bot, callback_query.from_user.id, lang )
    if msg_id:
        try:
            try:
                await callback_query.message.edit_reply_markup(reply_markup=None)
                sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)

            except:
                await callback_query.message.delete()
                sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
                
                
        except:
            sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)

        [FILE] comands.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/comands.py ---
from aiogram import Bot, Dispatcher, types
from aiogram.types import BotCommand, BotCommandScopeChat
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType


router = Router()



@router.message(Command("lang"))
async def set_name(message: types.Message, state: FSMContext, lang: str):
    user = await User.get_or_none(user_id=message.from_user.id)
    if user.lang:
        if user.lang=="ru":
            lang='en'
            user.lang=lang
            await user.save()
        else:
            lang='ru'
            user.lang=lang
            await user.save()
        await set_user_specific_commands(message.bot, message.from_user.id, lang)
        if lang == "ru":
            button_text = "🚀 Начать поиск"
        else:
            button_text = "🚀 Start Search"

        keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text=button_text)]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        txt ="""Вы измменили язык ✅
        
ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль.""" if lang=='ru' else"""You have changed the language ✅

ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."""

        await message.answer(txt, reply_markup=keyboard)





async def set_user_specific_commands(bot:Bot, user_id, lang):
    # Определяем команды для пользователя
    user_specific_commands = [
        
        BotCommand(command="myprofile", description="Профиль" if lang=='ru' else "Profile"),
        BotCommand(command="help", description="Помощь"if lang=='ru' else "Help"),
        BotCommand(command="subs", description="Подписка" if lang=='ru' else "Subscription"),
        BotCommand(command="ref", description="Реф. программа" if lang=='ru' else "Ref. program"),
        BotCommand(command="lang", description="Изменить язык" if lang=='ru' else "Change language")
    ]

    # Устанавливаем команды только для указанного пользователя
    await bot.set_my_commands(
        commands=user_specific_commands,
        scope=BotCommandScopeChat(chat_id=user_id)
    )

async def delete_user_specific_commands(bot: Bot, user_id: int):
    """
    Удаляет команды, установленные для конкретного пользователя.
    """
    await bot.delete_my_commands(
        scope=BotCommandScopeChat(chat_id=user_id)
    )

        [FILE] add_profile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/add_profile.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.types import InputMediaPhoto, InputMediaVideo
from src.utils.state import RegState
from src.utils.comands import set_user_specific_commands, delete_user_specific_commands

async def add_profile(message: types.Message, state: FSMContext, lang: str, user: User):
    if user:
        # Если имя не указано
        if user.name is None:
            txt = (
                "<b>🎉</b>\nТеперь давай настроим твой профиль, чтобы ты мог(ла) быстрее найти интересных людей. 🌟\n\n➡️ Укажи свое имя, чтобы мы могли начать!"
                if lang == "ru" else
                "<b>🎉</b>\nNow let’s set up your profile so you can start meeting interesting people faster. 🌟\n\n➡️ Please provide your name to get started!"
            )
            await state.set_state(RegState.name)
            await message.answer(txt)
            return

        # Если имя указано, но пол не выбран
        if user.gender is None:
            txt = (
                f"<b>Отлично,{user.name}</b>\nТеперь укажи свой пол! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                f"<b>Great,{user.name}</b>\nNow specify your gender! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другой" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.gender)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если пол указан, но ориентация не выбрана
        if user.orientation is None:
            txt = (
                "Теперь укажи свою ориентацию! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                "Now specify your orientation! 🌟\n\n➡️ Choose one of the options:"
            )
            if user.gender == 'mal':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'fem':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'oth':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если ориентация указана, но не указаны предпочтения для просмотра
        if user.for_whom is None:
            txt = (
"Теперь укажи, кого ты хочешь видеть! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
"Now specify who you want to see! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_girls")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_boys")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_everyone")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если предпочтения для просмотра указаны, но возраст не указан
        elif user.age is None:
            txt = (
                "Теперь укажи свой возраст! 🌟\n\n➡️ Введите ваш возраст (минимум 16 лет):"
                if lang == "ru" else
                "Now specify your age! 🌟\n\n➡️ Enter your age (minimum 16 years):"
            )
            await state.set_state(RegState.age)
            await message.answer(txt)
            return
        # Если все данные собраны, переходим к следующему шагу
        if user.preferences is None:
            txt = (
                "Теперь укажи свои цели! 🌟\n\n➡️ Выбери цели из предложенных вариантов:"
                if lang == "ru" else
                "Now specify your goals! 🌟\n\n➡️ Choose your goals from the options provided:"
            )
            inline_keyboard=[]
            if lang =="ru":
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
            else:
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.preferences)
            await message.answer(txt, reply_markup=keyboard)
            return
        if user.location is None:

            keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )

            if lang == "ru":
                txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
            else:
                txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

            await state.set_state(RegState.location)
            msg = await message.bot.send_message(message.from_user.id ,text=txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)
            return
        if user.about is None:
            if lang == "ru":
                txt = """
Теперь расскажи немного о себе. 🌟

➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
"""
            else:
                txt = """
Now tell us a bit about yourself. 🌟

➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
"""
            await state.set_state(RegState.about)
            await message.bot.send_message(message.from_user.id, txt)
            return
        if user.hobbies is None:
            state_data = await state.get_data()
            current_page = state_data.get("current_page", 1)
            hobbies = state_data.get("selected_hobbies", [])  # Загружаем хобби из состояния или базы

            if len(hobbies) < 5:
                await state.set_state(RegState.hobbies)

                # Увлечения на двух языках с номерами
                interests = [
                    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
                    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
                    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
                    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
                    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
                    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
                    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
                    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
                    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
                    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
                    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
                    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
                    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
                    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
                    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
                    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
                ]
                page_size = 10
                start_index = (current_page - 1) * page_size
                end_index = start_index + page_size

                # Генерация кнопок для текущей страницы
                inlinekeyboard = []
                row = []

                for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
                    text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
                    row.append(InlineKeyboardButton(
                        text=text,
                        callback_data=f"intrs_{number}"
                    ))
                    if len(row) == 2 or i == len(interests[start_index:end_index]):
                        inlinekeyboard.append(row)
                        row = []

                # Добавляем кнопки навигации
                navigation_buttons = []
                if current_page > 1:
                    navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
                if end_index < len(interests):
                    navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
                if navigation_buttons:
                    inlinekeyboard.append(navigation_buttons)

                if len(hobbies) == 5:
                    inlinekeyboard.append(
                        [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)

                if lang == "ru":
                    if hobbies:
                        txt = f"<b>У вас уже выбрано {len(hobbies)}/5 увлечений ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми \"<b>Сохранить✅</b>\"."
                else:
                    if hobbies:
                        txt = f"<b>You have already selected {len(hobbies)}/5 hobbies ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\"."

                await state.update_data(current_page=current_page, hobbies=hobbies)  # Сохраняем данные в состояние
                await message.answer(txt, reply_markup=keyboard)
                return


        if user.medias is None:

            txt = """

Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """

Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
Or press "Skip" to continue. ⏩"""
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
            ])
            await state.set_state(RegState.media)
            data = await state.get_data()

            msg = await message.bot.send_message(chat_id=message.from_user.id, text=txt, reply_markup=keyboard)
            data["idmsg_media"] = msg.message_id
            await state.update_data(data=data)
            return
        else:
            
            if lang == "ru":
                button_text = "🚀 Начать поиск"
            else:
                button_text = "🚀 Start Search"

            keyboard = ReplyKeyboardMarkup(
                keyboard=[
                    [KeyboardButton(text=button_text)]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            )
            await set_user_specific_commands(message.bot, message.from_user.id, lang )
            response = (
        "ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль." 
        if lang == "ru" 
        else "ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."
    )
            await message.answer(response, reply_markup=keyboard)

            

        [FILE] middleware.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/middleware.py ---
import logging
from aiogram import BaseMiddleware, types
from aiogram.types import Update
from typing import Callable, Any, Awaitable
from aiogram.fsm.context import FSMContext
from src.models import User
from aiogram.types import CallbackQuery
from src.utils.generate_uid import generate_uid_code
from src.bot.handlers.registration import choise_lang


class LoggingMiddleware(BaseMiddleware):
    """
    Middleware for logging all incoming updates and outgoing responses,
    ensuring user profile completeness and language setup.
    """

    async def __call__(
        self,
        handler: Callable[[Update, dict], Awaitable[Any]],
        event: Update,
        data: dict,
    ) -> Any:
        # Логируем входящее событие
        logging.info(f"Incoming update: {event}")
        state: FSMContext
        state: FSMContext = data.get("state")  # FSMContext передается через data
        current_state = await state.get_state() if state else None
        # Получаем user_id из обновления
        user_id = event.from_user.id if event.from_user else None

        if user_id:
            # Проверяем, существует ли пользователь в базе данных
            user = await User.get_or_none(user_id=user_id)
            if user:
                if user.status_block == "Active":
                    data["user"] = user
                    
                    # Устанавливаем язык
                    if user.lang == "nochoise":
                        data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                        return await choise_lang(event, data)
                    else:
                        data["lang"] = user.lang

                    # Проверка на полноту профиля
                    
                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias
                    ]) and event.text and ("/start" not in event.text and "/del" not in event.text) and current_state is None:
                        message_text = (
                            "Кажется, ваш профиль заполнен не до конца. \u2028"
                            "Нажмите /start, чтобы заполнить профиль и скорее приступить к поиску нужных людей."
                            if user.lang == "ru" else
                            "It seems your profile is incomplete. \u2028"
                            "Press /start to complete your profile and start connecting with people."
                        )
                        if isinstance(event, types.Message):
                            await event.answer(message_text)
                        return
                else:
                    # Если пользователь заблокирован, возвращаем статус 403
                    if isinstance(event, types.Message):
                        await event.answer("Ваш аккаунт заблокирован." if user.lang == "ru" else "Your account is blocked.")
                    return 403
            else:
                # Новый пользователь
                uid_ref = None
                if event.text and "/start" in event.text:
                    parts = event.text.split(" ")
                    if len(parts) > 1:
                        uid_ref = parts[1]
                        ref_user = await User.get_or_none(uid_code=uid_ref)
                        if ref_user:
                            if ref_user.lang == "ru":
                                await event.bot.send_message(ref_user.user_id, "У вас новый реферал")
                            else:
                                await event.bot.send_message(ref_user.user_id, "You have a new referral")

                # Генерация UID
                users = await User.all().values_list("uid_code", flat=True)
                uid = await generate_uid_code(uids=users)

                # Создание нового пользователя
                user = await User.create(user_id=user_id, uid_code=uid, referral_uid=uid_ref)
                data["user"] = user
                data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                return await choise_lang(event, data)

        # Передаём управление следующему обработчику
        response = await handler(event, data)

        # Логируем ответ
        logging.info(f"Outgoing response: {response}")

        return response




class CallbackMiddleware(BaseMiddleware):
    """
    Middleware для обработки callback-запросов.
    Проверяет статус пользователя и передаёт язык пользователя.
    """

    async def __call__(
        self,
        handler: Callable[[CallbackQuery, dict], Awaitable[Any]],
        event: CallbackQuery,
        data: dict,
    ) -> Any:
        # Логируем входящее событие
        logging.info(f"Incoming callback query: {event}")

        # Получаем user_id из callback
        user_id = event.from_user.id if event.from_user else None

        if user_id:
            # Проверяем, существует ли пользователь в базе данных
            user = await User.get_or_none(user_id=user_id)
            if user:
                if user.status_block == "Active":
                    data["user"] = user
                    data["lang"] = user.lang or ("ru" if event.from_user.language_code in ["ru", "uk"] else "en")
                else:
                    # Если пользователь заблокирован, отправляем сообщение и возвращаем статус 403
                    await event.answer("Ваш аккаунт заблокирован.", show_alert=True)
                    return 403
            else:
                # Если пользователь отсутствует, предлагаем выбрать язык
                data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                if event.data == "lang_ru" or event.data == "lang_en":
                    data["lang"] = "ru" if event.data == "lang_ru" else "en"
                    return await handler(event, data)
                return await choise_lang(event.message, data)

        # Передаём управление следующему обработчику
        response = await handler(event, data)

        # Логируем ответ
        logging.info(f"Outgoing response for callback query: {response}")

        return response


        [FILE] state.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/state.py ---
from aiogram.fsm.state import StatesGroup
from aiogram.fsm.state import State


class RegState(StatesGroup):

    name =State()
    age = State()
    gender = State()
    preferences = State()
    location = State()
    about = State()
    media = State()
    hobbies = State()
    show = State()
    orientation = State()
    done = State()




class SearchPeople(StatesGroup):
    search = State()
    like = State()
    superlike = State()
    dislike = State()
    block = State()
    report = State()
    stop = State()
    message = State()
    show = State()
    show_profile = State()
    show_media = State()
    show_hobbies = State()
    show_about = State()
    show_location = State()
    show_preferences = State()


class ReditState(StatesGroup):

    name =State()
    age = State()
    gender = State()
    preferences = State()
    location = State()
    about = State()
    media = State()
    hobbies = State()
    show = State()
    orientation = State()
    done = State()
 

    [DIR] __pycache__
        [FILE] models.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/__pycache__/models.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
    [DIR] bot
        [DIR] __pycache__
            [FILE] config.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/__pycache__/config.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [DIR] handlers
            [FILE] registration.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/registration.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.types import InputMediaPhoto, InputMediaVideo
from src.utils.state import RegState
from src.utils.generate_uid import generate_uid_code

from src.utils.comands import set_user_specific_commands, delete_user_specific_commands
import random

from aiogram.types import WebAppInfo, InlineKeyboardMarkup, InlineKeyboardButton

def get_web_app_button():
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(
                text="🔍 Найти пользователей",
                web_app=WebAppInfo(url="https://ffa0-162-213-64-84.ngrok-free.app/profile/cards/")
            )]
        ]
    )
router = Router()

@router.message(Command("search"))
async def start_search(message: types.Message):
    button = get_web_app_button()
    await message.answer("Нажмите кнопку ниже, чтобы начать поиск пользователей:", reply_markup=button)



@router.message(CommandStart())
async def handle_message1(message: types.Message, state: FSMContext, lang: str, user: User = None, user_none: bool = False):
    if user:
        # Если имя не указано
        if user.name is None:
            txt = (
                "<b>🎉</b>\nТеперь давай настроим твой профиль, чтобы ты мог(ла) быстрее найти интересных людей. 🌟\n\n➡️ Укажи свое имя, чтобы мы могли начать!"
                if lang == "ru" else
                "<b>🎉</b>\nNow let’s set up your profile so you can start meeting interesting people faster. 🌟\n\n➡️ Please provide your name to get started!"
            )
            await state.set_state(RegState.name)
            await message.answer(txt)

        # Если имя указано, но пол не выбран
        elif user.name is not None and user.gender is None:
            txt = (
                f"<b>Отлично,{user.name}</b>\nТеперь укажи свой пол! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                f"<b>Great,{user.name}</b>\nNow specify your gender! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другой" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.gender)
            await message.answer(txt, reply_markup=keyboard)

        # Если пол указан, но ориентация не выбрана
        elif user.name is not None and user.gender is not None and user.orientation is None:
            txt = (
                "Теперь укажи свою ориентацию! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                "Now specify your orientation! 🌟\n\n➡️ Choose one of the options:"
            )
            if user.gender == 'mal':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'fem':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'oth':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await message.answer(txt, reply_markup=keyboard)

        # Если ориентация указана, но не указаны предпочтения для просмотра
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is None:
            txt = (
"Теперь укажи, кого ты хочешь видеть! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
"Now specify who you want to see! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_everyone")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await message.answer(txt, reply_markup=keyboard)

        # Если предпочтения для просмотра указаны, но возраст не указан
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.age is None:
            txt = (
                "Теперь укажи свой возраст! 🌟\n\n➡️ Введите ваш возраст (минимум 16 лет):"
                if lang == "ru" else
                "Now specify your age! 🌟\n\n➡️ Enter your age (minimum 16 years):"
            )
            await state.set_state(RegState.age)
            await message.answer(txt)

        # Если все данные собраны, переходим к следующему шагу
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.age is not None and user.preferences is None:
            txt = (
                "Теперь укажи свои цели! 🌟\n\n➡️ Выбери цели из предложенных вариантов:"
                if lang == "ru" else
                "Now specify your goals! 🌟\n\n➡️ Choose your goals from the options provided:"
            )
            inline_keyboard=[]
            if lang =="ru":
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
            else:
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.preferences)
            await message.answer(txt, reply_markup=keyboard)
        elif user.name is not None and user.age is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is None:

            keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )

            if lang == "ru":
                txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
            else:
                txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

            await state.set_state(RegState.location)
            msg = await message.bot.send_message(message.from_user.id ,text=txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)

        elif user.name is not None and user.age is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is None:
            if lang == "ru":
                txt = """
Теперь расскажи немного о себе. 🌟

➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
"""
            else:
                txt = """
Now tell us a bit about yourself. 🌟

➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
"""
            await state.set_state(RegState.about)
            await message.bot.send_message(message.from_user.id, txt)
        elif user.name is not None and user.age is not None and user.gender is not None and user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is not None and user.hobbies is None:
            state_data = await state.get_data()
            current_page = state_data.get("current_page", 1)
            hobbies = state_data.get("selected_hobbies", [])  # Загружаем хобби из состояния или базы

            if len(hobbies) < 5:
                await state.set_state(RegState.hobbies)

                # Увлечения на двух языках с номерами
                interests = [
                    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
                    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
                    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
                    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
                    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
                    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
                    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
                    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
                    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
                    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
                    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
                    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
                    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
                    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
                    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
                    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
                ]
                page_size = 10
                start_index = (current_page - 1) * page_size
                end_index = start_index + page_size

                # Генерация кнопок для текущей страницы
                inlinekeyboard = []
                row = []

                for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
                    text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
                    row.append(InlineKeyboardButton(
                        text=text,
                        callback_data=f"intrs_{number}"
                    ))
                    if len(row) == 2 or i == len(interests[start_index:end_index]):
                        inlinekeyboard.append(row)
                        row = []

                # Добавляем кнопки навигации
                navigation_buttons = []
                if current_page > 1:
                    navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
                if end_index < len(interests):
                    navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
                if navigation_buttons:
                    inlinekeyboard.append(navigation_buttons)

                if len(hobbies) == 5:
                    inlinekeyboard.append(
                        [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)

                if lang == "ru":
                    if hobbies:
                        txt = f"<b>У вас уже выбрано {len(hobbies)}/5 увлечений ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми \"<b>Сохранить✅</b>\"."
                else:
                    if hobbies:
                        txt = f"<b>You have already selected {len(hobbies)}/5 hobbies ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\"."

                await state.update_data(current_page=current_page, hobbies=hobbies)  # Сохраняем данные в состояние
                await message.answer(txt, reply_markup=keyboard)


        elif user.name is not None and user.age is not None and user.gender is not None and user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is not None and user.hobbies is not None and user.medias is None:

            txt = """

Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """

Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
Or press "Skip" to continue. ⏩"""
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
            ])
            await state.set_state(RegState.media)
            data = await state.get_data()

            msg = await message.bot.send_message(chat_id=message.from_user.id, text=txt, reply_markup=keyboard)
            data["idmsg_media"] = msg.message_id
            await state.update_data(data=data)

        else:
            
            if lang == "ru":
                button_text = "🚀 Начать поиск"
            else:
                button_text = "🚀 Start Search"

            keyboard = ReplyKeyboardMarkup(
                keyboard=[
                    [KeyboardButton(text=button_text)]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            )
            await set_user_specific_commands(message.bot, message.from_user.id, lang )
            response = (
        "ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль." 
        if lang == "ru" 
        else "ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."
    )
            await message.answer(response, reply_markup=keyboard)

            
        









@router.message(Command("block"))
async def handle_message(message: types.Message, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    # if user:
    #     user.status_block="Deactive"
    #     await user.save()
    await delete_user_specific_commands(message.bot, message.from_user.id)

    

@router.message(Command("del"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    
    if user:
        await user.delete()
        # await user.save()


# Список столиц мира с их координатами
WORLD_CAPITALS = [
    ("Moscow", 55.7558, 37.6173),
    ("Washington, D.C.", 38.9072, -77.0369),
    ("London", 51.5074, -0.1278),
    ("Tokyo", 35.6895, 139.6917),
    ("Paris", 48.8566, 2.3522),
    ("Berlin", 52.5200, 13.4050),
    ("Beijing", 39.9042, 116.4074),
    ("Canberra", -35.2809, 149.1300),
    ("Ottawa", 45.4215, -75.6972),
    ("Brasília", -15.8267, -47.9218)
]
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"fem":"👩 Девушки",
    "mal":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "fem":"👩 Girls",
    "mal":"👨 Boys",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"💫Другая",
                "skip":"Не указана"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"💫Other",
                "skip":"Not specified"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}


async def generate_random_profiles():
    interests = [interest[1] for interest in INTERESTS]

    for _ in range(200):
        # Случайный выбор пола, ориентации и других параметров
        gender = random.choice(list(GENDER["en"].keys()))
        orientation = random.choice(list(ORI["en"].keys()))
        for_whom = random.choice(list(WHO["en"].keys()))
        preference = random.choice(list(PREFERENCES["en"].keys()))

        # Случайная локация
        city, latitude, longitude = random.choice(WORLD_CAPITALS)
        location = f"{latitude},{longitude}"

        # Случайные увлечения (до 5)
        hobbies = random.sample(interests, k=random.randint(1, 5))

        # Случайное имя и описание
        name = f"User{random.randint(1000, 9999)}"
        about = "I love " + ", ".join(random.sample(interests, k=2)) + "."
        media=[]
        media_data = {
                    "file_id": 'AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ',
                    "type": "photo" 
                }
        users = await User.all().values_list("uid_code", flat=True)
        uid = await generate_uid_code(uids=users)
        media.append(media_data)
        # Создание пользователя
        await User.create(
            name=name,
            age=random.randint(18, 50),
            gender=gender,
            orientation=orientation,
            for_whom=for_whom,
            preferences=preference,
            location=location,
            about=about,
            hobbies=hobbies,
            medias=None,
            uid_code=uid,
            lang='ru' # Медиаданные остаются пустыми

        )

    print("200 random profiles created successfully!")
@router.message(Command("add"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    await generate_random_profiles()
    await message.answer("200 случайных профилей успешно созданы!")

        
@router.message(Command("del1"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    
    if user:
        user.age=None
        await user.save()


async def choise_lang(message: types.Message, lang: str):
    if lang['lang']=="ru":
    
        txt="""<b>Привет! 👋</b>
На связи <b>💖Emi-Date💖</b> — твой помощник в мире знакомств для людей в эмиграции. 🌍✨

Чтобы начать, пожалуйста, выбери язык, который тебе удобен:
"""
    else:
        txt="""<b>Hi there! 👋</b>
Welcome to <b>💖Emi-Date💖</b> — your go-to bot for connecting with people in emigration. 🌍✨

To get started, please select your preferred language:
"""
    
    # Кнопки для выбора языка
    
    inline_keyboard=[]
    inline_keyboard.append([InlineKeyboardButton(text="🇷🇺 Русский", callback_data="lang_ru")])
    inline_keyboard.append([InlineKeyboardButton(text="🇺🇸 English", callback_data="lang_en")])

    keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)

    await message.answer(text=txt, reply_markup=keyboard)




@router.message(Command("album"))
async def handle_message(message: types.Message, user: User = None, user_none: bool = False):

    media_files = [
        InputMediaPhoto(media='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'),
        InputMediaPhoto(media='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'),
        # Добавьте до 10 медиафайлов
    ]

    # Отправка медиа-группы
    await message.bot.send_media_group(chat_id=message.from_user.id, media=media_files)










@router.callback_query(lambda c: "lang_" in c.data)
async def callback_handler(callback_query: CallbackQuery, state: FSMContext, lang: str):
    lang = (callback_query.data.split("_"))[1]
    user_id = callback_query.from_user.id
    user= await User.get_or_none(user_id=user_id)
    if user:
        user.lang=lang
        await user.save()
    if user.name==None:
        keyboard = None
        if lang == "ru":
            txt = """<b>Отлично! 🎉</b>
Нажми /start, чтобы быстрее найти интересных людей. 🌟

"""
        else:
            txt = """<b>Great! 🎉</b
Tap /start to quickly find interesting people. 🌟
    """
        await callback_query.bot.edit_message_text(text=txt, chat_id=user_id, message_id=callback_query.message.message_id, reply_markup=None)
        
       


  







            [FILE] likes.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/likes.py ---


            [FILE] anketa.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/anketa.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from src.utils.add_profile import add_profile
from aiogram.types import ContentType


router = Router()
BAD_WORDS = [
    # Наркотики
    "наркотик", "наркота", "косяк", "травка", "гашиш", "героин", "кокаин", "амфетамин", "экстази",
    "марихуана", "спайс", "лсд", "шишки", "опиум", "план", "кристалл", "мефедрон", "drugs", "drug",
    "weed", "marijuana", "cocaine", "heroin", "ecstasy", "meth", "amphetamine", "hash", "spice",
    "lsd", "crystal", "meph", "opium", "j0int", "dr@g", "tr@vka",

    # CP
    "детская порнография", "детское порно", "запрещенное видео", "нелегальный контент", "порнография с детьми",
    "cp", "child porn", "child pornography", "illegal content", "b@nned video", "ch!ld p0rn",

    # Оружие
    "оружие", "пистолет", "винтовка", "автомат", "пулемет", "граната", "мина", "бомба", "арсенал",
    "ружье", "ствол", "калашников", "ак-47", "глок", "гранатомет", "weapon", "gun", "pistol", "rifle",
    "machine gun", "grenade", "bomb", "landmine", "arsenal", "shotgun", "kalashnikov", "ak47",
    "glock", "rocket launcher", "we@pon", "glock-19", "b0mb",

    # Additional prohibited words
    "explosive", "tnt", "c4", "detonator", "silencer", "sniper", "assault rifle", "pipe bomb",
    "наркот", "герич", "герыч", "доза", "спайсы", "соли", "фен", "скорость",
    "запрещенка", "порно с детьми", "порево", "kill", "murder", "mass shooting", "terrorist", "attack"
]






# ++++++++++++++++ NAME +++++++++++++++

@router.message(RegState.name)
async def set_name(message: types.Message, state: FSMContext, lang: str):
    user = await User.get_or_none(user_id=message.from_user.id)
    global BAD_WORDS
    if user:
        
        if message.text not in BAD_WORDS:
            user.name = message.text.strip()
            await user.save()
            if user.gender is None:
                
                if lang == "ru":
                    txt = """<b>Имя указано! ✅</b>
    Отлично, теперь укажи свой пол! 🌟

    ➡️ Выбери один из вариантов:
    """
                else:
                    txt = """<b>Name provided! ✅</b>
    Great, now specify your gender! 🌟

    ➡️ Choose one of the options:
    """

                inline_keyboard = [
                    [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                    [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                    [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
                ]

                keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
                await state.set_state(RegState.gender)
                await message.answer(txt, reply_markup=keyboard)
            else:
                txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
                await state.set_state(state=None)

                
                if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=message, state=state , user=user, lang=lang)
                else:
                    await message.answer(txt)

        else:
            txt = """<❌ <b>Ошибка:</b> Ваше имя содержит запрещенные слова. Пожалуйста, выберите другое имя. ✍️""" if lang == "ru" else """<❌ <b>Error:</b> Your name contains prohibited words. Please choose another name. ✍️"""
            await state.set_state(RegState.name)
            await message.answer(txt)
        
# ++++++++++++++++ GENDER +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("gender_"), RegState.gender)
async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.gender = callback_query.data.split("_")[1]
        await user.save()
        if user.orientation is None:
            if lang == "ru":
                txt = """<b>Пол указан! ✅</b>
    Теперь укажи свою ориентацию! 🌟

    ➡️ Выбери один из вариантов:
    """
            else:
                txt = """<b>Gender saved! ✅</b>
    Now specify your orientation! 🌟

    ➡️ Choose one of the options:
    """
            if user.gender =='mal':

                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender =="fem":
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender=="oth":
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]

            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)
# ++++++++++++++++ ORIENTATION +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("orientation_"), RegState.orientation)
async def set_orientation(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.orientation = callback_query.data.split("_")[1]
        await user.save()
        if user.for_whom is None:
            if lang == "ru":
                txt = """<b>Ориентация указана! ✅</b>
    Теперь укажи, кого ты хочешь видеть! 🌟

    ➡️ Выбери один из вариантов:
    """
            else:
                txt = """<b>Orientation saved! ✅</b>
    Now specify who you want to see! 🌟

    ➡️ Choose one of the options:
    """

            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")]
            ]

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ SHOW PREFERENCES +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("show_"), RegState.show)
async def set_show_preferences(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.for_whom = callback_query.data.split("_")[1]
        await user.save()
        if user.age is None:
            if lang == "ru":
                txt = """<b>Параметры просмотра указаны! ✅</b>
    Теперь укажи свой возраст! 🌟

    ➡️ Введите ваш возраст (минимум 16 лет):
    """
            else:
                txt = """<b>Viewing preferences saved! ✅</b>
    Now specify your age! 🌟

    ➡️ Enter your age (minimum 16 years):
    """

            await state.set_state(RegState.age)
            await callback_query.message.edit_text(txt)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ AGE +++++++++++++++

@router.message(RegState.age)
async def set_age(message: types.Message, user: User, state: FSMContext, lang: str):
    if user:
        if message.text.isdigit():
            age = int(message.text)
            if age >= 16:
                user.age = age
                await user.save()
                if user.preferences is None:
                    if lang == "ru":
                        txt = """<b>Возраст указан! ✅</b>
    Теперь укажи свои цели! 🌟

    ➡️ Выбери цели из предложенных вариантов:
    """
                    else:
                        txt = """<b>Age saved! ✅</b>
    Now specify your goals! 🌟

    ➡️ Choose your goals from the options provided:
    """
                    inline_keyboard=[]
                    if lang =="ru":
                        inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                        inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                        inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                        inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
                    else:
                        inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                        inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                        inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                        inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])


                    keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
                    await state.set_state(RegState.preferences)
                    await message.answer(txt, reply_markup=keyboard)
                else:
                    txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
                    await state.set_state(state=None)

                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                        await add_profile(message=message, state=state , user=user, lang=lang)
                    else:
                        await message.answer(txt)
            else:
                txt = """❌ <b>Ошибка:</b> Возраст должен быть не менее 16 лет. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be at least 16 years. 🔢"""
                await message.answer(txt)
        else:
            txt = """❌ <b>Ошибка:</b> Возраст должен быть числом. Пожалуйста, введите корректное значение. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be a number. Please enter a valid value. 🔢"""
            await message.answer(txt)


# ++++++++++++++++ PREFERENCES +++++++++++++++

@router.callback_query(lambda c: "interest_" in c.data, RegState.preferences)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
    if user:
        pref = callback_query.data.split("_")[1]
        user.preferences=pref
        await user.save()
        if user.location is None:
            keyboard = ReplyKeyboardMarkup(
                keyboard=[[ KeyboardButton(text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",request_location=True)]],resize_keyboard=True,one_time_keyboard=True)

            if lang == "ru":
                txt = """<b>Цели поиска указаны! ✅</b>
    Отлично, теперь нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍

    ⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

    💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
    Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

    ➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
    """
            else:
                txt = """<b>Search goals saved! ✅</b>
    Great, now we need your location to suggest people nearby. 🌍

    ⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

    💡 <b>Note:</b> You can send your current location by pressing the button below. 
    If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

    ➡️ Please press the button below to share your location or choose a point on the map.
    """

            await state.set_state(RegState.location)
            await callback_query.bot.delete_message(callback_query.from_user.id, callback_query.message.message_id)
            msg= await callback_query.bot.send_message(callback_query.from_user.id, txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ LOCATION +++++++++++++++

@router.message(RegState.location, lambda message: message.content_type == ContentType.LOCATION)
async def set_location(message: types.Message, user: User, state: FSMContext, lang: str):
    
    if user:
        print(f"\n\n\n\n\n\n\n\n\n\n\n\n\n\n{message.location}\n\n\n\n\n\n\n\n\n\n\n\n{message.location.model_config}")
        user.location = f"{message.location.latitude},{message.location.longitude}"
        await user.save()
        if user.about is None:
            if lang == "ru":
                txt = """<b>Локация указана! ✅</b>
    Отлично, теперь расскажи немного о себе. 🌟

    ➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
    """
            else:
                txt = """<b>Location saved! ✅</b>
    Great, now tell us a bit about yourself. 🌟

    ➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
    """
            await state.set_state(RegState.about)
            data = await state.get_data()
            if "idmsg_local" in data: 
                await message.bot.delete_message(message.from_user.id, data["idmsg_local"])
            data["idmsg_local"]=''
            await state.update_data(data)
            await message.bot.delete_message(message.from_user.id, message.message_id)
            await message.bot.send_message(message.from_user.id, txt)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=message, state=state , user=user, lang=lang)
            else:
                await message.answer(txt)
# ++++++++++++++++ ABOUT +++++++++++++++

@router.message(RegState.about)
async def set_about(message: types.Message, user: User, state: FSMContext, lang: str):
    global BAD_WORDS
    if user:
        if message.text:
            if message.text not in BAD_WORDS:
                user.about = message.text
                await user.save()
                if user.hobbies is None:
                
                    await state.set_state(RegState.hobbies)
                # Увлечения на двух языках с номерами
                    interests = [
                        (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
                    ]
                    inlinekeyboard = []
                    row = []

                    # Формируем кнопки для увлечений, по 3 в ряд
                    for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
                        row.append(InlineKeyboardButton(
                            text=interest_ru if lang == "ru" else interest_en,
                            callback_data=f"intrs_{number}"
                        ))
                        # Если добавлено 3 кнопки или это последняя кнопка в списке
                        if len(row) == 2 or i == len(interests[:10]):
                            inlinekeyboard.append(row)
                            row = []  # Сбрасываем строку для следующего ряда

                    # Добавляем стрелки навигации в последнюю строку
                    inlinekeyboard.append([
                        InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
                        InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
                    ])

                    keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
                    
                    if lang == "ru":
                        txt = """<b>Записали ✅</b>
    Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟

    ➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
        """
                    else:
                        txt = """<b>Saved ✅</b>
    Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
    """


                    await message.answer(txt, reply_markup=keyboard)
                else:
                    txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."
                    await state.set_state(state=None)

                    
                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                        await add_profile(message=message, state=state , user=user, lang=lang)
                    else:
                        await message.answer(txt)
            else:
                if lang == "ru":
                    txt = """❌ <b>Ошибка:</b> Описание содержит запрещенные слова. Пожалуйста, введите другое описание и попробуйте снова. ✍️"""
                else:
                    txt = """❌ <b>Error:</b> The description contains prohibited words. Please enter another description and try again. ✍️"""
                await message.answer(txt)
                await state.set_state(RegState.about)
        else:
                if lang == "ru":
                    txt = """❌ <b>Ошибка:</b> Описание долджно содержать текст ✍️"""
                else:
                    
                    txt = """❌ <b>Error:</b> The description must contain text. Please write something ✍️"""
                await message.answer(txt)
                await state.set_state(RegState.about)

# ++++++++++++++++ HOBBIES +++++++++++++++

@router.callback_query(lambda c: "intrs_" in c.data or c.data.startswith("intrs_page") or c.data == "intrs_done", RegState.hobbies)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    # Загружаем список интересов
    interests = [
        (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]

    # Обработка страниц
    state_data = await state.get_data()
    current_page = state_data.get("current_page", 1)
    hobbies = state_data.get("selected_hobbies", [])

    if callback_query.data.startswith("intrs_page"):
        if "next" in callback_query.data:
            current_page += 1
        elif "back" in callback_query.data:
            current_page -= 1
        await state.update_data(current_page=current_page)

    elif callback_query.data.startswith("intrs_") and callback_query.data != "intrs_done":
        interest = callback_query.data.split("_")[1]
        if interest in hobbies:
            hobbies.remove(interest)
        else:
            if len(hobbies) < 5:
                hobbies.append(interest)
            else:
                txt1 = "Выбрано максимальное количество! Уберите один интерес или нажмите 'Сохранить'." if lang == "ru" else "Maximum number selected! Remove one interest or click 'Save'."
                await callback_query.answer(
                    txt1,
                    show_alert=True
                )
                return
        await state.update_data(selected_hobbies=hobbies)

    elif callback_query.data == "intrs_done":
        if len(hobbies) < 5:
            txt2 = "Вы должны выбрать минимум 5 интересов, чтобы продолжить!" if lang == "ru" else "You must select at least 5 interests to continue!"
            await callback_query.answer(
                txt2,
                show_alert=True
            )
            return
        else:
            user.hobbies = hobbies  # Сохраняем в базу данных только при завершении
            await user.save()
            if user.medias is None:
                txt3 = "Интересы сохранены! ✅" if lang == "ru" else "Interests saved! ✅"
                await callback_query.answer(txt3, show_alert=True)

                txt = """🎉 <b>Отлично!</b> Ваши хобби успешно сохранены.  

    Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
    Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """🎉 <b>Great!</b> Your hobbies have been successfully saved.  

    Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
    Or press "Skip" to continue. ⏩"""

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
                ])
                data = await state.get_data()
                msg =await callback_query.message.edit_text(txt, reply_markup=keyboard)
                data['idmsg_media']=msg.message_id
                await state.update_data(data)
                await state.set_state(RegState.media)
                return
            else:
                txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."
                await state.set_state(state=None)
                await callback_query.answer(txt, show_alert=True)

                if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
                else:
                    await callback_query.message.edit_text(txt, reply_markup=None)
                return

    # Генерация кнопок для текущей страницы
    page_size = 10
    start_index = (current_page - 1) * page_size
    end_index = start_index + page_size
    inlinekeyboard = []
    row = []

    for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
        text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
        row.append(InlineKeyboardButton(
            text=text,
            callback_data=f"intrs_{number}"
        ))
        if len(row) == 2 or i == len(interests[start_index:end_index]):
            inlinekeyboard.append(row)
            row = []

    navigation_buttons = []
    if current_page > 1:
        navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
    if end_index < len(interests):
        navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
    if navigation_buttons:
        inlinekeyboard.append(navigation_buttons)

    if len(hobbies) == 5:
        inlinekeyboard.append(
            [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
        )

    keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
    txt = (f"<b>Выбрано {len(hobbies)}/5 увлечений ✅</b>\n" if lang == "ru" else f"<b>Selected {len(hobbies)}/5 hobbies ✅</b>\n")
    txt += "Отлично, выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми 'Сохранить'." if lang == "ru" else "Great, select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click 'Save'."

    await callback_query.message.edit_text(txt, reply_markup=keyboard)

            [FILE] myprofile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/myprofile.py ---
from aiogram import Router, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo
from src.models import User
from aiogram.filters import CommandStart, Command
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState

router = Router()

# Словари переводов
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"fem":"👩 Девушки",
    "mal":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "fem":"👩 fem",
    "mal":"👨 mal",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"💫Другая",
                "skip":"Не указана"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"💫Other",
                "skip":"Not specified"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}

import ssl
import certifi
from geopy.geocoders import Nominatim

def get_location_by_coordinates(latitude, longitude):
    geolocator = Nominatim(
        user_agent="my_geopy_app",
        timeout=10,
        ssl_context=ssl.create_default_context(cafile=certifi.where())
    )
    try:
        location = geolocator.reverse((latitude, longitude), exactly_one=True)
        if location:
            address = location.raw.get('address', {})
            city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
            return city or location.address
        else:
            return "Местоположение не найдено"
    except Exception as e:
        return f"Ошибка при определении местоположения: {e}"
    

@router.message(Command("myprofile"))
async def my_profile_handler(message: types.Message,state: FSMContext):
    user = await User.get_or_none(user_id=message.from_user.id)

    if not user:
        lang = "ru"
        await message.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
        return

    lang = user.lang if user.lang in ["ru", "en"] else "ru"
    hobbies_text = ", ".join([
        (interest[1] if lang == "ru" else interest[2])
        for interest in INTERESTS
        if str(interest[0]) in (user.hobbies or [])
    ])

    location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
    if "," in location_text:
        latitude, longitude = map(float, location_text.split(","))
        location_text = get_location_by_coordinates(latitude, longitude)

    subscription_text = (
        f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
    )
    if user.subscription != "Free":
        subscription_text += (
            f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
        )

    description = (
        f"<b>{'Ваш профиль' if lang == 'ru' else 'Your profile'}:</b>\n\n"
        f"<b>{'Имя' if lang == 'ru' else 'Name'}:</b> {user.name}\n"
        f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
        f"<b>{'Пол' if lang == 'ru' else 'Gender'}:</b> {GENDER[lang][user.gender]}\n"
        f"<b>{'Локация' if lang == 'ru' else 'Location'}:</b> {location_text or ('Локация не указана' if lang == 'ru' else 'Location not provided')}\n\n"
        f"{subscription_text}"
        f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
        f"<b>{'Кого показывать' if lang == 'ru' else 'Viewing Preferences'}:</b> {WHO[lang][user.for_whom]}\n"
        f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
        f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
        f"_________________________\n{user.about or ''}\n"
    )



    media = user.medias or []
    if len(media) == 1:
        media_file = media[0]['file_id']
        if media[0]['type'] == 'photo':
            msg= await message.bot.send_photo(message.from_user.id, media_file, caption=description)
        elif media[0]['type'] == 'video':
            msg= await message.bot.send_video(message.from_user.id, media_file, caption=description)
    else:
        files=[]
        i =0
        for media_file in media:
            
            caption=description if i == 0 else None
            
            if media_file["type"] =="video":
                files.append(InputMediaVideo(media=f"{media_file['file_id']}", caption=caption))
                i = i+1
            elif media_file['type'] == 'photo':
                files.append(InputMediaPhoto(media=f"{media_file['file_id']}", caption=caption))
                i = i+1
            else:
                continue
                 

    # Отправка медиа-группы
        msg= await message.bot.send_media_group(chat_id=message.from_user.id, media=files)
        data= await state.get_data()
        data["id_card_profile"]=None
        await state.update_data(data=data)
    lang = user.lang if user and user.lang in ["ru", "en"] else "ru"
    if user.localstatus == "active":
        btn_local = InlineKeyboardButton(
            text="🌍 Скрыть локацию" if lang == "ru" else "🌍 Hide Location",
            callback_data="location_hish"
        )
    else:
        btn_local = InlineKeyboardButton(
            text="🌍 Показать локацию" if lang == "ru" else "🌍 Show Location",
            callback_data="location_hish"
        )

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="🖋 Имя" if lang == "ru" else "🖋 Name",
                callback_data="fedit_name"
            ),
            InlineKeyboardButton(
                text="🎂 Возраст" if lang == "ru" else "🎂 Age",
                callback_data="fedit_age"
            )
        ],
        [
            InlineKeyboardButton(
                text="📍 Изменить локацию" if lang == "ru" else "📍 Edit Location",
                callback_data="fedit_location"
            ),
            btn_local
        ],
        [
            InlineKeyboardButton(
                text="⚥ Пол" if lang == "ru" else "⚥ Gender",
                callback_data="fedit_gender"
            ),
            InlineKeyboardButton(
                text="🌈 Ориентация" if lang == "ru" else "🌈 Orientation",
                callback_data="fedit_orientation"
            )
        ],
        [
            InlineKeyboardButton(
                text="👁️‍🗨️ Кого показывать" if lang == "ru" else "👁️‍🗨️ Viewing Preferences",
                callback_data="fedit_pref"
            ),
            InlineKeyboardButton(
                text="🎯 Цели" if lang == "ru" else "🎯 Goals",
                callback_data="fedit_goals"
            )
        ],
        [
            InlineKeyboardButton(
                text="🎨 Увлечения" if lang == "ru" else "🎨 Hobbies",
                callback_data="fedit_hobbies"
            ),
            InlineKeyboardButton(
                text="📝 Описание" if lang == "ru" else "📝 Description",
                callback_data="fedit_descr"
            )
        ],[
    InlineKeyboardButton(
        text="🖼️ Изменить медиа" if lang == "ru" else "🖼️ Edit Media",
        callback_data="fedit_media"
    )
],

        [
            InlineKeyboardButton(
                text="🔄 Заполнить заново" if lang == "ru" else "🔄 Refill Profile",
                callback_data="reset_profile"
            )
        ]
    ])


    await message.answer(
        MESSAGES["action_prompt"][lang], 
        reply_markup=keyboard
    )


            [DIR] __pycache__
                [FILE] myproffile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/myproffile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] edit_profile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/edit_profile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] serch.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/serch.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] anketa.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/anketa.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] registration.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/registration.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] myprofile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/myprofile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] edit_profile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/edit_profile.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType
from src.utils.comands import set_user_specific_commands
from aiogram import Router, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo
from src.models import User
from aiogram.filters import CommandStart, Command
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from src.utils.add_profile import add_profile



# Словари переводов
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"girls":"👩 Девушки",
    "boys":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "girls":"👩 Girls",
    "boys":"👨 Boys",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"Другая"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"Other"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}

import ssl
import certifi
from geopy.geocoders import Nominatim

def get_location_by_coordinates(latitude, longitude):
    geolocator = Nominatim(
        user_agent="my_geopy_app",
        timeout=10,
        ssl_context=ssl.create_default_context(cafile=certifi.where())
    )
    try:
        location = geolocator.reverse((latitude, longitude), exactly_one=True)
        if location:
            address = location.raw.get('address', {})
            city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
            return city or location.address
        else:
            return "Местоположение не найдено"
    except Exception as e:
        return f"Ошибка при определении местоположения: {e}"

router = Router()

                # "🖋 Имя" if 🖋 Name",callback_data="fedit_name"
                # "🎂 Возраст" if 🎂 Age",callback_data="fedit_age"
                # "📍 Изменить локацию" if 📍 Edit Location",callback_data="fedit_location"
                # "⚥ Пол" if ⚥ Gender",callback_data="fedit_gender"            
                # "🌈 Ориентация" if 🌈 Orientation",callback_data="fedit_orientation"
                # "👁️‍🗨️ Кого показывать" if 👁️‍🗨️ Viewing Preferences",callback_data="fedit_pref"
                # "🎯 Цели" if 🎯 Goals",callback_data="fedit_goals"           
                # "🎨 Увлечения" if 🎨 Hobbies",callback_data="fedit_hobbies"
                # "📝 Описание" if 📝 Description",callback_data="fedit_descr"
            

@router.callback_query(lambda c: c.data.startswith("fedit_"))
async def set_edit_field(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    cb_data = (callback_query.data.split("_"))[1]
    data = await state.get_data()
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="Назад⬅️" if lang == "ru" else "Back⬅️",
                callback_data="fedit_back"
            )
        ]
    ])

    if cb_data == "name":
        txt = "🌟➡️ Укажи свое имя, чтобы мы могли начать!\n\nИли надмите <b>'назад⬅️'</b> чтобы отменить действвие " if lang == "ru" else "🌟➡️ Please provide your name to get started!\n\nOr press <b>'back⬅️'</b> to undo the action"
        data = await state.get_data()
        await state.set_state(RegState.name)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "age":
        txt = "🎂➡️ Укажи свой возраст, чтобы продолжить!\n(минимум 16 лет):\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "🎂➡️ Please provide your age to proceed!\n(minimum 16 years):\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.age)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "location":
        if lang == "ru":
            txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
        else:
            txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

        data = await state.get_data()
        keyboard1 = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        await state.set_state(RegState.location)
        txt1="Жду локаци..." if lang=="ru" else "Waiting for the location..."
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        msg1 = await callback_query.bot.send_message(callback_query.from_user.id, txt1, reply_markup=keyboard1)
        data["idmsg_local"] = msg1.message_id
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data == "gender":
        txt = "⚥➡️ Укажи свой пол, чтобы мы могли лучше настроить профиль!\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "⚥➡️ Please specify your gender to better customize your profile!\n\nOr press <b>'back⬅️'</b> to undo the action."
        # Добавляем кнопки для выбора пола
        inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")],
                [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
            ]

        keyboard1 = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        msg= await callback_query.message.edit_text(txt, reply_markup=keyboard1)
        data = await state.get_data()
        await state.set_state(RegState.gender)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "orientation":
        if user.gender =='mal':

            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]
        elif user.gender =="fem":
            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]
        elif user.gender=="oth":
            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]


        inline_keyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard1 = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        txt = "🌈➡️ Укажи свою ориентацию, чтобы мы могли найти подходящих людей!\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "🌈➡️ Please specify your orientation so we can find the right people for you!\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.orientation)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard1)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "pref":
        txt = "👁️‍🗨️➡️ Укажи, кого ты хочешь видеть в своей ленте: девушек, парней или всех!\n\nИли нажми <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "👁️‍🗨️➡️ Specify who you want to see in your feed: girls, boys, or everyone!\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.show)
        inline_keyboard = [
            [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
            [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
            [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")],
            [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
        ]

        keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "goals":
        if lang == "ru":
            txt = """Укажи свои цели! 🌟

➡️ Выбери цели из предложенных вариантов:
"""
        else:
            txt = """<Specify your goals! 🌟

➡️ Choose your goals from the options provided:
"""
        inline_keyboard=[]
        if lang =="ru":
            inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
            inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
            inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
            inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
        else:
            inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
            inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
            inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
            inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

        inline_keyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        await state.set_state(RegState.preferences)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "hobbies":
    # Увлечения на двух языках с номерами
        interests = [
            (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
            (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
            (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
            (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
            (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
        ]
        inlinekeyboard = []
        row = []

        # Формируем кнопки для увлечений, по 3 в ряд
        for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
            row.append(InlineKeyboardButton(
                text=interest_ru if lang == "ru" else interest_en,
                callback_data=f"intrs_{number}"
            ))
            # Если добавлено 3 кнопки или это последняя кнопка в списке
            if len(row) == 2 or i == len(interests[:10]):
                inlinekeyboard.append(row)
                row = []  # Сбрасываем строку для следующего ряда

        # Добавляем стрелки навигации в последнюю строку
        inlinekeyboard.append([
            InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
            InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
        ])
        inlinekeyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
        if lang == "ru":
            txt = """
Выбери до 5 увлечений, которые описывают тебя. 🌟

➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
"""
        else:
            txt = """
Select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
    """
        await state.set_state(RegState.hobbies)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data == "descr":
        txt = (
"📝➡️ Напиши короткое описание о себе, чтобы другие могли узнать тебя лучше! Укажи свои увлечения, интересы или что-то, что ты хотел бы рассказать о себе. 🌟\n\nИли нажми <b>'назад⬅️'</b>, чтобы отменить действие."
        if lang == "ru"
        else "📝➡️ Write a short description about yourself so others can get to know you better! Share your hobbies, interests, or anything you'd like to tell about yourself. 🌟\n\nOr press <b>'back⬅️'</b> to undo the action."
        )

        data = await state.get_data()
        await state.set_state(RegState.about)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "media":
        txt = (
"📷 Пожалуйста, отправьте <b>от 1 до 3 медиа</b> (фотографии или видео), чтобы обновить ваш профиль.\n\n"
"Нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else
"📷 Please send <b>1 to 3 media</b> (photos or videos) to update your profile.\n\n"
"Press <b>'back⬅️'</b> to cancel the action."
)       
        await state.set_state(RegState.media)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_media"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data =="back":
        await state.set_state(state=None)
        data = await state.get_data()
        if 'idmsg_local' in data:
            if data["idmsg_local"] is not None:
                await callback_query.bot.delete_message(callback_query.from_user.id, data["idmsg_local"])
                data["idmsg_local"]=None
                await state.update_data(data=data)
                await state.clear()
        

        user = await User.get_or_none(user_id=callback_query.from_user.id)

        if not user:
            lang = "ru"
            await callback_query.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
            return

        lang = user.lang if user.lang in ["ru", "en"] else "ru"
        hobbies_text = ", ".join([
            (interest[1] if lang == "ru" else interest[2])
            for interest in INTERESTS
            if str(interest[0]) in (user.hobbies or [])
        ])

        location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
        if "," in location_text:
            latitude, longitude = map(float, location_text.split(","))
            location_text = get_location_by_coordinates(latitude, longitude)

        subscription_text = (
            f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
        )
        if user.subscription != "Free":
            subscription_text += (
                f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
            )

        description = (
            f"<b>{'Ваш профиль' if lang == 'ru' else 'Your profile'}:</b>\n\n"
            f"<b>{'Имя' if lang == 'ru' else 'Name'}:</b> {user.name}\n"
            f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
            f"<b>{'Пол' if lang == 'ru' else 'Gender'}:</b> {GENDER[lang][user.gender]}\n"
            f"<b>{'Локация' if lang == 'ru' else 'Location'}:</b> {location_text or ('Локация не указана' if lang == 'ru' else 'Location not provided')}\n\n"
            f"{subscription_text}"
            f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
            f"<b>{'Кого показывать' if lang == 'ru' else 'Viewing Preferences'}:</b> {WHO[lang][user.for_whom]}\n"
            f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
            f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
            f"_________________________\n{user.about or ''}\n"
        )



        media = user.medias or []
        # if len(media) == 1:
        #     media_file = media[0]['file_id']
        #     if media[0]['type'] == 'photo':
        #         await callback_query.bot.send_photo(callback_query.from_user.id, media_file, caption=description)
        #     elif media[0]['type'] == 'video':
        #         await callback_query.bot.send_video(callback_query.from_user.id, media_file, caption=description)
        lang = user.lang if user and user.lang in ["ru", "en"] else "ru"
        if user.localstatus == "active":
            btn_local = InlineKeyboardButton(
                text="🌍 Скрыть локацию" if lang == "ru" else "🌍 Hide Location",
                callback_data="location_hish"
            )
        else:
            btn_local = InlineKeyboardButton(
                text="🌍 Показать локацию" if lang == "ru" else "🌍 Show Location",
                callback_data="location_hish"
            )

        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="🖋 Имя" if lang == "ru" else "🖋 Name",
                    callback_data="fedit_name"
                ),
                InlineKeyboardButton(
                    text="🎂 Возраст" if lang == "ru" else "🎂 Age",
                    callback_data="fedit_age"
                )
            ],
            [
                InlineKeyboardButton(
                    text="📍 Изменить локацию" if lang == "ru" else "📍 Edit Location",
                    callback_data="fedit_location"
                ),
                btn_local
            ],
            [
                InlineKeyboardButton(
                    text="⚥ Пол" if lang == "ru" else "⚥ Gender",
                    callback_data="fedit_gender"
                ),
                InlineKeyboardButton(
                    text="🌈 Ориентация" if lang == "ru" else "🌈 Orientation",
                    callback_data="fedit_orientation"
                )
            ],
            [
                InlineKeyboardButton(
                    text="👁️‍🗨️ Кого показывать" if lang == "ru" else "👁️‍🗨️ Viewing Preferences",
                    callback_data="fedit_pref"
                ),
                InlineKeyboardButton(
                    text="🎯 Цели" if lang == "ru" else "🎯 Goals",
                    callback_data="fedit_goals"
                )
            ],
            [
                InlineKeyboardButton(
                    text="🎨 Увлечения" if lang == "ru" else "🎨 Hobbies",
                    callback_data="fedit_hobbies"
                ),
                InlineKeyboardButton(
                    text="📝 Описание" if lang == "ru" else "📝 Description",
                    callback_data="fedit_descr"
                )
            ],
            [
                InlineKeyboardButton(
                    text="🔄 Заполнить заново" if lang == "ru" else "🔄 Refill Profile",
                    callback_data="reset_profile"
                )
            ]
        ])


        await callback_query.message.edit_text(
            MESSAGES["action_prompt"][lang], 
            reply_markup=keyboard
        )
    else:
        await callback_query.answer("Неизвестная команда" if lang == "ru" else "Unknown command", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("reset_"))
async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    cb_data = (callback_query.data.split("_"))[1]
    if user:
        if cb_data == "profile":
            
            txt = """<b>Вы собираетесь заполнить профиль заново. ❗️</b>

            После нажатия <b>"ДА"</b> это действие будет <b>необратимо</b>. Все текущие данные профиля будут удалены.

            Вы точно уверены в этом?""" if lang == "ru" else """<b>You are about to refill your profile. ❗️</b>

            Once you press <b>"YES"</b>, this action will be <b>irreversible</b>. All current profile data will be deleted.

            Are you sure about this?"""
            inline_keyboard = [
                [InlineKeyboardButton(text="Да" if lang == "ru" else "Yes", callback_data="reset_yes")],
                [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        elif cb_data == "yes":  
            user.name=None
            user.age=None
            user.gender=None
            user.orientation=None
            user.for_whom=None
            user.preferences=None
            user.location=None
            user.about=None
            user.hobbies=None
            user.medias=None
            await user.save()
            await state.clear()
            await callback_query.answer("Профиль удален" if lang == "ru" else "Profile deleted", show_alert=True)
            await callback_query.message.edit_reply_markup(reply_markup=None)
            await add_profile(message=callback_query.message, state=state , user=user, lang=lang)








            await callback_query.answer("Профиль удален" if lang == "ru" else "Profile deleted")

# ===+++++=====+++++++=======++++++ HANDLERS ===+++++=====+++++++=======++++++ 

# BAD_WORDS = [
#     # Наркотики
#     "наркотик", "наркота", "косяк", "травка", "гашиш", "героин", "кокаин", "амфетамин", "экстази",
#     "марихуана", "спайс", "лсд", "шишки", "опиум", "план", "кристалл", "мефедрон", "drugs", "drug",
#     "weed", "marijuana", "cocaine", "heroin", "ecstasy", "meth", "amphetamine", "hash", "spice",
#     "lsd", "crystal", "meph", "opium", "j0int", "dr@g", "tr@vka",

#     # CP
#     "детская порнография", "детское порно", "запрещенное видео", "нелегальный контент", "порнография с детьми",
#     "cp", "child porn", "child pornography", "illegal content", "b@nned video", "ch!ld p0rn",

#     # Оружие
#     "оружие", "пистолет", "винтовка", "автомат", "пулемет", "граната", "мина", "бомба", "арсенал",
#     "ружье", "ствол", "калашников", "ак-47", "глок", "гранатомет", "weapon", "gun", "pistol", "rifle",
#     "machine gun", "grenade", "bomb", "landmine", "arsenal", "shotgun", "kalashnikov", "ak47",
#     "glock", "rocket launcher", "we@pon", "glock-19", "b0mb",

#     # Additional prohibited words
#     "explosive", "tnt", "c4", "detonator", "silencer", "sniper", "assault rifle", "pipe bomb",
#     "наркот", "герич", "герыч", "доза", "спайсы", "соли", "фен", "скорость",
#     "запрещенка", "порно с детьми", "порево", "kill", "murder", "mass shooting", "terrorist", "attack"
# ]






# # ++++++++++++++++ NAME +++++++++++++++

# @router.message(RegState.name)
# async def set_name(message: types.Message, state: FSMContext, lang: str):
#     user = await User.get_or_none(user_id=message.from_user.id)
#     global BAD_WORDS
#     if user:
#         if message.text not in BAD_WORDS:
#             user.name = message.text.strip()
#             await user.save()
            
#             if lang == "ru":
#                 txt = """<b>Имя указано! ✅</b>
# Отлично, теперь укажи свой пол! 🌟

# ➡️ Выбери один из вариантов:
# """
#             else:
#                 txt = """<b>Name provided! ✅</b>
# Great, now specify your gender! 🌟

# ➡️ Choose one of the options:
# """

#             inline_keyboard = [
#                 [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
#                 [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
#                 [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
#             ]

#             keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#             await state.set_state(RegState.gender)
#             await message.answer(txt, reply_markup=keyboard)
#         else:
#             txt = """<❌ <b>Ошибка:</b> Ваше имя содержит запрещенные слова. Пожалуйста, выберите другое имя. ✍️""" if lang == "ru" else """<❌ <b>Error:</b> Your name contains prohibited words. Please choose another name. ✍️"""
#             await state.set_state(RegState.name)
#             await message.answer(txt)


# # ++++++++++++++++ GENDER +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("gender_"), RegState.gender)
# async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.gender = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Пол указан! ✅</b>
# Теперь укажи свою ориентацию! 🌟

# ➡️ Выбери один из вариантов:
# """
#         else:
#             txt = """<b>Gender saved! ✅</b>
# Now specify your orientation! 🌟

# ➡️ Choose one of the options:
# """
#         if user.gender =='mal':

#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]
#         elif user.gender =="fem":
#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]
#         elif user.gender=="oth":
#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]



#         keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#         await state.set_state(RegState.orientation)
#         await callback_query.message.edit_text(txt, reply_markup=keyboard)


# # ++++++++++++++++ ORIENTATION +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("orientation_"), RegState.orientation)
# async def set_orientation(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.orientation = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Ориентация указана! ✅</b>
# Теперь укажи, кого ты хочешь видеть! 🌟

# ➡️ Выбери один из вариантов:
# """
#         else:
#             txt = """<b>Orientation saved! ✅</b>
# Now specify who you want to see! 🌟

# ➡️ Choose one of the options:
# """

#         inline_keyboard = [
#             [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
#             [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
#             [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")]
#         ]

#         keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#         await state.set_state(RegState.show)
#         await callback_query.message.edit_text(txt, reply_markup=keyboard)


# # ++++++++++++++++ SHOW PREFERENCES +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("show_"), RegState.show)
# async def set_show_preferences(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.for_whom = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Параметры просмотра указаны! ✅</b>
# Теперь укажи свой возраст! 🌟

# ➡️ Введите ваш возраст (минимум 16 лет):
# """
#         else:
#             txt = """<b>Viewing preferences saved! ✅</b>
# Now specify your age! 🌟

# ➡️ Enter your age (minimum 16 years):
# """

#         await state.set_state(RegState.age)
#         await callback_query.message.edit_text(txt)


# # ++++++++++++++++ AGE +++++++++++++++

# @router.message(RegState.age)
# async def set_age(message: types.Message, user: User, state: FSMContext, lang: str):
#     if user:
#         if message.text.isdigit():
#             age = int(message.text)
#             if age >= 16:
#                 user.age = age
#                 await user.save()

#                 if lang == "ru":
#                     txt = """<b>Возраст указан! ✅</b>
# Теперь укажи свои цели! 🌟

# ➡️ Выбери цели из предложенных вариантов:
# """
#                 else:
#                     txt = """<b>Age saved! ✅</b>
# Now specify your goals! 🌟

# ➡️ Choose your goals from the options provided:
# """
#                 inline_keyboard=[]
#                 if lang =="ru":
#                     inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
#                     inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
#                     inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
#                     inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
#                 else:
#                     inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
#                     inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
#                     inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
#                     inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])


#                 keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#                 await state.set_state(RegState.preferences)
#                 await message.answer(txt, reply_markup=keyboard)
#             else:
#                 txt = """❌ <b>Ошибка:</b> Возраст должен быть не менее 16 лет. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be at least 16 years. 🔢"""
#                 await message.answer(txt)
#         else:
#             txt = """❌ <b>Ошибка:</b> Возраст должен быть числом. Пожалуйста, введите корректное значение. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be a number. Please enter a valid value. 🔢"""
#             await message.answer(txt)


# # ++++++++++++++++ PREFERENCES +++++++++++++++

# @router.callback_query(lambda c: "interest_" in c.data, RegState.preferences)
# async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
#     if user:
#         pref = callback_query.data.split("_")[1]
#         user.preferences=pref
#         await user.save()
#         keyboard = ReplyKeyboardMarkup(
#             keyboard=[
#                 [
#                     KeyboardButton(
#                         text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
#                         request_location=True
#                     )
#                 ]
#             ],
#             resize_keyboard=True,
#             one_time_keyboard=True
#         )

#         if lang == "ru":
#             txt = """
# Нам нужно знать твою локацию, чтобы предложить людей рядом. 🌍

# ⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

# 💡 <b>Обратите внимание:</b> с тарифом <b>Pro</b> вы можете указать любую интересующую вас локацию и искать людей в том месте, где вам удобно! Это отличный способ расширить круг общения и найти людей из интересующих вас регионов. 🌎

# ➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию.
# """
#         else:
#             txt = """
# We need your location to suggest people nearby. 🌍

# ⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

# 💡 <b>Note:</b> With the <b>Pro</b> plan, you can specify any location you’re interested in and search for people in a convenient area! This is a great way to expand your connections and meet people from specific regions. 🌎

# ➡️ Please press the button below to share your location.
# """
#         await state.set_state(RegState.location)
#         await callback_query.bot.delete_message(callback_query.from_user.id, callback_query.message.message_id)
#         msg= await callback_query.bot.send_message(callback_query.from_user.id, txt, reply_markup=keyboard)
#         data = await state.get_data()
#         data['idmsg_local']=msg.message_id
#         await state.update_data(data)

# # ++++++++++++++++ LOCATION +++++++++++++++

# @router.message(RegState.location, lambda message: message.content_type == ContentType.LOCATION)
# async def set_location(message: types.Message, user: User, state: FSMContext, lang: str):
    
#     if user:
#         user.location = f"{message.location.latitude},{message.location.longitude}"
#         await user.save()
#         if lang == "ru":
#             txt = """<b>Локация указана! ✅</b>
# Отлично, теперь расскажи немного о себе. 🌟

# ➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
# """
#         else:
#             txt = """<b>Location saved! ✅</b>
# Great, now tell us a bit about yourself. 🌟

# ➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
# """
#         await state.set_state(RegState.about)
#         data = await state.get_data()
#         if "idmsg_local" in data: 
#             await message.bot.delete_message(message.from_user.id, data["idmsg_local"])
#         data["idmsg_local"]=''
#         await state.update_data(data)
#         await message.bot.delete_message(message.from_user.id, message.message_id)
#         await message.bot.send_message(message.from_user.id, txt)

# # ++++++++++++++++ ABOUT +++++++++++++++

# @router.message(RegState.about)
# async def set_about(message: types.Message, user: User, state: FSMContext, lang: str):
#     global BAD_WORDS
#     if user:
#         if message.text:
#             if message.text not in BAD_WORDS:
#                 user.about = message.text
#                 await user.save()
                
#                 await state.set_state(RegState.hobbies)
#             # Увлечения на двух языках с номерами
#                 interests = [
#                     (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
#                     (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
#                     (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
#                     (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
#                     (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
#                 ]
#                 inlinekeyboard = []
#                 row = []

#                 # Формируем кнопки для увлечений, по 3 в ряд
#                 for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
#                     row.append(InlineKeyboardButton(
#                         text=interest_ru if lang == "ru" else interest_en,
#                         callback_data=f"intrs_{number}"
#                     ))
#                     # Если добавлено 3 кнопки или это последняя кнопка в списке
#                     if len(row) == 2 or i == len(interests[:10]):
#                         inlinekeyboard.append(row)
#                         row = []  # Сбрасываем строку для следующего ряда

#                 # Добавляем стрелки навигации в последнюю строку
#                 inlinekeyboard.append([
#                     InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
#                     InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
#                 ])

#                 keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
                
#                 if lang == "ru":
#                     txt = """<b>Записали ✅</b>
#     Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟

#    ➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
#         """
#                 else:
#                     txt = """<b>Saved ✅</b>
#     Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
#     """


#                 await message.answer(txt, reply_markup=keyboard)
                
#             else:
#                 if lang == "ru":
#                     txt = """❌ <b>Ошибка:</b> Описание содержит запрещенные слова. Пожалуйста, введите другое описание и попробуйте снова. ✍️"""
#                 else:
#                     txt = """❌ <b>Error:</b> The description contains prohibited words. Please enter another description and try again. ✍️"""
#                 await message.answer(txt)
#                 await state.set_state(RegState.about)
#         else:
#                 if lang == "ru":
#                     txt = """❌ <b>Ошибка:</b> Описание долджно содержать текст ✍️"""
#                 else:
                    
#                     txt = """❌ <b>Error:</b> The description must contain text. Please write something ✍️"""
#                 await message.answer(txt)
#                 await state.set_state(RegState.about)

# # ++++++++++++++++ HOBBIES +++++++++++++++

# @router.callback_query(lambda c: "intrs_" in c.data or c.data.startswith("intrs_page") or c.data == "intrs_done", RegState.hobbies)
# async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     # Загружаем список интересов
#     interests = [
#         (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
#         (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
#         (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
#         (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
#         (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
#         (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
#         (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
#         (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
#         (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
#         (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
#         (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
#         (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
#         (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
#         (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
#         (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
#         (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
#         (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
#         (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
#         (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
#         (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
#     ]

#     # Обработка страниц
#     state_data = await state.get_data()
#     current_page = state_data.get("current_page", 1)
#     hobbies = state_data.get("selected_hobbies", [])

#     if callback_query.data.startswith("intrs_page"):
#         if "next" in callback_query.data:
#             current_page += 1
#         elif "back" in callback_query.data:
#             current_page -= 1
#         await state.update_data(current_page=current_page)

#     elif callback_query.data.startswith("intrs_") and callback_query.data != "intrs_done":
#         interest = callback_query.data.split("_")[1]
#         if interest in hobbies:
#             hobbies.remove(interest)
#         else:
#             if len(hobbies) < 5:
#                 hobbies.append(interest)
#             else:
#                 txt1 = "Выбрано максимальное количество! Уберите один интерес или нажмите 'Сохранить'." if lang == "ru" else "Maximum number selected! Remove one interest or click 'Save'."
#                 await callback_query.answer(
#                     txt1,
#                     show_alert=True
#                 )
#                 return
#         await state.update_data(selected_hobbies=hobbies)

#     elif callback_query.data == "intrs_done":
#         if len(hobbies) < 5:
#             txt2 = "Вы должны выбрать минимум 5 интересов, чтобы продолжить!" if lang == "ru" else "You must select at least 5 interests to continue!"
#             await callback_query.answer(
#                 txt2,
#                 show_alert=True
#             )
#             return
#         else:
#             user.hobbies = hobbies  # Сохраняем в базу данных только при завершении
#             await user.save()

#             txt3 = "Интересы сохранены! ✅" if lang == "ru" else "Interests saved! ✅"
#             await callback_query.answer(txt3, show_alert=True)

#             txt = """🎉 <b>Отлично!</b> Ваши хобби успешно сохранены.  

# Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
# Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """🎉 <b>Great!</b> Your hobbies have been successfully saved.  

# Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
# Or press "Skip" to continue. ⏩"""

#             keyboard = InlineKeyboardMarkup(inline_keyboard=[
#                 [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
#             ])

#             await callback_query.message.edit_text(txt, reply_markup=keyboard)
#             await state.set_state(RegState.media)
#             return

#     # Генерация кнопок для текущей страницы
#     page_size = 10
#     start_index = (current_page - 1) * page_size
#     end_index = start_index + page_size
#     inlinekeyboard = []
#     row = []

#     for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
#         text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
#         row.append(InlineKeyboardButton(
#             text=text,
#             callback_data=f"intrs_{number}"
#         ))
#         if len(row) == 2 or i == len(interests[start_index:end_index]):
#             inlinekeyboard.append(row)
#             row = []

#     navigation_buttons = []
#     if current_page > 1:
#         navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
#     if end_index < len(interests):
#         navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
#     if navigation_buttons:
#         inlinekeyboard.append(navigation_buttons)

#     if len(hobbies) == 5:
#         inlinekeyboard.append(
#             [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
#         )

#     keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
#     txt = (f"<b>Выбрано {len(hobbies)}/5 увлечений ✅</b>\n" if lang == "ru" else f"<b>Selected {len(hobbies)}/5 hobbies ✅</b>\n")
#     txt += "Отлично, выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми 'Сохранить'." if lang == "ru" else "Great, select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click 'Save'."

#     await callback_query.message.edit_text(txt, reply_markup=keyboard)


        

            [FILE] chat.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/chat.py ---


            [FILE] search.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/search.py ---


# import ssl
# import certifi
# from geopy.geocoders import Nominatim

# def get_location_by_coordinates(latitude, longitude):
#     geolocator = Nominatim(
#         user_agent="my_geopy_app",
#         timeout=10,
#         ssl_context=ssl.create_default_context(cafile=certifi.where())
#     )
#     try:
#         location = geolocator.reverse((latitude, longitude), exactly_one=True)
#         if location:
#             address = location.raw.get('address', {})
#             city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
#             return city or location.address
#         else:
#             return "Местоположение не найдено"
#     except Exception as e:
#         return f"Ошибка при определении местоположения: {e}"
    

# @router.message(Command("myprofile"))
# async def my_profile_handler(message: types.Message,state: FSMContext):
#     user = await User.get_or_none(user_id=message.from_user.id)

#     if not user:
#         lang = "ru"
#         await message.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
#         return

#     lang = user.lang if user.lang in ["ru", "en"] else "ru"
#     hobbies_text = ", ".join([
#         (interest[1] if lang == "ru" else interest[2])
#         for interest in INTERESTS
#         if str(interest[0]) in (user.hobbies or [])
#     ])

#     location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
#     if "," in location_text:
#         latitude, longitude = map(float, location_text.split(","))
#         location_text = get_location_by_coordinates(latitude, longitude)

#     subscription_text = (
#         f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
#     )
#     if user.subscription != "Free":
#         subscription_text += (
#             f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
#         )

#     description = (
#         f"<b>{user.name}</b> \n"
#         f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
#         f"{GENDER[lang][user.gender]}\n"
#         f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
#         f"{location_text}\n"

#         f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
#         f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
#         f"_________________________\n{user.about or ''}\n"
#     )



#     media = user.medias or []
#     if len(media) == 1:
#         media_file = media[0]['file_id']
#         if media[0]['type'] == 'photo':
#             msg= await message.bot.send_photo(message.from_user.id, media_file, caption=description)
#         elif media[0]['type'] == 'video':
#             msg= await message.bot.send_video(message.from_user.id, media_file, caption=description)
#     else:
#         files=[]
#         i =0
#         for media_file in media:
            
#             caption=description if i == 0 else None
            
#             if media_file["type"] =="video":
#                 files.append(InputMediaVideo(media=f"{media_file['file_id']}", caption=caption))
#                 i = i+1
#             elif media_file['type'] == 'photo':
#                 files.append(InputMediaPhoto(media=f"{media_file['file_id']}", caption=caption))
#                 i = i+1
#             else:
#                 continue
                 

#     # Отправка медиа-группы
#         msg= await message.bot.send_media_group(chat_id=message.from_user.id, media=files)
#         data= await state.get_data()
#         data["id_card_profile"]=None
#         await state.update_data(data=data)
    
    

   
        
    


            [FILE] serch.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/serch.py ---
from aiogram import Router, types, F
from aiogram.types import (
    ReplyKeyboardMarkup,
    KeyboardButton,
    InputMediaPhoto,
    InputMediaVideo,
    ReplyKeyboardRemove
)
from aiogram.fsm.context import FSMContext

import math
import ssl
import certifi
from geopy.geocoders import Nominatim
from tortoise.expressions import Q

from src.models import User as Userdb, Like, Block
from src.utils.state import SearchPeople

router = Router()

# -----------------------------
# Словари переводов
# -----------------------------
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), 
    (60, "Языковой обмен", "Language Exchange"),
]

PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {"fem": "👩 Женский", "mal": "👨 Мужской", "oth": "🌈 Другое"},
    "en": {"fem": "👩 Female", "mal": "👨 Male", "oth": "🌈 Other"}
}

WHO = {
    "ru": {"fem": "👩 Девушки", "mal": "👨 Парни", "all": "🌍 Все"},
    "en": {"fem": "👩 fem", "mal": "👨 mal", "all": "🌍 Everyone"}
}

ORI = {
    "ru": {
        "hetero": "❤️ Гетеро",
        "gay": "🌈 Гей",
        "bi": "💛 Би",
        "lesbian": "💖 Лесби",
        "gay_lesbian": "🌈 Гей/Лесби",
        "oth": "💫 Другая",
        "skip": "Не указана"
    },
    "en": {
        "hetero": "❤️ Hetero",
        "gay": "🌈 Gay",
        "bi": "💛 Bi",
        "lesbian": "💖 Lesbian",
        "gay_lesbian": "🌈 Gay/Lesbian",
        "oth": "💫 Other",
        "skip": "Not specified"
    }
}

# -----------------------------
# Вспомогательные функции
# -----------------------------
@router.message(F.text.in_(["❤️ Лайк", "💖 Суперлайк", "👎🏻 Дизлайк", "🚫 Заблокировать", "❗ Пожаловаться", "⏹ Остановить поиск",
                             "❤️ Like", "💖 Superlike", "👎🏻 Dislike", "🚫 Block", "❗ Report", "⏹ Stop Search"]))
async def handle_reaction(message: types.Message, state: FSMContext):
    user = await Userdb.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer("Профиль не найден.")
        return

    reaction = message.text
    if reaction in ["⏹ Остановить поиск", "⏹ Stop Search"]:
        await state.clear()
        await message.answer("Поиск остановлен.", reply_markup=ReplyKeyboardRemove())
        return

    data = await state.get_data()
    current_candidate_id = data.get("current_candidate_id")
    if not current_candidate_id:
        await message.answer("Нет текущей анкеты для оценки. Попробуйте начать поиск заново.")
        return

    candidate = await Userdb.get_or_none(user_id=current_candidate_id)
    if not candidate:
        await message.answer("Ошибка: кандидат не найден.")
        return

    if reaction in ["❤️ Лайк", "❤️ Like"]:
        await Like.create(from_user=user, to_user=candidate, is_superlike=False)
        # Если у пользователя Free-подписка, уведомляем, что для просмотра полного профиля необходимо оформить подписку.
        if user.subscription.lower() == "free":
            await message.answer("Вы получили лайк! Чтобы увидеть подробности профиля кандидата, необходимо приобрести подписку.")
            # Здесь можно добавить дополнительную логику для перенаправления на страницу покупки подписки.
        else:
            await message.answer("Вы поставили лайк!")
    elif reaction in ["💖 Суперлайк", "💖 Superlike"]:
        if user.subscription.lower() != "free":
            await Like.create(from_user=user, to_user=candidate, is_superlike=True)
            await message.answer("Вы поставили суперлайк!")
        else:
            await message.answer("Суперлайк доступен только при платной подписке.")
    elif reaction in ["👎🏻 Дизлайк", "👎🏻 Dislike"]:
        await message.answer("Вы дизлайкнули кандидата.")
    elif reaction in ["🚫 Заблокировать", "🚫 Block"]:
        await Block.create(from_user=user, to_user=candidate, can_message=False)
        await message.answer("Кандидат заблокирован.")
    elif reaction in ["❗ Пожаловаться", "❗ Report"]:
        # Здесь можно добавить логику обработки жалобы.
        await message.answer("Вы отправили жалобу.")
    else:
        await message.answer("Неверная команда.")

    # После обработки реакции, если реакция не связана с остановкой поиска, показываем следующего кандидата.
    await start_search(user, state, message.bot)

# -----------------------------
# Хендлер для кнопки "Начать поиск"
# -----------------------------
@router.message(F.text.in_(["🚀 Начать поиск", "🚀 Start Search"]))
async def handle_search_start(message: types.Message, state: FSMContext):
    user = await Userdb.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer(
            "<b>Профиль не найден.</b> Пожалуйста, зарегистрируйтесь с помощью команды /start."
        )
        return

    lang = user.lang or ("ru" if message.from_user.language_code == "ru" else "en")
    await state.set_state(SearchPeople.search)
    await message.answer(
        "🔎 Поиск начался! Ожидайте…" if lang == "ru" else "🔎 The search has begun! Please wait…"
    )
    await start_search(user, state, message.bot)


            [FILE] SET FOREIGN_KEY_CHECKS = 0; -- Отключаем.sql

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/SET FOREIGN_KEY_CHECKS = 0; -- Отключаем.sql ---
SET FOREIGN_KEY_CHECKS = 0; -- Отключаем проверку внешних ключей

DROP TABLE IF EXISTS `users`;
DROP TABLE IF EXISTS `likes`;
DROP TABLE IF EXISTS `blocks`;
DROP TABLE IF EXISTS `statements`;
DROP TABLE IF EXISTS `aerich`; -- Если используется Aerich

SET FOREIGN_KEY_CHECKS = 1

    [DIR] data
        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/data/__init__.py ---


[FILE] project_structure_and_code.txt

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/project_structure_and_code.txt ---
Структура проекта и содержимое файлов:

[DIR] migrations
    [DIR] models
        [DIR] __pycache__
            [FILE] 0_20250119163110_init.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/migrations/models/__pycache__/0_20250119163110_init.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] 0_20250119163110_init.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/migrations/models/0_20250119163110_init.py ---
from tortoise import BaseDBAsyncClient


async def upgrade(db: BaseDBAsyncClient) -> str:
    return """
        CREATE TABLE IF NOT EXISTS `users` (
    `user_id` BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `uid_code` VARCHAR(50) NOT NULL UNIQUE,
    `status_block` VARCHAR(255) NOT NULL  DEFAULT 'Active',
    `name` VARCHAR(50),
    `age` INT,
    `orientation` VARCHAR(255),
    `gender` VARCHAR(10),
    `medias` JSON,
    `about` LONGTEXT,
    `location` VARCHAR(255),
    `preferences` VARCHAR(255),
    `hobbies` JSON,
    `for_whom` VARCHAR(255),
    `subscription` VARCHAR(50) NOT NULL  DEFAULT 'Free',
    `localstatus` VARCHAR(50) NOT NULL  DEFAULT 'active',
    `subscription_start` DATETIME(6),
    `subscription_end` DATETIME(6),
    `referral_uid` VARCHAR(50)  UNIQUE,
    `balance` DECIMAL(10,2) NOT NULL  DEFAULT 0,
    `level` DECIMAL(5,2) NOT NULL  DEFAULT 0,
    `date_registered` DATETIME(6) NOT NULL  DEFAULT CURRENT_TIMESTAMP(6),
    `lang` VARCHAR(50) NOT NULL  DEFAULT 'nochoise'
) CHARACTER SET utf8mb4;
CREATE TABLE IF NOT EXISTS `blocks` (
    `block_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `can_message` BOOL NOT NULL  DEFAULT 0,
    `created_at` DATETIME(6) NOT NULL  DEFAULT CURRENT_TIMESTAMP(6),
    `from_user_id` BIGINT NOT NULL,
    `to_user_id` BIGINT NOT NULL,
    CONSTRAINT `fk_blocks_users_f69e9486` FOREIGN KEY (`from_user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_blocks_users_041aac48` FOREIGN KEY (`to_user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE
) CHARACTER SET utf8mb4;
CREATE TABLE IF NOT EXISTS `likes` (
    `like_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `is_superlike` BOOL NOT NULL  DEFAULT 0,
    `message` LONGTEXT,
    `created_at` DATETIME(6) NOT NULL  DEFAULT CURRENT_TIMESTAMP(6),
    `from_user_id` BIGINT NOT NULL,
    `to_user_id` BIGINT NOT NULL,
    CONSTRAINT `fk_likes_users_0e2e7347` FOREIGN KEY (`from_user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_likes_users_5172e914` FOREIGN KEY (`to_user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE
) CHARACTER SET utf8mb4;
CREATE TABLE IF NOT EXISTS `statements` (
    `statement_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `referral_count` INT NOT NULL  DEFAULT 0,
    `subscription_level` VARCHAR(20) NOT NULL  DEFAULT 'basic',
    `price` DECIMAL(10,2) NOT NULL  DEFAULT 0,
    `referral_percentage` DECIMAL(5,2) NOT NULL  DEFAULT 0,
    `payment_method` VARCHAR(50),
    `transaction_id` VARCHAR(255),
    `status` VARCHAR(20) NOT NULL  DEFAULT 'pending',
    `created_at` DATETIME(6) NOT NULL  DEFAULT CURRENT_TIMESTAMP(6),
    `user_id` BIGINT NOT NULL,
    CONSTRAINT `fk_statemen_users_32a21656` FOREIGN KEY (`user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE
) CHARACTER SET utf8mb4;
CREATE TABLE IF NOT EXISTS `aerich` (
    `id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `version` VARCHAR(255) NOT NULL,
    `app` VARCHAR(100) NOT NULL,
    `content` JSON NOT NULL
) CHARACTER SET utf8mb4;"""


async def downgrade(db: BaseDBAsyncClient) -> str:
    return """
        """


[FILE] config.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/config.py ---
BOT_TOKEN = "6137952629:AAENt0V0fK9pwDNo2NRxP4_GiiLNdXqKtHk"


TORTOISE_ORM = {
    "connections": {
        # Использование вашего IPv6-адреса и учетных данных
        "default": "mysql://maxemidate:id!125678!@platina.pro:3306/emidate_db"
    },
    "apps": {
        "models": {
            "models": ["src.models", "aerich.models"],  # Пути к вашим моделям
            "default_connection": "default",
        },
    },
}


# aerich init -t config.TORTOISE_ORM
# aerich init-db

[FILE] requirements.txt

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/requirements.txt ---
aiogram>=3.0
tortoise-orm
aiomysql


[DIR] .pytest_cache
    [FILE] CACHEDIR.TAG

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/CACHEDIR.TAG ---
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html


    [FILE] README.md

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/README.md ---
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


    [FILE] .gitignore

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/.gitignore ---
# Created by pytest automatically.
*


    [DIR] v
        [DIR] cache
            [FILE] nodeids

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/v/cache/nodeids ---
[
  "reg_test.py::test_block_command",
  "reg_test.py::test_callback_handler_lang_selection",
  "reg_test.py::test_choise_lang",
  "reg_test.py::test_choise_lang_ru",
  "reg_test.py::test_del_command",
  "reg_test.py::test_handle_message_age_prompt",
  "reg_test.py::test_handle_message_for_whom_prompt",
  "reg_test.py::test_handle_message_gender_prompt",
  "reg_test.py::test_handle_message_name_prompt",
  "reg_test.py::test_handle_message_orientation_prompt",
  "reg_test.py::test_handle_message_preferences_prompt",
  "reg_test.py::test_start_handler_new_user",
  "reg_test.py::test_start_handler_user_all_filled_till_media",
  "reg_test.py::test_start_handler_user_no_gender",
  "reg_test.py::test_start_handler_user_no_name",
  "reg_test.py::test_start_handler_user_no_orientation"
]

            [FILE] lastfailed

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/v/cache/lastfailed ---
{
  "reg_test.py::test_handle_message_name_prompt": true,
  "reg_test.py::test_handle_message_gender_prompt": true,
  "reg_test.py::test_handle_message_orientation_prompt": true,
  "reg_test.py::test_handle_message_for_whom_prompt": true,
  "reg_test.py::test_handle_message_age_prompt": true,
  "reg_test.py::test_handle_message_preferences_prompt": true,
  "reg_test.py::test_choise_lang": true,
  "reg_test.py::test_start_handler_new_user": true,
  "reg_test.py::test_start_handler_user_no_name": true,
  "reg_test.py::test_start_handler_user_no_gender": true,
  "reg_test.py::test_start_handler_user_no_orientation": true,
  "reg_test.py::test_start_handler_user_all_filled_till_media": true,
  "reg_test.py::test_block_command": true,
  "reg_test.py::test_del_command": true,
  "reg_test.py::test_choise_lang_ru": true,
  "reg_test.py::test_callback_handler_lang_selection": true
}

            [FILE] stepwise

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.pytest_cache/v/cache/stepwise ---
[]

[FILE] pyproject.toml

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/pyproject.toml ---
[tool.aerich]
tortoise_orm = "config.TORTOISE_ORM"
location = "./migrations"
src_folder = "./."


[FILE] reg_test.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/reg_test.py ---
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext

# Импортируем ваши хендлеры и состояния
from src.bot.handlers.registration import (
    handle_message,
    choise_lang,
    callback_handler
)

# Импортируем ваше состояние
from src.utils.state import RegState
# Импортируем модель User (или же мокируем её внутри теста)
from src.models import User


@pytest.mark.asyncio
async def test_start_handler_new_user(mocker):
    """
    Тестируем ситуацию, когда пользователь впервые нажимает /start
    и в БД ещё нет записи о нём (user=None).
    """
    # Мокаем объект message
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/start"
    # Мокаем метод answer (будет вызван при отправке сообщения)
    message.answer = AsyncMock()
    
    # Мокаем FSMContext
    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()
    
    # Переопределим lang и user, user_none (как в ваших аргументах)
    # Допустим, user=None, user_none=True
    user = None
    user_none = True
    lang = "ru"

    # Вызываем тестируемую функцию
    await handle_message(message=message, state=state, lang=lang, user=user, user_none=user_none)

    # Проверяем, что state.set_state НЕ вызван,
    # так как в вашем коде нет явной логики, если user=None (и стоит user_none=True),
    # но вы можете добавить проверку в код или в тестах.
    state.set_state.assert_not_awaited()

    # Проверяем, что было отправлено какое-то приветственное сообщение или нет
    # (зависит от вашей логики). Предположим, что при user=None ничего не происходит —
    # тогда проверяем, что message.answer тоже не вызывается:
    message.answer.assert_not_awaited()
    

@pytest.mark.asyncio
async def test_start_handler_user_no_name(mocker):
    """
    Тестируем ситуацию, когда в БД есть user, но у него нет имени (user.name = None).
    По коду вы проверяете: если user.name is None -> спросить имя
    """
    # Мокаем message
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/start"
    message.answer = AsyncMock()

    # Мокаем FSMContext
    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()

    # Создаём тестового user (мок)
    user = MagicMock(spec=User)
    user.name = None
    user.gender = None
    user.orientation = None
    user.for_whom = None
    user.age = None
    user.preferences = None
    user.location = None
    user.about = None
    user.hobbies = None
    user.medias = None

    # Вызываем хендлер
    await handle_message(message=message, state=state, lang="ru", user=user, user_none=False)

    # Проверяем, что мы установили состояние на RegState.name
    state.set_state.assert_awaited_once_with(RegState.name)
    
    # Проверяем, что отправили сообщение с инструкцией указать имя
    message.answer.assert_awaited_once()
    args, kwargs = message.answer.call_args
    # Можем дополнительно проверить текст:
    assert "Укажи свое имя" in args[0]  # если lang="ru"


@pytest.mark.asyncio
async def test_start_handler_user_no_gender(mocker):
    """
    Тестируем ситуацию, когда у user есть имя, но не указан пол
    (user.gender = None).
    """
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/start"
    message.answer = AsyncMock()

    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()

    # Допустим, имя есть
    user = MagicMock(spec=User)
    user.name = "Тест"
    user.gender = None
    user.orientation = None
    user.for_whom = None
    user.age = None
    user.preferences = None
    user.location = None
    user.about = None
    user.hobbies = None
    user.medias = None

    await handle_message(message=message, state=state, lang="ru", user=user, user_none=False)

    state.set_state.assert_awaited_once_with(RegState.gender)
    message.answer.assert_awaited_once()
    args, kwargs = message.answer.call_args
    # Проверяем текст
    assert "имя указано! ✅" in args[0]
    assert "укажи свой пол" in args[0]


@pytest.mark.asyncio
async def test_start_handler_user_no_orientation(mocker):
    """
    Тестируем ситуацию, когда user.name и user.gender есть,
    но orientation=None
    """
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.answer = AsyncMock()

    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()

    user = MagicMock(spec=User)
    user.name = "Тест"
    user.gender = "mal"
    user.orientation = None
    user.for_whom = None
    user.age = None

    await handle_message(message=message, state=state, lang="ru", user=user, user_none=False)

    state.set_state.assert_awaited_once_with(RegState.orientation)
    message.answer.assert_awaited_once()
    args, kwargs = message.answer.call_args
    assert "Теперь укажи свою ориентацию" in args[0]


@pytest.mark.asyncio
async def test_start_handler_user_all_filled_till_media(mocker):
    """
    Предположим, что у пользователя заполнено всё до момента,
    когда нужно отправить медиа (user.medias=None).
    Проверяем, что мы переходим на состояние RegState.media.
    """
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.answer = AsyncMock()
    # В коде на этом этапе вызывается message.bot.send_message для медиа,
    # Поэтому замокаем и его:
    message.bot.send_message = AsyncMock()

    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()
    state.get_data = AsyncMock(return_value={})
    state.update_data = AsyncMock()

    user = MagicMock(spec=User)
    user.name = "Тест"
    user.gender = "mal"
    user.orientation = "hetero"
    user.for_whom = "girls"
    user.age = 30
    user.preferences = "romance"
    user.location = "SomeLocation"
    user.about = "Текст о себе"
    user.hobbies = ["1", "2", "3", "4", "5"]  # типа уже 5 увлечений
    user.medias = None  # нет медиа

    await handle_message(message=message, state=state, lang="ru", user=user, user_none=False)

    # Должно установиться состояние media
    state.set_state.assert_awaited_once_with(RegState.media)

    # Проверяем, что бот отправил сообщение с предложением выслать медиа
    message.bot.send_message.assert_awaited_once()
    args, kwargs = message.bot.send_message.call_args
    assert "Теперь отправьте от <b>1 до 3 медиа</b>" in args[1]


@pytest.mark.asyncio
async def test_block_command(mocker):
    """
    Тестируем команду /block.
    """
    from src.bot.handlers.registration import handle_message as block_handler

    # Мокаем message
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/block"

    # Создадим мок для User.get_or_none
    async def mock_get_or_none(user_id):
        mock_user = MagicMock(spec=User)
        mock_user.status_block = None
        async def mock_save():
            pass
        mock_user.save = mock_save
        return mock_user

    with patch("src.handlers.main_handlers.User.get_or_none", side_effect=mock_get_or_none):
        await block_handler(message=message, user=None, user_none=False)
    
    # Проверяем, что у найденного пользователя проставился status_block = "Deactive"
    # В нашем mock_get_or_none мы возвращаем mock_user, у которого изначально status_block = None.
    # После вызова команды /block должно стать "Deactive".
    # Также вызывается mock_user.save().
    # Мы можем проверить это так:
    # Но придётся чуть усложнить реализацию с учётом patch-а.
    # Проще проверить внутри mock-а:

    # Или проверка через spy:
    # (Если используете pytest-mock, можно использовать mocker.spy и т.д.)
    

@pytest.mark.asyncio
async def test_del_command(mocker):
    """
    Тестируем команду /del, которая обнуляет user.medias.
    """
    from src.bot.handlers.registration import handle_message as del_handler


    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.text = "/del"

    async def mock_get_or_none(user_id):
        mock_user = MagicMock(spec=User)
        mock_user.medias = ["some_media"]
        async def mock_save():
            pass
        mock_user.save = mock_save
        return mock_user

    state = MagicMock(spec=FSMContext)

    with patch("src.handlers.main_handlers.User.get_or_none", side_effect=mock_get_or_none):
        await del_handler(message=message, state=state, user=None, user_none=False)

    # Здесь проверяем, что medias = None
    # Аналогично предыдущему тесту.
    

@pytest.mark.asyncio
async def test_choise_lang_ru(mocker):
    """
    Тестируем функцию choise_lang, которая отправляет кнопки выбора языка.
    """
    message = MagicMock(spec=Message)
    message.from_user.id = 12345678
    message.answer = AsyncMock()
    
    # Проверяем, что при lang['lang']="ru" отсылается русский текст
    await choise_lang(message=message, lang={"lang": "ru"})
    message.answer.assert_awaited_once()
    args, kwargs = message.answer.call_args
    assert "Привет!" in args[0]
    assert "🇷🇺 Русский" in str(kwargs["reply_markup"])  # проверяем, что есть кнопка русского языка
    

@pytest.mark.asyncio
async def test_callback_handler_lang_selection(mocker):
    """
    Тестируем callback_handler, когда приходит выбор языка.
    """
    callback_query = MagicMock(spec=CallbackQuery)
    callback_query.data = "lang_ru"
    callback_query.from_user.id = 12345678
    callback_query.message.message_id = 98765
    callback_query.bot.edit_message_text = AsyncMock()

    state = MagicMock(spec=FSMContext)
    state.set_state = AsyncMock()

    # Мокаем базу
    async def mock_user_get_or_none(user_id):
        mock_user = MagicMock(spec=User)
        mock_user.lang = None
        async def mock_save():
            pass
        mock_user.save = mock_save
        mock_user.name = None
        return mock_user

    with patch("src.handlers.main_handlers.User.get_or_none", side_effect=mock_user_get_or_none), \
         patch("src.handlers.main_handlers.User.save", new_callable=AsyncMock):
        await callback_handler(callback_query=callback_query, state=state, lang="ru")

    # Проверяем, что edit_message_text вызвался с нужным текстом
    callback_query.bot.edit_message_text.assert_awaited_once()
    args, kwargs = callback_query.bot.edit_message_text.call_args
    assert "Нажми /start, чтобы быстрее найти интересных людей" in args[0]

    # Проверяем, что у пользователя выставился lang="ru" и user.save() был вызван
    # (в нашем patch-е в mock_user_get_or_none мы создали mock_user)
    # Можно также проверить через spy, но в данном упрощённом варианте —
    # главное, что исключений нет и вызов edit_message_text корректен.


[FILE] checkk.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/checkk.py ---
import os

def scan_directory_and_save_code(directory, output_file="project_structure_and_code.txt", depth=0):
    """Сканирует директорию, записывает структуру и содержимое файлов в указанный файл."""
    indent = ' ' * (depth * 4)
    try:
        for item in os.listdir(directory):
            path = os.path.join(directory, item)
            if os.path.isdir(path):
                with open(output_file, 'a', encoding='utf-8') as f:
                    f.write(f"{indent}[DIR] {item}\n")
                scan_directory_and_save_code(path, output_file, depth + 1)
            else:
                with open(output_file, 'a', encoding='utf-8') as f:
                    f.write(f"{indent}[FILE] {item}\n")
                save_file_content(path, output_file)
    except Exception as e:
        with open(output_file, 'a', encoding='utf-8') as f:
            f.write(f"{indent}Ошибка доступа к {directory}: {e}\n")

def save_file_content(file_path, output_file):
    """Сохраняет содержимое файла в указанный файл."""
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()
        with open(output_file, 'a', encoding='utf-8') as f:
            f.write(f"\n--- Содержимое файла: {file_path} ---\n")
            f.write(content)
            f.write("\n\n")
    except Exception as e:
        with open(output_file, 'a', encoding='utf-8') as f:
            f.write(f"Ошибка при чтении файла {file_path}: {e}\n")

if __name__ == "__main__":
    # Укажите корневую директорию проекта
    root_dir = os.getcwd()
    output_file = "project_structure_and_code.txt"

    # Очистить файл перед записью
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("Структура проекта и содержимое файлов:\n\n")

    # Сканирование директории и сохранение данных
    scan_directory_and_save_code(root_dir, output_file)

    print(f"Сканирование завершено. Результаты сохранены в {output_file}")


[FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/__init__.py ---


[DIR] __pycache__
    [FILE] config.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/__pycache__/config.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
    [FILE] reg_test.cpython-312-pytest-8.3.4.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/__pycache__/reg_test.cpython-312-pytest-8.3.4.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
[FILE] README.md

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/README.md ---
# EMI-Date Bot

This is a Telegram bot built with aiogram 3.x, designed for user matching and social interactions.

## Features:
- User registration
- Profile search and matching
- Likes and superlikes
- Chats for matches

## How to Run:
1. Install dependencies:


[DIR] dj_emi
    [FILE] config.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/config.py ---
TORTOISE_ORM = {
    "connections": {
        "default": "mysql://maxemidate:id!125678!@platina.pro:3306/emidate_db"
    },
    "apps": {
        "models": {
            "models": ["src.models", "aerich.models"],
            "default_connection": "default",
        },
    },
}


    [DIR] profile__card
        [DIR] migrations
            [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/migrations/__init__.py ---


        [FILE] models.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/models.py ---
from django.db import models

# Create your models here.


        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__init__.py ---


        [DIR] __pycache__
            [FILE] views.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/views.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] urls.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/urls.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] models.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/models.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] admin.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/admin.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] apps.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/__pycache__/apps.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] apps.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/apps.py ---
from django.apps import AppConfig


class ProfileCardConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'profile__card'


        [FILE] admin.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/admin.py ---
from django.contrib import admin

# Register your models here.


        [DIR] templates
            [DIR] profile__card
                [FILE] cards.html

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/templates/profile__card/cards.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Profile Cards</title>
    <style>
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            margin: 10px auto;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        .card img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div id="cards-container"></div>

    <script>
        async function fetchCards() {
            const response = await fetch('/profile/cards/');
            const data = await response.json();

            const container = document.getElementById('cards-container');

            data.users.forEach(user => {
                const card = document.createElement('div');
                card.classList.add('card');

                const img = user.medias.length > 0 ? `<img src="https://api.telegram.org/file/bot<YOUR_BOT_TOKEN>/${user.medias[0].file_id}" alt="${user.name}" />` : '';
                
                card.innerHTML = `
                    ${img}
                    <h3>${user.name}</h3>
                    <p>Age: ${user.age}</p>
                    <p>About: ${user.about}</p>
                `;
                container.appendChild(card);
            });
        }

        fetchCards();
    </script>
</body>
</html>


        [FILE] tests.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/tests.py ---
from django.test import TestCase

# Create your tests here.


        [FILE] urls.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/urls.py ---
from django.urls import path
from . import views

urlpatterns = [
    path('cards/', views.get_user_cards, name='user_cards'),
]

        [FILE] views.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/profile__card/views.py ---
from django.http import JsonResponse
import asyncio
from tortoise import Tortoise
from config import TORTOISE_ORM
from src.models import User

async def init_db():
    if not Tortoise._inited:
        await Tortoise.init(config=TORTOISE_ORM)
        await Tortoise.generate_schemas()

def get_user_cards(request):
    # Инициализация базы данных
    asyncio.run(init_db())

    # Получение данных
    async def fetch_users():
        current_user_id = request.GET.get('user_id')
        return await User.filter(localstatus="active").exclude(user_id=current_user_id).values(
            "name", "age", "about", "medias"
        )

    users = asyncio.run(fetch_users())

    return JsonResponse({"users": list(users)})


    [FILE] db.sqlite3
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/db.sqlite3: 'utf-8' codec can't decode byte 0x8b in position 99: invalid start byte
    [DIR] __pycache__
        [FILE] config.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/__pycache__/config.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
    [FILE] manage.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/manage.py ---
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dj_emi.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


    [DIR] dj_emi
        [FILE] asgi.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/asgi.py ---
import os
from django.core.asgi import get_asgi_application
from tortoise import Tortoise
from config import TORTOISE_ORM

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dj_emi.settings')

async def init_db():
    if not Tortoise._inited:
        await Tortoise.init(config=TORTOISE_ORM)
        await Tortoise.generate_schemas()

application = get_asgi_application()


        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__init__.py ---


        [DIR] __pycache__
            [FILE] urls.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/urls.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] settings.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/settings.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] asgi.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/asgi.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] wsgi.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/wsgi.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] settings.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/settings.py ---
# Удалите или закомментируйте:
WSGI_APPLICATION = 'dj_emi.wsgi.application'

# Добавьте:
ASGI_APPLICATION = 'dj_emi.asgi.application'

ROOT_URLCONF = 'dj_emi.urls'

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Ваши приложения:
    'profile__card',
]

        [FILE] urls.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/urls.py ---
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('profile/', include('profile__card.urls')),
]


        [FILE] wsgi.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/dj_emi/wsgi.py ---
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dj_emi.settings')

application = get_wsgi_application()


    [DIR] src
        [FILE] models.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/models.py ---
from tortoise.models import Model
from tortoise import fields



class User(Model):
    user_id = fields.BigIntField(pk=True, unique=True)  # Уникальный Telegram ID пользователя
    uid_code = fields.CharField(max_length=50, unique=True)  # Уникальный код пользователя
    status_block = fields.CharField(max_length=255, default="Active")  # Статус (например, "Active", "Blocked")
    name = fields.CharField(max_length=50, null=True)  # Имя
    age = fields.IntField(null=True)  # Возраст
    orientation = fields.CharField(max_length=255, null=True)
    gender = fields.CharField(max_length=10, null=True)  # Пол (например, "male", "female", "other")
    medias = fields.JSONField(null=True)  # Ссылки на медиа (фото/видео)
    about = fields.TextField(null=True)  # Описание "О себе"
    location = fields.CharField(max_length=255, null=True)  # Локация
    preferences = fields.CharField(max_length=255, null=True)  # Кого ищет (например, "friends", "relationship")
    hobbies = fields.JSONField(null=True)  # Список увлечений (до 5)
    for_whom = fields.CharField(max_length=255, null=True)  # Кого показывать (например, "all", "man" , 'girl')
    subscription = fields.CharField(max_length=50, default="Free") 
    localstatus = fields.CharField(max_length=50, default="active") 

     # Тариф подписки (например, "Free", "Premium")
    subscription_start = fields.DatetimeField(null=True)  # Дата начала подписки (только для платных)
    subscription_end = fields.DatetimeField(null=True)  # Дата окончания подписки
    referral_uid = fields.CharField(max_length=50, unique=True, null=True)  # Telegram ID реферера
    balance = fields.DecimalField(max_digits=10, decimal_places=2, default=0.0)  # Баланс
    level = fields.DecimalField(max_digits=5, decimal_places=2, default=0.0)  # % от реферальной программы
    date_registered = fields.DatetimeField(auto_now_add=True)  # Дата регистрации
    lang = fields.CharField(max_length=50, default="nochoise") #язык поользователя
    class Meta:
        table = "users"





class Like(Model):
    like_id = fields.IntField(pk=True)  # Уникальный ID лайка
    from_user = fields.ForeignKeyField("models.User", related_name="sent_likes")  # Кто лайкнул
    to_user = fields.ForeignKeyField("models.User", related_name="received_likes")  # Кто получил лайк
    is_superlike = fields.BooleanField(default=False)  # Это суперлайк или обычный лайк
    message = fields.TextField(null=True)  # Сообщение, если было отправлено
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата создания лайка

    class Meta:
        table = "likes"


class Block(Model):
    block_id = fields.IntField(pk=True)  # Уникальный ID блокировки
    from_user = fields.ForeignKeyField("models.User", related_name="blocked_users")  # Кто заблокировал
    to_user = fields.ForeignKeyField("models.User", related_name="blocked_by")  # Кто заблокирован
    can_message = fields.BooleanField(default=False)  # Разрешены ли сообщения
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата блокировки

    class Meta:
        table = "blocks"


class Statement(Model):
    statement_id = fields.IntField(pk=True)  # Уникальный ID записи
    user = fields.ForeignKeyField("models.User", related_name="statements")  # Пользователь
    referral_count = fields.IntField(default=0)  # Количество рефералов
    subscription_level = fields.CharField(max_length=20, default="basic")  # Уровень подписки
    price = fields.DecimalField(max_digits=10, decimal_places=2, default=0.0)  # Цена подписки/транзакции
    referral_percentage = fields.DecimalField(max_digits=5, decimal_places=2, default=0.0)  # Процент отчислений за реферал
    payment_method = fields.CharField(max_length=50, null=True)  # Метод оплаты (например, "card", "paypal")
    transaction_id = fields.CharField(max_length=255, null=True)  # Уникальный ID транзакции
    status = fields.CharField(max_length=20, default="pending")  # Статус транзакции (успешно, ошибка)
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата создания записи

    class Meta:
        table = "statements"


        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/__init__.py ---


        [DIR] utils
            [FILE] generate_uid.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/generate_uid.py ---
import random
import string

async def generate_uid_code(uids ):
    length=5
    uid=""
    while uid =="":

        """
        Генерирует уникальный код указанной длины, содержащий латинские заглавные и строчные буквы и цифры.

        :param length: Длина кода (по умолчанию 5).
        :return: Сгенерированный код.
        """
        characters = string.ascii_letters + string.digits  # Латинские буквы (верхний и нижний регистр) + цифры
        x_code=''.join(random.choices(characters, k=length))
        if x_code not in uids:
            uid = x_code
        else:
            continue
    return uid

# Пример использования



            [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__init__.py ---


            [DIR] __pycache__
                [FILE] album.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/album.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] generate_uid.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/generate_uid.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] state.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/state.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] comands.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/comands.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] add_profile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/add_profile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] middleware.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/__pycache__/middleware.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] album.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/album.py ---
from aiogram import BaseMiddleware, types
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from typing import Callable, Awaitable, Dict, Any, List, Optional
from cachetools import TTLCache
from asyncio import sleep
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType
from src.utils.comands import set_user_specific_commands


DEFAULT_LATENCY = 0.2
DEFAULT_TTL = 0.600

router = Router()
# Middleware для обработки меди-альбомов
class AlbumMiddleware(BaseMiddleware):
    def __init__(
        self,
        groupmedia_handler: Callable[[Message, List[Dict[str, str]], List[int]], Awaitable[Any]],
        latency: float = DEFAULT_LATENCY,
        ttl: float = DEFAULT_TTL,
    ) -> None:
        super().__init__()
        self.groupmedia_handler = groupmedia_handler
        self.latency = latency
        self.cache: TTLCache = TTLCache(maxsize=10_000, ttl=ttl)

    @staticmethod
    async def get_media_data(message: Message) -> Optional[Dict[str, str]]:
        if message.photo:
            return {"file_id": message.photo[-1].file_id, "type": "photo", "message_id": message.message_id}
        if message.video:
            return {"file_id": message.video.file_id, "type": "video", "message_id": message.message_id}
        return None

    async def __call__(
        self,
        handler: Callable[[types.TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: types.TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        if isinstance(event, Message) and event.media_group_id is not None:
            state: FSMContext = data.get("state")

            if not state:
                return await handler(event, data)

            current_state: Optional[State] = await state.get_state()

            # Проверяем, находится ли пользователь в состоянии RegState.media
            if current_state != "RegState:media":
                return 403

            key = event.media_group_id
            media_data = await self.get_media_data(event)

            if not media_data:
                return await handler(event, data)

            # Если альбом уже собирается, добавляем текущий файл
            if key in self.cache:
                self.cache[key]["media_data"].append(media_data)
                return None

            # Создаем новый альбом в кэше
            self.cache[key] = {
                "media_data": [media_data]
            }

            # Ждем, пока все части альбома дойдут
            await sleep(self.latency)

            # Передаем собранный альбом и message_id для удаления в groupmedia_handler
            media_data_list = self.cache.pop(key)["media_data"]
            message_ids = [media["message_id"] for media in media_data_list]
            return await self.groupmedia_handler(event, media_data_list, message_ids, state)

        return await handler(event, data)
    




# Функция для обработки одиночного медиа
@router.message(RegState.media)
async def set_media(message: types.Message, user: User, state: FSMContext, lang: str):
    if message.media_group_id is None and (message.photo or message.video):  
        # Проверяем одиночные фото/видео
        if user:
            media = user.medias or []
            if len(media) < 3:
                media_data = {
                    "file_id": message.photo[-1].file_id if message.photo else message.video.file_id,
                    "type": "photo" if message.photo else "video"
                }
                await message.bot.delete_message(message.from_user.id, message.message_id)
                media.append(media_data)
                user.medias = media
                await user.save()

                

                # Обновляем сообщение прогресса
                data = await state.get_data()
                msg_id = None
                if "idmsg_media" in data:
                    msg_id=data["idmsg_media"]
                count = len(media)
                if count ==3:
                    txt = (
                    f"Сохранено {count}/3 медиа. Нажмите 'Сохранить'." 
                    if lang == "ru" 
                    else f"Saved {count}/3 media. Click 'Save'."
                )
                else:   
                    txt = (
                        f"Сохранено {count}/3 медиа. Отправьте ещё одно или нажмите 'Сохранить'." 
                        if lang == "ru" 
                        else f"Saved {count}/3 media. Send another one or click 'Save'."
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="Сохранить ✅" if lang == "ru" else "Save ✅", callback_data="save_album")]
                ])

                if msg_id:
                    try:
                        await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
                    except:
                        sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                        await state.update_data(idmsg_media=sent_message.message_id)
                else:
                    sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                    await state.update_data(idmsg_media=sent_message.message_id)
            else:
                txt = "Вы уже отправили максимальное количество медиа! 📸" if lang == "ru" else "You have already sent the maximum amount of media! 📸"
                await message.answer(txt)

# Функция для обработки меди-альбомов
async def groupmedia(message: Message, media_data_list: List[Dict[str, str]], message_ids , state: FSMContext):
    
    chat_id = message.chat.id  # Или используйте другой chat_id, если нужно
    print(message_ids)
    # Проверяем количество файлов в базе данных
    for id in message_ids:
        await message.bot.delete_message(message.from_user.id, id)
    user = await User.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer("Ошибка: пользователь не найден.")
        return
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Сохранить ✅" if user.lang == "ru" else "Save ✅", callback_data="save_album")]
    ])
    existing_files = user.medias or []

    # Если уже есть 2 файла, добавляем только первый файл из альбома
    if len(existing_files) == 2:
        existing_files.append(media_data_list[0])
        user.medias = existing_files
        await user.save()

        # Удаляем сообщение с медиа

        # Обновляем сообщение прогресса
        txt = (
            "Сохранён только первый файл из альбома. Теперь у вас 3/3 медиа. Нажмите 'Сохранить'." 
            if user.lang == "ru" 
            else "Only the first file from the album has been saved. You now have 3/3 media. Click 'Save'."
        )
        data = await state.get_data()
        msg_id = None
        if "idmsg_media" in data:
            msg_id=data["idmsg_media"]

        if msg_id:
            try:
                await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
            except:
                sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                await state.update_data(idmsg_media=sent_message.message_id)
        else:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
        return

    # Если альбом содержит больше 3 файлов, сохраняем только первые 3
    if len(existing_files) + len(media_data_list) > 3:
        remaining_slots = 3 - len(existing_files)
        existing_files.extend(media_data_list[:remaining_slots])
        user.medias = existing_files
        await user.save()

        # Удаляем сообщение с медиа
        # await message.delete()

        # Обновляем сообщение прогресса
        txt = (
            f"Сохранены только первые {remaining_slots} файла из альбома. Теперь у вас 3/3 медиа. Нажмите 'Сохранить'."
            if user.lang == "ru" 
            else f"Only the first {remaining_slots} files from the album have been saved. You now have 3/3 media. Click 'Save'."
        )
        data = await state.get_data()
        msg_id = None
        if "idmsg_media" in data:
            msg_id=data["idmsg_media"]

        if msg_id:
            try:
                await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
            except:
                sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                await state.update_data(idmsg_media=sent_message.message_id)
        else:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
        return

    # Если всё в порядке, сохраняем весь альбом
    existing_files.extend(media_data_list)
    user.medias = existing_files
    await user.save()

    # Удаляем сообщение с медиа

    # Обновляем сообщение прогресса
    if existing_files==3:
        txt = (
        f"Сохранено {len(existing_files)}/3 медиа. Нажать 'Сохранить'."
        if user.lang == "ru" 
        else f"Saved {len(existing_files)}/3 media. Click 'Save'."
    )
    else:
        txt = (
            f"Сохранено {len(existing_files)}/3 медиа. Можете отправить ещё одно или нажать 'Сохранить'."
            if user.lang == "ru" 
            else f"Saved {len(existing_files)}/3 media. You can send another one or click 'Save'."
        )

    

    # await message.answer(txt, reply_markup=keyboard)÷
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]

    if msg_id:
        try:
            await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
        except:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)


def create_start_search_keyboard(lang: str) -> ReplyKeyboardMarkup:
    """
    Создает клавиатуру с кнопкой "Начать поиск" на русском или английском языке.

    :param lang: Язык клавиатуры ('ru' или 'en').
    :return: Объект ReplyKeyboardMarkup.
    """
    if lang == "ru":
        button_text = "🚀 Начать поиск"
    else:
        button_text = "🚀 Start Search"

    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=button_text)]
        ],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    return keyboard

@router.callback_query(lambda c: "skip_album" in c.data, RegState.media)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    # print()
    await state.set_state(RegState.done)
    media = user.medias or []
    file_id='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'
    media_data = {
                    "file_id": file_id,
                    "type": "photo" 
                }
    media.append(media_data)
    user.medias = media
    await user.save()
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]
    txt='''🎉 <b>Профиль успешно заполнен! ✅</b>  

Теперь вы готовы начать находить интересных людей! 🌟  
➡️ Используйте меню внизу и нажмите "Начать поиск", чтобы приступить.  
Удачи! 🍀''' if lang == 'ru' else '''🎉 <b>Profile successfully completed! ✅</b>  

You’re now ready to start finding interesting people! 🌟  
➡️ Use the menu below and tap "Start Search" to begin.  
Good luck! 🍀
'''

    keyboard = create_start_search_keyboard(lang)
    await set_user_specific_commands(callback_query.bot, callback_query.from_user.id, lang )

    if msg_id:
        try:
            await callback_query.bot.edit_message_text(chat_id=callback_query.from_user.id, message_id=msg_id, text=txt, reply_markup=keyboard)
        except:
            sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)


@router.callback_query(lambda c: "save_album" in c.data, RegState.media)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
    await state.set_state(RegState.done)
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]
    txt='''🎉 <b>Профиль успешно заполнен! ✅</b>  

Теперь вы готовы начать находить интересных людей! 🌟  
➡️ Используйте меню внизу и нажмите "Начать поиск", чтобы приступить.  
Удачи! 🍀''' if lang == 'ru' else '''🎉 <b>Profile successfully completed! ✅</b>  

You’re now ready to start finding interesting people! 🌟  
➡️ Use the menu below and tap "Start Search" to begin.  
Good luck! 🍀
'''

    keyboard = create_start_search_keyboard(lang)
    await set_user_specific_commands(callback_query.bot, callback_query.from_user.id, lang )
    if msg_id:
        try:
            try:
                await callback_query.message.edit_reply_markup(reply_markup=None)
                sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)

            except:
                await callback_query.message.delete()
                sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
                
                
        except:
            sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)

            [FILE] comands.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/comands.py ---
from aiogram import Bot, Dispatcher, types
from aiogram.types import BotCommand, BotCommandScopeChat
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType


router = Router()



@router.message(Command("lang"))
async def set_name(message: types.Message, state: FSMContext, lang: str):
    user = await User.get_or_none(user_id=message.from_user.id)
    if user.lang:
        if user.lang=="ru":
            lang='en'
            user.lang=lang
            await user.save()
        else:
            lang='ru'
            user.lang=lang
            await user.save()
        await set_user_specific_commands(message.bot, message.from_user.id, lang)
        if lang == "ru":
            button_text = "🚀 Начать поиск"
        else:
            button_text = "🚀 Start Search"

        keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text=button_text)]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        txt ="""Вы измменили язык ✅
        
ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль.""" if lang=='ru' else"""You have changed the language ✅

ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."""

        await message.answer(txt, reply_markup=keyboard)





async def set_user_specific_commands(bot:Bot, user_id, lang):
    # Определяем команды для пользователя
    user_specific_commands = [
        
        BotCommand(command="myprofile", description="Профиль" if lang=='ru' else "Profile"),
        BotCommand(command="help", description="Помощь"if lang=='ru' else "Help"),
        BotCommand(command="subs", description="Подписка" if lang=='ru' else "Subscription"),
        BotCommand(command="ref", description="Реф. программа" if lang=='ru' else "Ref. program"),
        BotCommand(command="lang", description="Изменить язык" if lang=='ru' else "Change language")
    ]

    # Устанавливаем команды только для указанного пользователя
    await bot.set_my_commands(
        commands=user_specific_commands,
        scope=BotCommandScopeChat(chat_id=user_id)
    )

async def delete_user_specific_commands(bot: Bot, user_id: int):
    """
    Удаляет команды, установленные для конкретного пользователя.
    """
    await bot.delete_my_commands(
        scope=BotCommandScopeChat(chat_id=user_id)
    )

            [FILE] add_profile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/add_profile.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.types import InputMediaPhoto, InputMediaVideo
from src.utils.state import RegState
from src.utils.comands import set_user_specific_commands, delete_user_specific_commands

async def add_profile(message: types.Message, state: FSMContext, lang: str, user: User):
    if user:
        # Если имя не указано
        if user.name is None:
            txt = (
                "<b>🎉</b>\nТеперь давай настроим твой профиль, чтобы ты мог(ла) быстрее найти интересных людей. 🌟\n\n➡️ Укажи свое имя, чтобы мы могли начать!"
                if lang == "ru" else
                "<b>🎉</b>\nNow let’s set up your profile so you can start meeting interesting people faster. 🌟\n\n➡️ Please provide your name to get started!"
            )
            await state.set_state(RegState.name)
            await message.answer(txt)
            return

        # Если имя указано, но пол не выбран
        if user.gender is None:
            txt = (
                f"<b>Отлично,{user.name}</b>\nТеперь укажи свой пол! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                f"<b>Great,{user.name}</b>\nNow specify your gender! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другой" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.gender)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если пол указан, но ориентация не выбрана
        if user.orientation is None:
            txt = (
                "Теперь укажи свою ориентацию! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                "Now specify your orientation! 🌟\n\n➡️ Choose one of the options:"
            )
            if user.gender == 'mal':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'fem':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'oth':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если ориентация указана, но не указаны предпочтения для просмотра
        if user.for_whom is None:
            txt = (
"Теперь укажи, кого ты хочешь видеть! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
"Now specify who you want to see! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_girls")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_boys")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_everyone")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если предпочтения для просмотра указаны, но возраст не указан
        elif user.age is None:
            txt = (
                "Теперь укажи свой возраст! 🌟\n\n➡️ Введите ваш возраст (минимум 16 лет):"
                if lang == "ru" else
                "Now specify your age! 🌟\n\n➡️ Enter your age (minimum 16 years):"
            )
            await state.set_state(RegState.age)
            await message.answer(txt)
            return
        # Если все данные собраны, переходим к следующему шагу
        if user.preferences is None:
            txt = (
                "Теперь укажи свои цели! 🌟\n\n➡️ Выбери цели из предложенных вариантов:"
                if lang == "ru" else
                "Now specify your goals! 🌟\n\n➡️ Choose your goals from the options provided:"
            )
            inline_keyboard=[]
            if lang =="ru":
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
            else:
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.preferences)
            await message.answer(txt, reply_markup=keyboard)
            return
        if user.location is None:

            keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )

            if lang == "ru":
                txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
            else:
                txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

            await state.set_state(RegState.location)
            msg = await message.bot.send_message(message.from_user.id ,text=txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)
            return
        if user.about is None:
            if lang == "ru":
                txt = """
Теперь расскажи немного о себе. 🌟

➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
"""
            else:
                txt = """
Now tell us a bit about yourself. 🌟

➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
"""
            await state.set_state(RegState.about)
            await message.bot.send_message(message.from_user.id, txt)
            return
        if user.hobbies is None:
            state_data = await state.get_data()
            current_page = state_data.get("current_page", 1)
            hobbies = state_data.get("selected_hobbies", [])  # Загружаем хобби из состояния или базы

            if len(hobbies) < 5:
                await state.set_state(RegState.hobbies)

                # Увлечения на двух языках с номерами
                interests = [
                    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
                    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
                    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
                    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
                    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
                    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
                    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
                    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
                    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
                    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
                    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
                    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
                    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
                    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
                    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
                    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
                ]
                page_size = 10
                start_index = (current_page - 1) * page_size
                end_index = start_index + page_size

                # Генерация кнопок для текущей страницы
                inlinekeyboard = []
                row = []

                for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
                    text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
                    row.append(InlineKeyboardButton(
                        text=text,
                        callback_data=f"intrs_{number}"
                    ))
                    if len(row) == 2 or i == len(interests[start_index:end_index]):
                        inlinekeyboard.append(row)
                        row = []

                # Добавляем кнопки навигации
                navigation_buttons = []
                if current_page > 1:
                    navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
                if end_index < len(interests):
                    navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
                if navigation_buttons:
                    inlinekeyboard.append(navigation_buttons)

                if len(hobbies) == 5:
                    inlinekeyboard.append(
                        [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)

                if lang == "ru":
                    if hobbies:
                        txt = f"<b>У вас уже выбрано {len(hobbies)}/5 увлечений ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми \"<b>Сохранить✅</b>\"."
                else:
                    if hobbies:
                        txt = f"<b>You have already selected {len(hobbies)}/5 hobbies ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\"."

                await state.update_data(current_page=current_page, hobbies=hobbies)  # Сохраняем данные в состояние
                await message.answer(txt, reply_markup=keyboard)
                return


        if user.medias is None:

            txt = """

Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """

Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
Or press "Skip" to continue. ⏩"""
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
            ])
            await state.set_state(RegState.media)
            data = await state.get_data()

            msg = await message.bot.send_message(chat_id=message.from_user.id, text=txt, reply_markup=keyboard)
            data["idmsg_media"] = msg.message_id
            await state.update_data(data=data)
            return
        else:
            
            if lang == "ru":
                button_text = "🚀 Начать поиск"
            else:
                button_text = "🚀 Start Search"

            keyboard = ReplyKeyboardMarkup(
                keyboard=[
                    [KeyboardButton(text=button_text)]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            )
            await set_user_specific_commands(message.bot, message.from_user.id, lang )
            response = (
        "ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль." 
        if lang == "ru" 
        else "ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."
    )
            await message.answer(response, reply_markup=keyboard)

            

            [FILE] middleware.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/middleware.py ---
import logging
from aiogram import BaseMiddleware, types
from aiogram.types import Update
from typing import Callable, Any, Awaitable
from aiogram.fsm.context import FSMContext
from src.models import User
from aiogram.types import CallbackQuery
from src.utils.generate_uid import generate_uid_code
from src.bot.handlers.registration import choise_lang


class LoggingMiddleware(BaseMiddleware):
    """
    Middleware for logging all incoming updates and outgoing responses,
    ensuring user profile completeness and language setup.
    """

    async def __call__(
        self,
        handler: Callable[[Update, dict], Awaitable[Any]],
        event: Update,
        data: dict,
    ) -> Any:
        # Логируем входящее событие
        logging.info(f"Incoming update: {event}")
        state: FSMContext
        state: FSMContext = data.get("state")  # FSMContext передается через data
        current_state = await state.get_state() if state else None
        # Получаем user_id из обновления
        user_id = event.from_user.id if event.from_user else None

        if user_id:
            # Проверяем, существует ли пользователь в базе данных
            user = await User.get_or_none(user_id=user_id)
            if user:
                if user.status_block == "Active":
                    data["user"] = user
                    
                    # Устанавливаем язык
                    if user.lang == "nochoise":
                        data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                        return await choise_lang(event, data)
                    else:
                        data["lang"] = user.lang

                    # Проверка на полноту профиля
                    
                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias
                    ]) and event.text and ("/start" not in event.text and "/del" not in event.text) and current_state is None:
                        message_text = (
                            "Кажется, ваш профиль заполнен не до конца. \u2028"
                            "Нажмите /start, чтобы заполнить профиль и скорее приступить к поиску нужных людей."
                            if user.lang == "ru" else
                            "It seems your profile is incomplete. \u2028"
                            "Press /start to complete your profile and start connecting with people."
                        )
                        if isinstance(event, types.Message):
                            await event.answer(message_text)
                        return
                else:
                    # Если пользователь заблокирован, возвращаем статус 403
                    if isinstance(event, types.Message):
                        await event.answer("Ваш аккаунт заблокирован." if user.lang == "ru" else "Your account is blocked.")
                    return 403
            else:
                # Новый пользователь
                uid_ref = None
                if event.text and "/start" in event.text:
                    parts = event.text.split(" ")
                    if len(parts) > 1:
                        uid_ref = parts[1]
                        ref_user = await User.get_or_none(uid_code=uid_ref)
                        if ref_user:
                            if ref_user.lang == "ru":
                                await event.bot.send_message(ref_user.user_id, "У вас новый реферал")
                            else:
                                await event.bot.send_message(ref_user.user_id, "You have a new referral")

                # Генерация UID
                users = await User.all().values_list("uid_code", flat=True)
                uid = await generate_uid_code(uids=users)

                # Создание нового пользователя
                user = await User.create(user_id=user_id, uid_code=uid, referral_uid=uid_ref)
                data["user"] = user
                data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                return await choise_lang(event, data)

        # Передаём управление следующему обработчику
        response = await handler(event, data)

        # Логируем ответ
        logging.info(f"Outgoing response: {response}")

        return response




class CallbackMiddleware(BaseMiddleware):
    """
    Middleware для обработки callback-запросов.
    Проверяет статус пользователя и передаёт язык пользователя.
    """

    async def __call__(
        self,
        handler: Callable[[CallbackQuery, dict], Awaitable[Any]],
        event: CallbackQuery,
        data: dict,
    ) -> Any:
        # Логируем входящее событие
        logging.info(f"Incoming callback query: {event}")

        # Получаем user_id из callback
        user_id = event.from_user.id if event.from_user else None

        if user_id:
            # Проверяем, существует ли пользователь в базе данных
            user = await User.get_or_none(user_id=user_id)
            if user:
                if user.status_block == "Active":
                    data["user"] = user
                    data["lang"] = user.lang or ("ru" if event.from_user.language_code in ["ru", "uk"] else "en")
                else:
                    # Если пользователь заблокирован, отправляем сообщение и возвращаем статус 403
                    await event.answer("Ваш аккаунт заблокирован.", show_alert=True)
                    return 403
            else:
                # Если пользователь отсутствует, предлагаем выбрать язык
                data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                if event.data == "lang_ru" or event.data == "lang_en":
                    data["lang"] = "ru" if event.data == "lang_ru" else "en"
                    return await handler(event, data)
                return await choise_lang(event.message, data)

        # Передаём управление следующему обработчику
        response = await handler(event, data)

        # Логируем ответ
        logging.info(f"Outgoing response for callback query: {response}")

        return response


            [FILE] state.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/utils/state.py ---
from aiogram.fsm.state import StatesGroup
from aiogram.fsm.state import State


class RegState(StatesGroup):

    name =State()
    age = State()
    gender = State()
    preferences = State()
    location = State()
    about = State()
    media = State()
    hobbies = State()
    show = State()
    orientation = State()
    done = State()




class SearchPeople(StatesGroup):
    search = State()
    like = State()
    superlike = State()
    dislike = State()
    block = State()
    report = State()
    stop = State()
    message = State()
    show = State()
    show_profile = State()
    show_media = State()
    show_hobbies = State()
    show_about = State()
    show_location = State()
    show_preferences = State()


class ReditState(StatesGroup):

    name =State()
    age = State()
    gender = State()
    preferences = State()
    location = State()
    about = State()
    media = State()
    hobbies = State()
    show = State()
    orientation = State()
    done = State()
 

        [DIR] __pycache__
            [FILE] models.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/__pycache__/models.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [DIR] bot
            [DIR] __pycache__
                [FILE] config.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/__pycache__/config.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [DIR] handlers
                [FILE] registration.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/registration.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.types import InputMediaPhoto, InputMediaVideo
from src.utils.state import RegState
from src.utils.generate_uid import generate_uid_code

from src.utils.comands import set_user_specific_commands, delete_user_specific_commands
import random

from aiogram.types import WebAppInfo, InlineKeyboardMarkup, InlineKeyboardButton

def get_web_app_button():
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(
                text="🔍 Найти пользователей",
                web_app=WebAppInfo(url="https://6ef0-162-213-64-84.ngrok-free.app/profile/cards/")
            )]
        ]
    )
router = Router()

@router.message(Command("search"))
async def start_search(message: types.Message):
    button = get_web_app_button()
    await message.answer("Нажмите кнопку ниже, чтобы начать поиск пользователей:", reply_markup=button)



@router.message(CommandStart())
async def handle_message1(message: types.Message, state: FSMContext, lang: str, user: User = None, user_none: bool = False):
    if user:
        # Если имя не указано
        if user.name is None:
            txt = (
                "<b>🎉</b>\nТеперь давай настроим твой профиль, чтобы ты мог(ла) быстрее найти интересных людей. 🌟\n\n➡️ Укажи свое имя, чтобы мы могли начать!"
                if lang == "ru" else
                "<b>🎉</b>\nNow let’s set up your profile so you can start meeting interesting people faster. 🌟\n\n➡️ Please provide your name to get started!"
            )
            await state.set_state(RegState.name)
            await message.answer(txt)

        # Если имя указано, но пол не выбран
        elif user.name is not None and user.gender is None:
            txt = (
                f"<b>Отлично,{user.name}</b>\nТеперь укажи свой пол! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                f"<b>Great,{user.name}</b>\nNow specify your gender! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другой" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.gender)
            await message.answer(txt, reply_markup=keyboard)

        # Если пол указан, но ориентация не выбрана
        elif user.name is not None and user.gender is not None and user.orientation is None:
            txt = (
                "Теперь укажи свою ориентацию! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                "Now specify your orientation! 🌟\n\n➡️ Choose one of the options:"
            )
            if user.gender == 'mal':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'fem':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'oth':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await message.answer(txt, reply_markup=keyboard)

        # Если ориентация указана, но не указаны предпочтения для просмотра
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is None:
            txt = (
"Теперь укажи, кого ты хочешь видеть! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
"Now specify who you want to see! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_everyone")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await message.answer(txt, reply_markup=keyboard)

        # Если предпочтения для просмотра указаны, но возраст не указан
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.age is None:
            txt = (
                "Теперь укажи свой возраст! 🌟\n\n➡️ Введите ваш возраст (минимум 16 лет):"
                if lang == "ru" else
                "Now specify your age! 🌟\n\n➡️ Enter your age (minimum 16 years):"
            )
            await state.set_state(RegState.age)
            await message.answer(txt)

        # Если все данные собраны, переходим к следующему шагу
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.age is not None and user.preferences is None:
            txt = (
                "Теперь укажи свои цели! 🌟\n\n➡️ Выбери цели из предложенных вариантов:"
                if lang == "ru" else
                "Now specify your goals! 🌟\n\n➡️ Choose your goals from the options provided:"
            )
            inline_keyboard=[]
            if lang =="ru":
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
            else:
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.preferences)
            await message.answer(txt, reply_markup=keyboard)
        elif user.name is not None and user.age is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is None:

            keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )

            if lang == "ru":
                txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
            else:
                txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

            await state.set_state(RegState.location)
            msg = await message.bot.send_message(message.from_user.id ,text=txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)

        elif user.name is not None and user.age is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is None:
            if lang == "ru":
                txt = """
Теперь расскажи немного о себе. 🌟

➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
"""
            else:
                txt = """
Now tell us a bit about yourself. 🌟

➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
"""
            await state.set_state(RegState.about)
            await message.bot.send_message(message.from_user.id, txt)
        elif user.name is not None and user.age is not None and user.gender is not None and user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is not None and user.hobbies is None:
            state_data = await state.get_data()
            current_page = state_data.get("current_page", 1)
            hobbies = state_data.get("selected_hobbies", [])  # Загружаем хобби из состояния или базы

            if len(hobbies) < 5:
                await state.set_state(RegState.hobbies)

                # Увлечения на двух языках с номерами
                interests = [
                    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
                    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
                    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
                    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
                    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
                    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
                    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
                    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
                    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
                    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
                    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
                    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
                    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
                    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
                    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
                    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
                ]
                page_size = 10
                start_index = (current_page - 1) * page_size
                end_index = start_index + page_size

                # Генерация кнопок для текущей страницы
                inlinekeyboard = []
                row = []

                for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
                    text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
                    row.append(InlineKeyboardButton(
                        text=text,
                        callback_data=f"intrs_{number}"
                    ))
                    if len(row) == 2 or i == len(interests[start_index:end_index]):
                        inlinekeyboard.append(row)
                        row = []

                # Добавляем кнопки навигации
                navigation_buttons = []
                if current_page > 1:
                    navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
                if end_index < len(interests):
                    navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
                if navigation_buttons:
                    inlinekeyboard.append(navigation_buttons)

                if len(hobbies) == 5:
                    inlinekeyboard.append(
                        [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)

                if lang == "ru":
                    if hobbies:
                        txt = f"<b>У вас уже выбрано {len(hobbies)}/5 увлечений ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми \"<b>Сохранить✅</b>\"."
                else:
                    if hobbies:
                        txt = f"<b>You have already selected {len(hobbies)}/5 hobbies ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\"."

                await state.update_data(current_page=current_page, hobbies=hobbies)  # Сохраняем данные в состояние
                await message.answer(txt, reply_markup=keyboard)


        elif user.name is not None and user.age is not None and user.gender is not None and user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is not None and user.hobbies is not None and user.medias is None:

            txt = """

Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """

Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
Or press "Skip" to continue. ⏩"""
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
            ])
            await state.set_state(RegState.media)
            data = await state.get_data()

            msg = await message.bot.send_message(chat_id=message.from_user.id, text=txt, reply_markup=keyboard)
            data["idmsg_media"] = msg.message_id
            await state.update_data(data=data)

        else:
            
            if lang == "ru":
                button_text = "🚀 Начать поиск"
            else:
                button_text = "🚀 Start Search"

            keyboard = ReplyKeyboardMarkup(
                keyboard=[
                    [KeyboardButton(text=button_text)]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            )
            await set_user_specific_commands(message.bot, message.from_user.id, lang )
            response = (
        "ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль." 
        if lang == "ru" 
        else "ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."
    )
            await message.answer(response, reply_markup=keyboard)

            
        









@router.message(Command("block"))
async def handle_message(message: types.Message, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    # if user:
    #     user.status_block="Deactive"
    #     await user.save()
    await delete_user_specific_commands(message.bot, message.from_user.id)

    

@router.message(Command("del"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    
    if user:
        await user.delete()
        # await user.save()


# Список столиц мира с их координатами
WORLD_CAPITALS = [
    ("Moscow", 55.7558, 37.6173),
    ("Washington, D.C.", 38.9072, -77.0369),
    ("London", 51.5074, -0.1278),
    ("Tokyo", 35.6895, 139.6917),
    ("Paris", 48.8566, 2.3522),
    ("Berlin", 52.5200, 13.4050),
    ("Beijing", 39.9042, 116.4074),
    ("Canberra", -35.2809, 149.1300),
    ("Ottawa", 45.4215, -75.6972),
    ("Brasília", -15.8267, -47.9218)
]
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"fem":"👩 Девушки",
    "mal":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "fem":"👩 Girls",
    "mal":"👨 Boys",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"💫Другая",
                "skip":"Не указана"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"💫Other",
                "skip":"Not specified"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}


async def generate_random_profiles():
    interests = [interest[1] for interest in INTERESTS]

    for _ in range(200):
        # Случайный выбор пола, ориентации и других параметров
        gender = random.choice(list(GENDER["en"].keys()))
        orientation = random.choice(list(ORI["en"].keys()))
        for_whom = random.choice(list(WHO["en"].keys()))
        preference = random.choice(list(PREFERENCES["en"].keys()))

        # Случайная локация
        city, latitude, longitude = random.choice(WORLD_CAPITALS)
        location = f"{latitude},{longitude}"

        # Случайные увлечения (до 5)
        hobbies = random.sample(interests, k=random.randint(1, 5))

        # Случайное имя и описание
        name = f"User{random.randint(1000, 9999)}"
        about = "I love " + ", ".join(random.sample(interests, k=2)) + "."
        media=[]
        media_data = {
                    "file_id": 'AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ',
                    "type": "photo" 
                }
        users = await User.all().values_list("uid_code", flat=True)
        uid = await generate_uid_code(uids=users)
        media.append(media_data)
        # Создание пользователя
        await User.create(
            name=name,
            age=random.randint(18, 50),
            gender=gender,
            orientation=orientation,
            for_whom=for_whom,
            preferences=preference,
            location=location,
            about=about,
            hobbies=hobbies,
            medias=None,
            uid_code=uid,
            lang='ru' # Медиаданные остаются пустыми

        )

    print("200 random profiles created successfully!")
@router.message(Command("add"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    await generate_random_profiles()
    await message.answer("200 случайных профилей успешно созданы!")

        
@router.message(Command("del1"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    
    if user:
        user.age=None
        await user.save()


async def choise_lang(message: types.Message, lang: str):
    if lang['lang']=="ru":
    
        txt="""<b>Привет! 👋</b>
На связи <b>💖Emi-Date💖</b> — твой помощник в мире знакомств для людей в эмиграции. 🌍✨

Чтобы начать, пожалуйста, выбери язык, который тебе удобен:
"""
    else:
        txt="""<b>Hi there! 👋</b>
Welcome to <b>💖Emi-Date💖</b> — your go-to bot for connecting with people in emigration. 🌍✨

To get started, please select your preferred language:
"""
    
    # Кнопки для выбора языка
    
    inline_keyboard=[]
    inline_keyboard.append([InlineKeyboardButton(text="🇷🇺 Русский", callback_data="lang_ru")])
    inline_keyboard.append([InlineKeyboardButton(text="🇺🇸 English", callback_data="lang_en")])

    keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)

    await message.answer(text=txt, reply_markup=keyboard)




@router.message(Command("album"))
async def handle_message(message: types.Message, user: User = None, user_none: bool = False):

    media_files = [
        InputMediaPhoto(media='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'),
        InputMediaPhoto(media='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'),
        # Добавьте до 10 медиафайлов
    ]

    # Отправка медиа-группы
    await message.bot.send_media_group(chat_id=message.from_user.id, media=media_files)










@router.callback_query(lambda c: "lang_" in c.data)
async def callback_handler(callback_query: CallbackQuery, state: FSMContext, lang: str):
    lang = (callback_query.data.split("_"))[1]
    user_id = callback_query.from_user.id
    user= await User.get_or_none(user_id=user_id)
    if user:
        user.lang=lang
        await user.save()
    if user.name==None:
        keyboard = None
        if lang == "ru":
            txt = """<b>Отлично! 🎉</b>
Нажми /start, чтобы быстрее найти интересных людей. 🌟

"""
        else:
            txt = """<b>Great! 🎉</b
Tap /start to quickly find interesting people. 🌟
    """
        await callback_query.bot.edit_message_text(text=txt, chat_id=user_id, message_id=callback_query.message.message_id, reply_markup=None)
        
       


  







                [FILE] likes.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/likes.py ---


                [FILE] anketa.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/anketa.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from src.utils.add_profile import add_profile
from aiogram.types import ContentType


router = Router()
BAD_WORDS = [
    # Наркотики
    "наркотик", "наркота", "косяк", "травка", "гашиш", "героин", "кокаин", "амфетамин", "экстази",
    "марихуана", "спайс", "лсд", "шишки", "опиум", "план", "кристалл", "мефедрон", "drugs", "drug",
    "weed", "marijuana", "cocaine", "heroin", "ecstasy", "meth", "amphetamine", "hash", "spice",
    "lsd", "crystal", "meph", "opium", "j0int", "dr@g", "tr@vka",

    # CP
    "детская порнография", "детское порно", "запрещенное видео", "нелегальный контент", "порнография с детьми",
    "cp", "child porn", "child pornography", "illegal content", "b@nned video", "ch!ld p0rn",

    # Оружие
    "оружие", "пистолет", "винтовка", "автомат", "пулемет", "граната", "мина", "бомба", "арсенал",
    "ружье", "ствол", "калашников", "ак-47", "глок", "гранатомет", "weapon", "gun", "pistol", "rifle",
    "machine gun", "grenade", "bomb", "landmine", "arsenal", "shotgun", "kalashnikov", "ak47",
    "glock", "rocket launcher", "we@pon", "glock-19", "b0mb",

    # Additional prohibited words
    "explosive", "tnt", "c4", "detonator", "silencer", "sniper", "assault rifle", "pipe bomb",
    "наркот", "герич", "герыч", "доза", "спайсы", "соли", "фен", "скорость",
    "запрещенка", "порно с детьми", "порево", "kill", "murder", "mass shooting", "terrorist", "attack"
]






# ++++++++++++++++ NAME +++++++++++++++

@router.message(RegState.name)
async def set_name(message: types.Message, state: FSMContext, lang: str):
    user = await User.get_or_none(user_id=message.from_user.id)
    global BAD_WORDS
    if user:
        
        if message.text not in BAD_WORDS:
            user.name = message.text.strip()
            await user.save()
            if user.gender is None:
                
                if lang == "ru":
                    txt = """<b>Имя указано! ✅</b>
    Отлично, теперь укажи свой пол! 🌟

    ➡️ Выбери один из вариантов:
    """
                else:
                    txt = """<b>Name provided! ✅</b>
    Great, now specify your gender! 🌟

    ➡️ Choose one of the options:
    """

                inline_keyboard = [
                    [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                    [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                    [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
                ]

                keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
                await state.set_state(RegState.gender)
                await message.answer(txt, reply_markup=keyboard)
            else:
                txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
                await state.set_state(state=None)

                
                if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=message, state=state , user=user, lang=lang)
                else:
                    await message.answer(txt)

        else:
            txt = """<❌ <b>Ошибка:</b> Ваше имя содержит запрещенные слова. Пожалуйста, выберите другое имя. ✍️""" if lang == "ru" else """<❌ <b>Error:</b> Your name contains prohibited words. Please choose another name. ✍️"""
            await state.set_state(RegState.name)
            await message.answer(txt)
        
# ++++++++++++++++ GENDER +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("gender_"), RegState.gender)
async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.gender = callback_query.data.split("_")[1]
        await user.save()
        if user.orientation is None:
            if lang == "ru":
                txt = """<b>Пол указан! ✅</b>
    Теперь укажи свою ориентацию! 🌟

    ➡️ Выбери один из вариантов:
    """
            else:
                txt = """<b>Gender saved! ✅</b>
    Now specify your orientation! 🌟

    ➡️ Choose one of the options:
    """
            if user.gender =='mal':

                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender =="fem":
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender=="oth":
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]

            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)
# ++++++++++++++++ ORIENTATION +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("orientation_"), RegState.orientation)
async def set_orientation(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.orientation = callback_query.data.split("_")[1]
        await user.save()
        if user.for_whom is None:
            if lang == "ru":
                txt = """<b>Ориентация указана! ✅</b>
    Теперь укажи, кого ты хочешь видеть! 🌟

    ➡️ Выбери один из вариантов:
    """
            else:
                txt = """<b>Orientation saved! ✅</b>
    Now specify who you want to see! 🌟

    ➡️ Choose one of the options:
    """

            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")]
            ]

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ SHOW PREFERENCES +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("show_"), RegState.show)
async def set_show_preferences(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.for_whom = callback_query.data.split("_")[1]
        await user.save()
        if user.age is None:
            if lang == "ru":
                txt = """<b>Параметры просмотра указаны! ✅</b>
    Теперь укажи свой возраст! 🌟

    ➡️ Введите ваш возраст (минимум 16 лет):
    """
            else:
                txt = """<b>Viewing preferences saved! ✅</b>
    Now specify your age! 🌟

    ➡️ Enter your age (minimum 16 years):
    """

            await state.set_state(RegState.age)
            await callback_query.message.edit_text(txt)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ AGE +++++++++++++++

@router.message(RegState.age)
async def set_age(message: types.Message, user: User, state: FSMContext, lang: str):
    if user:
        if message.text.isdigit():
            age = int(message.text)
            if age >= 16:
                user.age = age
                await user.save()
                if user.preferences is None:
                    if lang == "ru":
                        txt = """<b>Возраст указан! ✅</b>
    Теперь укажи свои цели! 🌟

    ➡️ Выбери цели из предложенных вариантов:
    """
                    else:
                        txt = """<b>Age saved! ✅</b>
    Now specify your goals! 🌟

    ➡️ Choose your goals from the options provided:
    """
                    inline_keyboard=[]
                    if lang =="ru":
                        inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                        inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                        inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                        inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
                    else:
                        inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                        inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                        inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                        inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])


                    keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
                    await state.set_state(RegState.preferences)
                    await message.answer(txt, reply_markup=keyboard)
                else:
                    txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
                    await state.set_state(state=None)

                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                        await add_profile(message=message, state=state , user=user, lang=lang)
                    else:
                        await message.answer(txt)
            else:
                txt = """❌ <b>Ошибка:</b> Возраст должен быть не менее 16 лет. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be at least 16 years. 🔢"""
                await message.answer(txt)
        else:
            txt = """❌ <b>Ошибка:</b> Возраст должен быть числом. Пожалуйста, введите корректное значение. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be a number. Please enter a valid value. 🔢"""
            await message.answer(txt)


# ++++++++++++++++ PREFERENCES +++++++++++++++

@router.callback_query(lambda c: "interest_" in c.data, RegState.preferences)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
    if user:
        pref = callback_query.data.split("_")[1]
        user.preferences=pref
        await user.save()
        if user.location is None:
            keyboard = ReplyKeyboardMarkup(
                keyboard=[[ KeyboardButton(text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",request_location=True)]],resize_keyboard=True,one_time_keyboard=True)

            if lang == "ru":
                txt = """<b>Цели поиска указаны! ✅</b>
    Отлично, теперь нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍

    ⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

    💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
    Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

    ➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
    """
            else:
                txt = """<b>Search goals saved! ✅</b>
    Great, now we need your location to suggest people nearby. 🌍

    ⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

    💡 <b>Note:</b> You can send your current location by pressing the button below. 
    If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

    ➡️ Please press the button below to share your location or choose a point on the map.
    """

            await state.set_state(RegState.location)
            await callback_query.bot.delete_message(callback_query.from_user.id, callback_query.message.message_id)
            msg= await callback_query.bot.send_message(callback_query.from_user.id, txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ LOCATION +++++++++++++++

@router.message(RegState.location, lambda message: message.content_type == ContentType.LOCATION)
async def set_location(message: types.Message, user: User, state: FSMContext, lang: str):
    
    if user:
        print(f"\n\n\n\n\n\n\n\n\n\n\n\n\n\n{message.location}\n\n\n\n\n\n\n\n\n\n\n\n{message.location.model_config}")
        user.location = f"{message.location.latitude},{message.location.longitude}"
        await user.save()
        if user.about is None:
            if lang == "ru":
                txt = """<b>Локация указана! ✅</b>
    Отлично, теперь расскажи немного о себе. 🌟

    ➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
    """
            else:
                txt = """<b>Location saved! ✅</b>
    Great, now tell us a bit about yourself. 🌟

    ➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
    """
            await state.set_state(RegState.about)
            data = await state.get_data()
            if "idmsg_local" in data: 
                await message.bot.delete_message(message.from_user.id, data["idmsg_local"])
            data["idmsg_local"]=''
            await state.update_data(data)
            await message.bot.delete_message(message.from_user.id, message.message_id)
            await message.bot.send_message(message.from_user.id, txt)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=message, state=state , user=user, lang=lang)
            else:
                await message.answer(txt)
# ++++++++++++++++ ABOUT +++++++++++++++

@router.message(RegState.about)
async def set_about(message: types.Message, user: User, state: FSMContext, lang: str):
    global BAD_WORDS
    if user:
        if message.text:
            if message.text not in BAD_WORDS:
                user.about = message.text
                await user.save()
                if user.hobbies is None:
                
                    await state.set_state(RegState.hobbies)
                # Увлечения на двух языках с номерами
                    interests = [
                        (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
                    ]
                    inlinekeyboard = []
                    row = []

                    # Формируем кнопки для увлечений, по 3 в ряд
                    for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
                        row.append(InlineKeyboardButton(
                            text=interest_ru if lang == "ru" else interest_en,
                            callback_data=f"intrs_{number}"
                        ))
                        # Если добавлено 3 кнопки или это последняя кнопка в списке
                        if len(row) == 2 or i == len(interests[:10]):
                            inlinekeyboard.append(row)
                            row = []  # Сбрасываем строку для следующего ряда

                    # Добавляем стрелки навигации в последнюю строку
                    inlinekeyboard.append([
                        InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
                        InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
                    ])

                    keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
                    
                    if lang == "ru":
                        txt = """<b>Записали ✅</b>
    Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟

    ➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
        """
                    else:
                        txt = """<b>Saved ✅</b>
    Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
    """


                    await message.answer(txt, reply_markup=keyboard)
                else:
                    txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."
                    await state.set_state(state=None)

                    
                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                        await add_profile(message=message, state=state , user=user, lang=lang)
                    else:
                        await message.answer(txt)
            else:
                if lang == "ru":
                    txt = """❌ <b>Ошибка:</b> Описание содержит запрещенные слова. Пожалуйста, введите другое описание и попробуйте снова. ✍️"""
                else:
                    txt = """❌ <b>Error:</b> The description contains prohibited words. Please enter another description and try again. ✍️"""
                await message.answer(txt)
                await state.set_state(RegState.about)
        else:
                if lang == "ru":
                    txt = """❌ <b>Ошибка:</b> Описание долджно содержать текст ✍️"""
                else:
                    
                    txt = """❌ <b>Error:</b> The description must contain text. Please write something ✍️"""
                await message.answer(txt)
                await state.set_state(RegState.about)

# ++++++++++++++++ HOBBIES +++++++++++++++

@router.callback_query(lambda c: "intrs_" in c.data or c.data.startswith("intrs_page") or c.data == "intrs_done", RegState.hobbies)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    # Загружаем список интересов
    interests = [
        (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]

    # Обработка страниц
    state_data = await state.get_data()
    current_page = state_data.get("current_page", 1)
    hobbies = state_data.get("selected_hobbies", [])

    if callback_query.data.startswith("intrs_page"):
        if "next" in callback_query.data:
            current_page += 1
        elif "back" in callback_query.data:
            current_page -= 1
        await state.update_data(current_page=current_page)

    elif callback_query.data.startswith("intrs_") and callback_query.data != "intrs_done":
        interest = callback_query.data.split("_")[1]
        if interest in hobbies:
            hobbies.remove(interest)
        else:
            if len(hobbies) < 5:
                hobbies.append(interest)
            else:
                txt1 = "Выбрано максимальное количество! Уберите один интерес или нажмите 'Сохранить'." if lang == "ru" else "Maximum number selected! Remove one interest or click 'Save'."
                await callback_query.answer(
                    txt1,
                    show_alert=True
                )
                return
        await state.update_data(selected_hobbies=hobbies)

    elif callback_query.data == "intrs_done":
        if len(hobbies) < 5:
            txt2 = "Вы должны выбрать минимум 5 интересов, чтобы продолжить!" if lang == "ru" else "You must select at least 5 interests to continue!"
            await callback_query.answer(
                txt2,
                show_alert=True
            )
            return
        else:
            user.hobbies = hobbies  # Сохраняем в базу данных только при завершении
            await user.save()
            if user.medias is None:
                txt3 = "Интересы сохранены! ✅" if lang == "ru" else "Interests saved! ✅"
                await callback_query.answer(txt3, show_alert=True)

                txt = """🎉 <b>Отлично!</b> Ваши хобби успешно сохранены.  

    Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
    Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """🎉 <b>Great!</b> Your hobbies have been successfully saved.  

    Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
    Or press "Skip" to continue. ⏩"""

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
                ])
                data = await state.get_data()
                msg =await callback_query.message.edit_text(txt, reply_markup=keyboard)
                data['idmsg_media']=msg.message_id
                await state.update_data(data)
                await state.set_state(RegState.media)
                return
            else:
                txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."
                await state.set_state(state=None)
                await callback_query.answer(txt, show_alert=True)

                if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
                else:
                    await callback_query.message.edit_text(txt, reply_markup=None)
                return

    # Генерация кнопок для текущей страницы
    page_size = 10
    start_index = (current_page - 1) * page_size
    end_index = start_index + page_size
    inlinekeyboard = []
    row = []

    for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
        text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
        row.append(InlineKeyboardButton(
            text=text,
            callback_data=f"intrs_{number}"
        ))
        if len(row) == 2 or i == len(interests[start_index:end_index]):
            inlinekeyboard.append(row)
            row = []

    navigation_buttons = []
    if current_page > 1:
        navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
    if end_index < len(interests):
        navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
    if navigation_buttons:
        inlinekeyboard.append(navigation_buttons)

    if len(hobbies) == 5:
        inlinekeyboard.append(
            [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
        )

    keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
    txt = (f"<b>Выбрано {len(hobbies)}/5 увлечений ✅</b>\n" if lang == "ru" else f"<b>Selected {len(hobbies)}/5 hobbies ✅</b>\n")
    txt += "Отлично, выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми 'Сохранить'." if lang == "ru" else "Great, select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click 'Save'."

    await callback_query.message.edit_text(txt, reply_markup=keyboard)

                [FILE] myprofile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/myprofile.py ---
from aiogram import Router, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo
from src.models import User
from aiogram.filters import CommandStart, Command
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState

router = Router()

# Словари переводов
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"fem":"👩 Девушки",
    "mal":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "fem":"👩 fem",
    "mal":"👨 mal",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"💫Другая",
                "skip":"Не указана"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"💫Other",
                "skip":"Not specified"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}

import ssl
import certifi
from geopy.geocoders import Nominatim

def get_location_by_coordinates(latitude, longitude):
    geolocator = Nominatim(
        user_agent="my_geopy_app",
        timeout=10,
        ssl_context=ssl.create_default_context(cafile=certifi.where())
    )
    try:
        location = geolocator.reverse((latitude, longitude), exactly_one=True)
        if location:
            address = location.raw.get('address', {})
            city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
            return city or location.address
        else:
            return "Местоположение не найдено"
    except Exception as e:
        return f"Ошибка при определении местоположения: {e}"
    

@router.message(Command("myprofile"))
async def my_profile_handler(message: types.Message,state: FSMContext):
    user = await User.get_or_none(user_id=message.from_user.id)

    if not user:
        lang = "ru"
        await message.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
        return

    lang = user.lang if user.lang in ["ru", "en"] else "ru"
    hobbies_text = ", ".join([
        (interest[1] if lang == "ru" else interest[2])
        for interest in INTERESTS
        if str(interest[0]) in (user.hobbies or [])
    ])

    location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
    if "," in location_text:
        latitude, longitude = map(float, location_text.split(","))
        location_text = get_location_by_coordinates(latitude, longitude)

    subscription_text = (
        f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
    )
    if user.subscription != "Free":
        subscription_text += (
            f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
        )

    description = (
        f"<b>{'Ваш профиль' if lang == 'ru' else 'Your profile'}:</b>\n\n"
        f"<b>{'Имя' if lang == 'ru' else 'Name'}:</b> {user.name}\n"
        f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
        f"<b>{'Пол' if lang == 'ru' else 'Gender'}:</b> {GENDER[lang][user.gender]}\n"
        f"<b>{'Локация' if lang == 'ru' else 'Location'}:</b> {location_text or ('Локация не указана' if lang == 'ru' else 'Location not provided')}\n\n"
        f"{subscription_text}"
        f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
        f"<b>{'Кого показывать' if lang == 'ru' else 'Viewing Preferences'}:</b> {WHO[lang][user.for_whom]}\n"
        f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
        f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
        f"_________________________\n{user.about or ''}\n"
    )



    media = user.medias or []
    if len(media) == 1:
        media_file = media[0]['file_id']
        if media[0]['type'] == 'photo':
            msg= await message.bot.send_photo(message.from_user.id, media_file, caption=description)
        elif media[0]['type'] == 'video':
            msg= await message.bot.send_video(message.from_user.id, media_file, caption=description)
    else:
        files=[]
        i =0
        for media_file in media:
            
            caption=description if i == 0 else None
            
            if media_file["type"] =="video":
                files.append(InputMediaVideo(media=f"{media_file['file_id']}", caption=caption))
                i = i+1
            elif media_file['type'] == 'photo':
                files.append(InputMediaPhoto(media=f"{media_file['file_id']}", caption=caption))
                i = i+1
            else:
                continue
                 

    # Отправка медиа-группы
        msg= await message.bot.send_media_group(chat_id=message.from_user.id, media=files)
        data= await state.get_data()
        data["id_card_profile"]=None
        await state.update_data(data=data)
    lang = user.lang if user and user.lang in ["ru", "en"] else "ru"
    if user.localstatus == "active":
        btn_local = InlineKeyboardButton(
            text="🌍 Скрыть локацию" if lang == "ru" else "🌍 Hide Location",
            callback_data="location_hish"
        )
    else:
        btn_local = InlineKeyboardButton(
            text="🌍 Показать локацию" if lang == "ru" else "🌍 Show Location",
            callback_data="location_hish"
        )

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="🖋 Имя" if lang == "ru" else "🖋 Name",
                callback_data="fedit_name"
            ),
            InlineKeyboardButton(
                text="🎂 Возраст" if lang == "ru" else "🎂 Age",
                callback_data="fedit_age"
            )
        ],
        [
            InlineKeyboardButton(
                text="📍 Изменить локацию" if lang == "ru" else "📍 Edit Location",
                callback_data="fedit_location"
            ),
            btn_local
        ],
        [
            InlineKeyboardButton(
                text="⚥ Пол" if lang == "ru" else "⚥ Gender",
                callback_data="fedit_gender"
            ),
            InlineKeyboardButton(
                text="🌈 Ориентация" if lang == "ru" else "🌈 Orientation",
                callback_data="fedit_orientation"
            )
        ],
        [
            InlineKeyboardButton(
                text="👁️‍🗨️ Кого показывать" if lang == "ru" else "👁️‍🗨️ Viewing Preferences",
                callback_data="fedit_pref"
            ),
            InlineKeyboardButton(
                text="🎯 Цели" if lang == "ru" else "🎯 Goals",
                callback_data="fedit_goals"
            )
        ],
        [
            InlineKeyboardButton(
                text="🎨 Увлечения" if lang == "ru" else "🎨 Hobbies",
                callback_data="fedit_hobbies"
            ),
            InlineKeyboardButton(
                text="📝 Описание" if lang == "ru" else "📝 Description",
                callback_data="fedit_descr"
            )
        ],[
    InlineKeyboardButton(
        text="🖼️ Изменить медиа" if lang == "ru" else "🖼️ Edit Media",
        callback_data="fedit_media"
    )
],

        [
            InlineKeyboardButton(
                text="🔄 Заполнить заново" if lang == "ru" else "🔄 Refill Profile",
                callback_data="reset_profile"
            )
        ]
    ])


    await message.answer(
        MESSAGES["action_prompt"][lang], 
        reply_markup=keyboard
    )


                [DIR] __pycache__
                    [FILE] myproffile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/myproffile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] edit_profile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/edit_profile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] serch.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/serch.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] anketa.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/anketa.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] registration.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/registration.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                    [FILE] myprofile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/__pycache__/myprofile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] edit_profile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/edit_profile.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType
from src.utils.comands import set_user_specific_commands
from aiogram import Router, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo
from src.models import User
from aiogram.filters import CommandStart, Command
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from src.utils.add_profile import add_profile



# Словари переводов
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"girls":"👩 Девушки",
    "boys":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "girls":"👩 Girls",
    "boys":"👨 Boys",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"Другая"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"Other"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}

import ssl
import certifi
from geopy.geocoders import Nominatim

def get_location_by_coordinates(latitude, longitude):
    geolocator = Nominatim(
        user_agent="my_geopy_app",
        timeout=10,
        ssl_context=ssl.create_default_context(cafile=certifi.where())
    )
    try:
        location = geolocator.reverse((latitude, longitude), exactly_one=True)
        if location:
            address = location.raw.get('address', {})
            city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
            return city or location.address
        else:
            return "Местоположение не найдено"
    except Exception as e:
        return f"Ошибка при определении местоположения: {e}"

router = Router()

                # "🖋 Имя" if 🖋 Name",callback_data="fedit_name"
                # "🎂 Возраст" if 🎂 Age",callback_data="fedit_age"
                # "📍 Изменить локацию" if 📍 Edit Location",callback_data="fedit_location"
                # "⚥ Пол" if ⚥ Gender",callback_data="fedit_gender"            
                # "🌈 Ориентация" if 🌈 Orientation",callback_data="fedit_orientation"
                # "👁️‍🗨️ Кого показывать" if 👁️‍🗨️ Viewing Preferences",callback_data="fedit_pref"
                # "🎯 Цели" if 🎯 Goals",callback_data="fedit_goals"           
                # "🎨 Увлечения" if 🎨 Hobbies",callback_data="fedit_hobbies"
                # "📝 Описание" if 📝 Description",callback_data="fedit_descr"
            

@router.callback_query(lambda c: c.data.startswith("fedit_"))
async def set_edit_field(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    cb_data = (callback_query.data.split("_"))[1]
    data = await state.get_data()
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="Назад⬅️" if lang == "ru" else "Back⬅️",
                callback_data="fedit_back"
            )
        ]
    ])

    if cb_data == "name":
        txt = "🌟➡️ Укажи свое имя, чтобы мы могли начать!\n\nИли надмите <b>'назад⬅️'</b> чтобы отменить действвие " if lang == "ru" else "🌟➡️ Please provide your name to get started!\n\nOr press <b>'back⬅️'</b> to undo the action"
        data = await state.get_data()
        await state.set_state(RegState.name)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "age":
        txt = "🎂➡️ Укажи свой возраст, чтобы продолжить!\n(минимум 16 лет):\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "🎂➡️ Please provide your age to proceed!\n(minimum 16 years):\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.age)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "location":
        if lang == "ru":
            txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
        else:
            txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

        data = await state.get_data()
        keyboard1 = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        await state.set_state(RegState.location)
        txt1="Жду локаци..." if lang=="ru" else "Waiting for the location..."
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        msg1 = await callback_query.bot.send_message(callback_query.from_user.id, txt1, reply_markup=keyboard1)
        data["idmsg_local"] = msg1.message_id
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data == "gender":
        txt = "⚥➡️ Укажи свой пол, чтобы мы могли лучше настроить профиль!\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "⚥➡️ Please specify your gender to better customize your profile!\n\nOr press <b>'back⬅️'</b> to undo the action."
        # Добавляем кнопки для выбора пола
        inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")],
                [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
            ]

        keyboard1 = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        msg= await callback_query.message.edit_text(txt, reply_markup=keyboard1)
        data = await state.get_data()
        await state.set_state(RegState.gender)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "orientation":
        if user.gender =='mal':

            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]
        elif user.gender =="fem":
            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]
        elif user.gender=="oth":
            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]


        inline_keyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard1 = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        txt = "🌈➡️ Укажи свою ориентацию, чтобы мы могли найти подходящих людей!\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "🌈➡️ Please specify your orientation so we can find the right people for you!\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.orientation)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard1)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "pref":
        txt = "👁️‍🗨️➡️ Укажи, кого ты хочешь видеть в своей ленте: девушек, парней или всех!\n\nИли нажми <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "👁️‍🗨️➡️ Specify who you want to see in your feed: girls, boys, or everyone!\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.show)
        inline_keyboard = [
            [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
            [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
            [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")],
            [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
        ]

        keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "goals":
        if lang == "ru":
            txt = """Укажи свои цели! 🌟

➡️ Выбери цели из предложенных вариантов:
"""
        else:
            txt = """<Specify your goals! 🌟

➡️ Choose your goals from the options provided:
"""
        inline_keyboard=[]
        if lang =="ru":
            inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
            inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
            inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
            inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
        else:
            inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
            inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
            inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
            inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

        inline_keyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        await state.set_state(RegState.preferences)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "hobbies":
    # Увлечения на двух языках с номерами
        interests = [
            (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
            (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
            (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
            (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
            (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
        ]
        inlinekeyboard = []
        row = []

        # Формируем кнопки для увлечений, по 3 в ряд
        for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
            row.append(InlineKeyboardButton(
                text=interest_ru if lang == "ru" else interest_en,
                callback_data=f"intrs_{number}"
            ))
            # Если добавлено 3 кнопки или это последняя кнопка в списке
            if len(row) == 2 or i == len(interests[:10]):
                inlinekeyboard.append(row)
                row = []  # Сбрасываем строку для следующего ряда

        # Добавляем стрелки навигации в последнюю строку
        inlinekeyboard.append([
            InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
            InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
        ])
        inlinekeyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
        if lang == "ru":
            txt = """
Выбери до 5 увлечений, которые описывают тебя. 🌟

➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
"""
        else:
            txt = """
Select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
    """
        await state.set_state(RegState.hobbies)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data == "descr":
        txt = (
"📝➡️ Напиши короткое описание о себе, чтобы другие могли узнать тебя лучше! Укажи свои увлечения, интересы или что-то, что ты хотел бы рассказать о себе. 🌟\n\nИли нажми <b>'назад⬅️'</b>, чтобы отменить действие."
        if lang == "ru"
        else "📝➡️ Write a short description about yourself so others can get to know you better! Share your hobbies, interests, or anything you'd like to tell about yourself. 🌟\n\nOr press <b>'back⬅️'</b> to undo the action."
        )

        data = await state.get_data()
        await state.set_state(RegState.about)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "media":
        txt = (
"📷 Пожалуйста, отправьте <b>от 1 до 3 медиа</b> (фотографии или видео), чтобы обновить ваш профиль.\n\n"
"Нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else
"📷 Please send <b>1 to 3 media</b> (photos or videos) to update your profile.\n\n"
"Press <b>'back⬅️'</b> to cancel the action."
)       
        await state.set_state(RegState.media)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_media"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data =="back":
        await state.set_state(state=None)
        data = await state.get_data()
        if 'idmsg_local' in data:
            if data["idmsg_local"] is not None:
                await callback_query.bot.delete_message(callback_query.from_user.id, data["idmsg_local"])
                data["idmsg_local"]=None
                await state.update_data(data=data)
                await state.clear()
        

        user = await User.get_or_none(user_id=callback_query.from_user.id)

        if not user:
            lang = "ru"
            await callback_query.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
            return

        lang = user.lang if user.lang in ["ru", "en"] else "ru"
        hobbies_text = ", ".join([
            (interest[1] if lang == "ru" else interest[2])
            for interest in INTERESTS
            if str(interest[0]) in (user.hobbies or [])
        ])

        location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
        if "," in location_text:
            latitude, longitude = map(float, location_text.split(","))
            location_text = get_location_by_coordinates(latitude, longitude)

        subscription_text = (
            f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
        )
        if user.subscription != "Free":
            subscription_text += (
                f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
            )

        description = (
            f"<b>{'Ваш профиль' if lang == 'ru' else 'Your profile'}:</b>\n\n"
            f"<b>{'Имя' if lang == 'ru' else 'Name'}:</b> {user.name}\n"
            f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
            f"<b>{'Пол' if lang == 'ru' else 'Gender'}:</b> {GENDER[lang][user.gender]}\n"
            f"<b>{'Локация' if lang == 'ru' else 'Location'}:</b> {location_text or ('Локация не указана' if lang == 'ru' else 'Location not provided')}\n\n"
            f"{subscription_text}"
            f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
            f"<b>{'Кого показывать' if lang == 'ru' else 'Viewing Preferences'}:</b> {WHO[lang][user.for_whom]}\n"
            f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
            f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
            f"_________________________\n{user.about or ''}\n"
        )



        media = user.medias or []
        # if len(media) == 1:
        #     media_file = media[0]['file_id']
        #     if media[0]['type'] == 'photo':
        #         await callback_query.bot.send_photo(callback_query.from_user.id, media_file, caption=description)
        #     elif media[0]['type'] == 'video':
        #         await callback_query.bot.send_video(callback_query.from_user.id, media_file, caption=description)
        lang = user.lang if user and user.lang in ["ru", "en"] else "ru"
        if user.localstatus == "active":
            btn_local = InlineKeyboardButton(
                text="🌍 Скрыть локацию" if lang == "ru" else "🌍 Hide Location",
                callback_data="location_hish"
            )
        else:
            btn_local = InlineKeyboardButton(
                text="🌍 Показать локацию" if lang == "ru" else "🌍 Show Location",
                callback_data="location_hish"
            )

        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="🖋 Имя" if lang == "ru" else "🖋 Name",
                    callback_data="fedit_name"
                ),
                InlineKeyboardButton(
                    text="🎂 Возраст" if lang == "ru" else "🎂 Age",
                    callback_data="fedit_age"
                )
            ],
            [
                InlineKeyboardButton(
                    text="📍 Изменить локацию" if lang == "ru" else "📍 Edit Location",
                    callback_data="fedit_location"
                ),
                btn_local
            ],
            [
                InlineKeyboardButton(
                    text="⚥ Пол" if lang == "ru" else "⚥ Gender",
                    callback_data="fedit_gender"
                ),
                InlineKeyboardButton(
                    text="🌈 Ориентация" if lang == "ru" else "🌈 Orientation",
                    callback_data="fedit_orientation"
                )
            ],
            [
                InlineKeyboardButton(
                    text="👁️‍🗨️ Кого показывать" if lang == "ru" else "👁️‍🗨️ Viewing Preferences",
                    callback_data="fedit_pref"
                ),
                InlineKeyboardButton(
                    text="🎯 Цели" if lang == "ru" else "🎯 Goals",
                    callback_data="fedit_goals"
                )
            ],
            [
                InlineKeyboardButton(
                    text="🎨 Увлечения" if lang == "ru" else "🎨 Hobbies",
                    callback_data="fedit_hobbies"
                ),
                InlineKeyboardButton(
                    text="📝 Описание" if lang == "ru" else "📝 Description",
                    callback_data="fedit_descr"
                )
            ],
            [
                InlineKeyboardButton(
                    text="🔄 Заполнить заново" if lang == "ru" else "🔄 Refill Profile",
                    callback_data="reset_profile"
                )
            ]
        ])


        await callback_query.message.edit_text(
            MESSAGES["action_prompt"][lang], 
            reply_markup=keyboard
        )
    else:
        await callback_query.answer("Неизвестная команда" if lang == "ru" else "Unknown command", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("reset_"))
async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    cb_data = (callback_query.data.split("_"))[1]
    if user:
        if cb_data == "profile":
            
            txt = """<b>Вы собираетесь заполнить профиль заново. ❗️</b>

            После нажатия <b>"ДА"</b> это действие будет <b>необратимо</b>. Все текущие данные профиля будут удалены.

            Вы точно уверены в этом?""" if lang == "ru" else """<b>You are about to refill your profile. ❗️</b>

            Once you press <b>"YES"</b>, this action will be <b>irreversible</b>. All current profile data will be deleted.

            Are you sure about this?"""
            inline_keyboard = [
                [InlineKeyboardButton(text="Да" if lang == "ru" else "Yes", callback_data="reset_yes")],
                [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        elif cb_data == "yes":  
            user.name=None
            user.age=None
            user.gender=None
            user.orientation=None
            user.for_whom=None
            user.preferences=None
            user.location=None
            user.about=None
            user.hobbies=None
            user.medias=None
            await user.save()
            await state.clear()
            await callback_query.answer("Профиль удален" if lang == "ru" else "Profile deleted", show_alert=True)
            await callback_query.message.edit_reply_markup(reply_markup=None)
            await add_profile(message=callback_query.message, state=state , user=user, lang=lang)








            await callback_query.answer("Профиль удален" if lang == "ru" else "Profile deleted")

# ===+++++=====+++++++=======++++++ HANDLERS ===+++++=====+++++++=======++++++ 

# BAD_WORDS = [
#     # Наркотики
#     "наркотик", "наркота", "косяк", "травка", "гашиш", "героин", "кокаин", "амфетамин", "экстази",
#     "марихуана", "спайс", "лсд", "шишки", "опиум", "план", "кристалл", "мефедрон", "drugs", "drug",
#     "weed", "marijuana", "cocaine", "heroin", "ecstasy", "meth", "amphetamine", "hash", "spice",
#     "lsd", "crystal", "meph", "opium", "j0int", "dr@g", "tr@vka",

#     # CP
#     "детская порнография", "детское порно", "запрещенное видео", "нелегальный контент", "порнография с детьми",
#     "cp", "child porn", "child pornography", "illegal content", "b@nned video", "ch!ld p0rn",

#     # Оружие
#     "оружие", "пистолет", "винтовка", "автомат", "пулемет", "граната", "мина", "бомба", "арсенал",
#     "ружье", "ствол", "калашников", "ак-47", "глок", "гранатомет", "weapon", "gun", "pistol", "rifle",
#     "machine gun", "grenade", "bomb", "landmine", "arsenal", "shotgun", "kalashnikov", "ak47",
#     "glock", "rocket launcher", "we@pon", "glock-19", "b0mb",

#     # Additional prohibited words
#     "explosive", "tnt", "c4", "detonator", "silencer", "sniper", "assault rifle", "pipe bomb",
#     "наркот", "герич", "герыч", "доза", "спайсы", "соли", "фен", "скорость",
#     "запрещенка", "порно с детьми", "порево", "kill", "murder", "mass shooting", "terrorist", "attack"
# ]






# # ++++++++++++++++ NAME +++++++++++++++

# @router.message(RegState.name)
# async def set_name(message: types.Message, state: FSMContext, lang: str):
#     user = await User.get_or_none(user_id=message.from_user.id)
#     global BAD_WORDS
#     if user:
#         if message.text not in BAD_WORDS:
#             user.name = message.text.strip()
#             await user.save()
            
#             if lang == "ru":
#                 txt = """<b>Имя указано! ✅</b>
# Отлично, теперь укажи свой пол! 🌟

# ➡️ Выбери один из вариантов:
# """
#             else:
#                 txt = """<b>Name provided! ✅</b>
# Great, now specify your gender! 🌟

# ➡️ Choose one of the options:
# """

#             inline_keyboard = [
#                 [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
#                 [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
#                 [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
#             ]

#             keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#             await state.set_state(RegState.gender)
#             await message.answer(txt, reply_markup=keyboard)
#         else:
#             txt = """<❌ <b>Ошибка:</b> Ваше имя содержит запрещенные слова. Пожалуйста, выберите другое имя. ✍️""" if lang == "ru" else """<❌ <b>Error:</b> Your name contains prohibited words. Please choose another name. ✍️"""
#             await state.set_state(RegState.name)
#             await message.answer(txt)


# # ++++++++++++++++ GENDER +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("gender_"), RegState.gender)
# async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.gender = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Пол указан! ✅</b>
# Теперь укажи свою ориентацию! 🌟

# ➡️ Выбери один из вариантов:
# """
#         else:
#             txt = """<b>Gender saved! ✅</b>
# Now specify your orientation! 🌟

# ➡️ Choose one of the options:
# """
#         if user.gender =='mal':

#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]
#         elif user.gender =="fem":
#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]
#         elif user.gender=="oth":
#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]



#         keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#         await state.set_state(RegState.orientation)
#         await callback_query.message.edit_text(txt, reply_markup=keyboard)


# # ++++++++++++++++ ORIENTATION +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("orientation_"), RegState.orientation)
# async def set_orientation(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.orientation = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Ориентация указана! ✅</b>
# Теперь укажи, кого ты хочешь видеть! 🌟

# ➡️ Выбери один из вариантов:
# """
#         else:
#             txt = """<b>Orientation saved! ✅</b>
# Now specify who you want to see! 🌟

# ➡️ Choose one of the options:
# """

#         inline_keyboard = [
#             [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
#             [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
#             [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")]
#         ]

#         keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#         await state.set_state(RegState.show)
#         await callback_query.message.edit_text(txt, reply_markup=keyboard)


# # ++++++++++++++++ SHOW PREFERENCES +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("show_"), RegState.show)
# async def set_show_preferences(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.for_whom = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Параметры просмотра указаны! ✅</b>
# Теперь укажи свой возраст! 🌟

# ➡️ Введите ваш возраст (минимум 16 лет):
# """
#         else:
#             txt = """<b>Viewing preferences saved! ✅</b>
# Now specify your age! 🌟

# ➡️ Enter your age (minimum 16 years):
# """

#         await state.set_state(RegState.age)
#         await callback_query.message.edit_text(txt)


# # ++++++++++++++++ AGE +++++++++++++++

# @router.message(RegState.age)
# async def set_age(message: types.Message, user: User, state: FSMContext, lang: str):
#     if user:
#         if message.text.isdigit():
#             age = int(message.text)
#             if age >= 16:
#                 user.age = age
#                 await user.save()

#                 if lang == "ru":
#                     txt = """<b>Возраст указан! ✅</b>
# Теперь укажи свои цели! 🌟

# ➡️ Выбери цели из предложенных вариантов:
# """
#                 else:
#                     txt = """<b>Age saved! ✅</b>
# Now specify your goals! 🌟

# ➡️ Choose your goals from the options provided:
# """
#                 inline_keyboard=[]
#                 if lang =="ru":
#                     inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
#                     inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
#                     inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
#                     inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
#                 else:
#                     inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
#                     inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
#                     inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
#                     inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])


#                 keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#                 await state.set_state(RegState.preferences)
#                 await message.answer(txt, reply_markup=keyboard)
#             else:
#                 txt = """❌ <b>Ошибка:</b> Возраст должен быть не менее 16 лет. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be at least 16 years. 🔢"""
#                 await message.answer(txt)
#         else:
#             txt = """❌ <b>Ошибка:</b> Возраст должен быть числом. Пожалуйста, введите корректное значение. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be a number. Please enter a valid value. 🔢"""
#             await message.answer(txt)


# # ++++++++++++++++ PREFERENCES +++++++++++++++

# @router.callback_query(lambda c: "interest_" in c.data, RegState.preferences)
# async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
#     if user:
#         pref = callback_query.data.split("_")[1]
#         user.preferences=pref
#         await user.save()
#         keyboard = ReplyKeyboardMarkup(
#             keyboard=[
#                 [
#                     KeyboardButton(
#                         text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
#                         request_location=True
#                     )
#                 ]
#             ],
#             resize_keyboard=True,
#             one_time_keyboard=True
#         )

#         if lang == "ru":
#             txt = """
# Нам нужно знать твою локацию, чтобы предложить людей рядом. 🌍

# ⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

# 💡 <b>Обратите внимание:</b> с тарифом <b>Pro</b> вы можете указать любую интересующую вас локацию и искать людей в том месте, где вам удобно! Это отличный способ расширить круг общения и найти людей из интересующих вас регионов. 🌎

# ➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию.
# """
#         else:
#             txt = """
# We need your location to suggest people nearby. 🌍

# ⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

# 💡 <b>Note:</b> With the <b>Pro</b> plan, you can specify any location you’re interested in and search for people in a convenient area! This is a great way to expand your connections and meet people from specific regions. 🌎

# ➡️ Please press the button below to share your location.
# """
#         await state.set_state(RegState.location)
#         await callback_query.bot.delete_message(callback_query.from_user.id, callback_query.message.message_id)
#         msg= await callback_query.bot.send_message(callback_query.from_user.id, txt, reply_markup=keyboard)
#         data = await state.get_data()
#         data['idmsg_local']=msg.message_id
#         await state.update_data(data)

# # ++++++++++++++++ LOCATION +++++++++++++++

# @router.message(RegState.location, lambda message: message.content_type == ContentType.LOCATION)
# async def set_location(message: types.Message, user: User, state: FSMContext, lang: str):
    
#     if user:
#         user.location = f"{message.location.latitude},{message.location.longitude}"
#         await user.save()
#         if lang == "ru":
#             txt = """<b>Локация указана! ✅</b>
# Отлично, теперь расскажи немного о себе. 🌟

# ➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
# """
#         else:
#             txt = """<b>Location saved! ✅</b>
# Great, now tell us a bit about yourself. 🌟

# ➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
# """
#         await state.set_state(RegState.about)
#         data = await state.get_data()
#         if "idmsg_local" in data: 
#             await message.bot.delete_message(message.from_user.id, data["idmsg_local"])
#         data["idmsg_local"]=''
#         await state.update_data(data)
#         await message.bot.delete_message(message.from_user.id, message.message_id)
#         await message.bot.send_message(message.from_user.id, txt)

# # ++++++++++++++++ ABOUT +++++++++++++++

# @router.message(RegState.about)
# async def set_about(message: types.Message, user: User, state: FSMContext, lang: str):
#     global BAD_WORDS
#     if user:
#         if message.text:
#             if message.text not in BAD_WORDS:
#                 user.about = message.text
#                 await user.save()
                
#                 await state.set_state(RegState.hobbies)
#             # Увлечения на двух языках с номерами
#                 interests = [
#                     (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
#                     (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
#                     (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
#                     (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
#                     (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
#                 ]
#                 inlinekeyboard = []
#                 row = []

#                 # Формируем кнопки для увлечений, по 3 в ряд
#                 for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
#                     row.append(InlineKeyboardButton(
#                         text=interest_ru if lang == "ru" else interest_en,
#                         callback_data=f"intrs_{number}"
#                     ))
#                     # Если добавлено 3 кнопки или это последняя кнопка в списке
#                     if len(row) == 2 or i == len(interests[:10]):
#                         inlinekeyboard.append(row)
#                         row = []  # Сбрасываем строку для следующего ряда

#                 # Добавляем стрелки навигации в последнюю строку
#                 inlinekeyboard.append([
#                     InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
#                     InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
#                 ])

#                 keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
                
#                 if lang == "ru":
#                     txt = """<b>Записали ✅</b>
#     Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟

#    ➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
#         """
#                 else:
#                     txt = """<b>Saved ✅</b>
#     Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
#     """


#                 await message.answer(txt, reply_markup=keyboard)
                
#             else:
#                 if lang == "ru":
#                     txt = """❌ <b>Ошибка:</b> Описание содержит запрещенные слова. Пожалуйста, введите другое описание и попробуйте снова. ✍️"""
#                 else:
#                     txt = """❌ <b>Error:</b> The description contains prohibited words. Please enter another description and try again. ✍️"""
#                 await message.answer(txt)
#                 await state.set_state(RegState.about)
#         else:
#                 if lang == "ru":
#                     txt = """❌ <b>Ошибка:</b> Описание долджно содержать текст ✍️"""
#                 else:
                    
#                     txt = """❌ <b>Error:</b> The description must contain text. Please write something ✍️"""
#                 await message.answer(txt)
#                 await state.set_state(RegState.about)

# # ++++++++++++++++ HOBBIES +++++++++++++++

# @router.callback_query(lambda c: "intrs_" in c.data or c.data.startswith("intrs_page") or c.data == "intrs_done", RegState.hobbies)
# async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     # Загружаем список интересов
#     interests = [
#         (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
#         (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
#         (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
#         (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
#         (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
#         (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
#         (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
#         (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
#         (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
#         (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
#         (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
#         (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
#         (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
#         (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
#         (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
#         (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
#         (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
#         (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
#         (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
#         (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
#     ]

#     # Обработка страниц
#     state_data = await state.get_data()
#     current_page = state_data.get("current_page", 1)
#     hobbies = state_data.get("selected_hobbies", [])

#     if callback_query.data.startswith("intrs_page"):
#         if "next" in callback_query.data:
#             current_page += 1
#         elif "back" in callback_query.data:
#             current_page -= 1
#         await state.update_data(current_page=current_page)

#     elif callback_query.data.startswith("intrs_") and callback_query.data != "intrs_done":
#         interest = callback_query.data.split("_")[1]
#         if interest in hobbies:
#             hobbies.remove(interest)
#         else:
#             if len(hobbies) < 5:
#                 hobbies.append(interest)
#             else:
#                 txt1 = "Выбрано максимальное количество! Уберите один интерес или нажмите 'Сохранить'." if lang == "ru" else "Maximum number selected! Remove one interest or click 'Save'."
#                 await callback_query.answer(
#                     txt1,
#                     show_alert=True
#                 )
#                 return
#         await state.update_data(selected_hobbies=hobbies)

#     elif callback_query.data == "intrs_done":
#         if len(hobbies) < 5:
#             txt2 = "Вы должны выбрать минимум 5 интересов, чтобы продолжить!" if lang == "ru" else "You must select at least 5 interests to continue!"
#             await callback_query.answer(
#                 txt2,
#                 show_alert=True
#             )
#             return
#         else:
#             user.hobbies = hobbies  # Сохраняем в базу данных только при завершении
#             await user.save()

#             txt3 = "Интересы сохранены! ✅" if lang == "ru" else "Interests saved! ✅"
#             await callback_query.answer(txt3, show_alert=True)

#             txt = """🎉 <b>Отлично!</b> Ваши хобби успешно сохранены.  

# Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
# Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """🎉 <b>Great!</b> Your hobbies have been successfully saved.  

# Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
# Or press "Skip" to continue. ⏩"""

#             keyboard = InlineKeyboardMarkup(inline_keyboard=[
#                 [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
#             ])

#             await callback_query.message.edit_text(txt, reply_markup=keyboard)
#             await state.set_state(RegState.media)
#             return

#     # Генерация кнопок для текущей страницы
#     page_size = 10
#     start_index = (current_page - 1) * page_size
#     end_index = start_index + page_size
#     inlinekeyboard = []
#     row = []

#     for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
#         text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
#         row.append(InlineKeyboardButton(
#             text=text,
#             callback_data=f"intrs_{number}"
#         ))
#         if len(row) == 2 or i == len(interests[start_index:end_index]):
#             inlinekeyboard.append(row)
#             row = []

#     navigation_buttons = []
#     if current_page > 1:
#         navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
#     if end_index < len(interests):
#         navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
#     if navigation_buttons:
#         inlinekeyboard.append(navigation_buttons)

#     if len(hobbies) == 5:
#         inlinekeyboard.append(
#             [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
#         )

#     keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
#     txt = (f"<b>Выбрано {len(hobbies)}/5 увлечений ✅</b>\n" if lang == "ru" else f"<b>Selected {len(hobbies)}/5 hobbies ✅</b>\n")
#     txt += "Отлично, выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми 'Сохранить'." if lang == "ru" else "Great, select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click 'Save'."

#     await callback_query.message.edit_text(txt, reply_markup=keyboard)


        

                [FILE] chat.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/chat.py ---


                [FILE] search.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/search.py ---


# import ssl
# import certifi
# from geopy.geocoders import Nominatim

# def get_location_by_coordinates(latitude, longitude):
#     geolocator = Nominatim(
#         user_agent="my_geopy_app",
#         timeout=10,
#         ssl_context=ssl.create_default_context(cafile=certifi.where())
#     )
#     try:
#         location = geolocator.reverse((latitude, longitude), exactly_one=True)
#         if location:
#             address = location.raw.get('address', {})
#             city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
#             return city or location.address
#         else:
#             return "Местоположение не найдено"
#     except Exception as e:
#         return f"Ошибка при определении местоположения: {e}"
    

# @router.message(Command("myprofile"))
# async def my_profile_handler(message: types.Message,state: FSMContext):
#     user = await User.get_or_none(user_id=message.from_user.id)

#     if not user:
#         lang = "ru"
#         await message.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
#         return

#     lang = user.lang if user.lang in ["ru", "en"] else "ru"
#     hobbies_text = ", ".join([
#         (interest[1] if lang == "ru" else interest[2])
#         for interest in INTERESTS
#         if str(interest[0]) in (user.hobbies or [])
#     ])

#     location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
#     if "," in location_text:
#         latitude, longitude = map(float, location_text.split(","))
#         location_text = get_location_by_coordinates(latitude, longitude)

#     subscription_text = (
#         f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
#     )
#     if user.subscription != "Free":
#         subscription_text += (
#             f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
#         )

#     description = (
#         f"<b>{user.name}</b> \n"
#         f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
#         f"{GENDER[lang][user.gender]}\n"
#         f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
#         f"{location_text}\n"

#         f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
#         f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
#         f"_________________________\n{user.about or ''}\n"
#     )



#     media = user.medias or []
#     if len(media) == 1:
#         media_file = media[0]['file_id']
#         if media[0]['type'] == 'photo':
#             msg= await message.bot.send_photo(message.from_user.id, media_file, caption=description)
#         elif media[0]['type'] == 'video':
#             msg= await message.bot.send_video(message.from_user.id, media_file, caption=description)
#     else:
#         files=[]
#         i =0
#         for media_file in media:
            
#             caption=description if i == 0 else None
            
#             if media_file["type"] =="video":
#                 files.append(InputMediaVideo(media=f"{media_file['file_id']}", caption=caption))
#                 i = i+1
#             elif media_file['type'] == 'photo':
#                 files.append(InputMediaPhoto(media=f"{media_file['file_id']}", caption=caption))
#                 i = i+1
#             else:
#                 continue
                 

#     # Отправка медиа-группы
#         msg= await message.bot.send_media_group(chat_id=message.from_user.id, media=files)
#         data= await state.get_data()
#         data["id_card_profile"]=None
#         await state.update_data(data=data)
    
    

   
        
    


                [FILE] serch.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/serch.py ---
from aiogram import Router, types, F
from aiogram.types import (
    ReplyKeyboardMarkup,
    KeyboardButton,
    InputMediaPhoto,
    InputMediaVideo,
    ReplyKeyboardRemove
)
from aiogram.fsm.context import FSMContext

import math
import ssl
import certifi
from geopy.geocoders import Nominatim
from tortoise.expressions import Q

from src.models import User as Userdb, Like, Block
from src.utils.state import SearchPeople

router = Router()

# -----------------------------
# Словари переводов
# -----------------------------
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), 
    (60, "Языковой обмен", "Language Exchange"),
]

PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {"fem": "👩 Женский", "mal": "👨 Мужской", "oth": "🌈 Другое"},
    "en": {"fem": "👩 Female", "mal": "👨 Male", "oth": "🌈 Other"}
}

WHO = {
    "ru": {"fem": "👩 Девушки", "mal": "👨 Парни", "all": "🌍 Все"},
    "en": {"fem": "👩 fem", "mal": "👨 mal", "all": "🌍 Everyone"}
}

ORI = {
    "ru": {
        "hetero": "❤️ Гетеро",
        "gay": "🌈 Гей",
        "bi": "💛 Би",
        "lesbian": "💖 Лесби",
        "gay_lesbian": "🌈 Гей/Лесби",
        "oth": "💫 Другая",
        "skip": "Не указана"
    },
    "en": {
        "hetero": "❤️ Hetero",
        "gay": "🌈 Gay",
        "bi": "💛 Bi",
        "lesbian": "💖 Lesbian",
        "gay_lesbian": "🌈 Gay/Lesbian",
        "oth": "💫 Other",
        "skip": "Not specified"
    }
}

# -----------------------------
# Вспомогательные функции
# -----------------------------
@router.message(F.text.in_(["❤️ Лайк", "💖 Суперлайк", "👎🏻 Дизлайк", "🚫 Заблокировать", "❗ Пожаловаться", "⏹ Остановить поиск",
                             "❤️ Like", "💖 Superlike", "👎🏻 Dislike", "🚫 Block", "❗ Report", "⏹ Stop Search"]))
async def handle_reaction(message: types.Message, state: FSMContext):
    user = await Userdb.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer("Профиль не найден.")
        return

    reaction = message.text
    if reaction in ["⏹ Остановить поиск", "⏹ Stop Search"]:
        await state.clear()
        await message.answer("Поиск остановлен.", reply_markup=ReplyKeyboardRemove())
        return

    data = await state.get_data()
    current_candidate_id = data.get("current_candidate_id")
    if not current_candidate_id:
        await message.answer("Нет текущей анкеты для оценки. Попробуйте начать поиск заново.")
        return

    candidate = await Userdb.get_or_none(user_id=current_candidate_id)
    if not candidate:
        await message.answer("Ошибка: кандидат не найден.")
        return

    if reaction in ["❤️ Лайк", "❤️ Like"]:
        await Like.create(from_user=user, to_user=candidate, is_superlike=False)
        # Если у пользователя Free-подписка, уведомляем, что для просмотра полного профиля необходимо оформить подписку.
        if user.subscription.lower() == "free":
            await message.answer("Вы получили лайк! Чтобы увидеть подробности профиля кандидата, необходимо приобрести подписку.")
            # Здесь можно добавить дополнительную логику для перенаправления на страницу покупки подписки.
        else:
            await message.answer("Вы поставили лайк!")
    elif reaction in ["💖 Суперлайк", "💖 Superlike"]:
        if user.subscription.lower() != "free":
            await Like.create(from_user=user, to_user=candidate, is_superlike=True)
            await message.answer("Вы поставили суперлайк!")
        else:
            await message.answer("Суперлайк доступен только при платной подписке.")
    elif reaction in ["👎🏻 Дизлайк", "👎🏻 Dislike"]:
        await message.answer("Вы дизлайкнули кандидата.")
    elif reaction in ["🚫 Заблокировать", "🚫 Block"]:
        await Block.create(from_user=user, to_user=candidate, can_message=False)
        await message.answer("Кандидат заблокирован.")
    elif reaction in ["❗ Пожаловаться", "❗ Report"]:
        # Здесь можно добавить логику обработки жалобы.
        await message.answer("Вы отправили жалобу.")
    else:
        await message.answer("Неверная команда.")

    # После обработки реакции, если реакция не связана с остановкой поиска, показываем следующего кандидата.
    await start_search(user, state, message.bot)

# -----------------------------
# Хендлер для кнопки "Начать поиск"
# -----------------------------
@router.message(F.text.in_(["🚀 Начать поиск", "🚀 Start Search"]))
async def handle_search_start(message: types.Message, state: FSMContext):
    user = await Userdb.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer(
            "<b>Профиль не найден.</b> Пожалуйста, зарегистрируйтесь с помощью команды /start."
        )
        return

    lang = user.lang or ("ru" if message.from_user.language_code == "ru" else "en")
    await state.set_state(SearchPeople.search)
    await message.answer(
        "🔎 Поиск начался! Ожидайте…" if lang == "ru" else "🔎 The search has begun! Please wait…"
    )
    await start_search(user, state, message.bot)


                [FILE] SET FOREIGN_KEY_CHECKS = 0; -- Отключаем.sql

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/bot/handlers/SET FOREIGN_KEY_CHECKS = 0; -- Отключаем.sql ---
SET FOREIGN_KEY_CHECKS = 0; -- Отключаем проверку внешних ключей

DROP TABLE IF EXISTS `users`;
DROP TABLE IF EXISTS `likes`;
DROP TABLE IF EXISTS `blocks`;
DROP TABLE IF EXISTS `statements`;
DROP TABLE IF EXISTS `aerich`; -- Если используется Aerich

SET FOREIGN_KEY_CHECKS = 1

        [DIR] data
            [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/dj_emi/src/data/__init__.py ---


[DIR] .git
    [FILE] config

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/config ---
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
	precomposeunicode = true
[remote "origin"]
	url = https://github.com/Kolotjob/emi-date.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main


    [DIR] objects
        [DIR] 61
            [FILE] 6eca87f01c968e04fb91d2f8d37995755118a6
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/61/6eca87f01c968e04fb91d2f8d37995755118a6: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 0c
            [FILE] 38622985166ae861cf9cc70c52f756372c6805
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/0c/38622985166ae861cf9cc70c52f756372c6805: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 50
            [FILE] f772cf37c57e9dcf056d6ee2cd97e0e5127883
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/50/f772cf37c57e9dcf056d6ee2cd97e0e5127883: 'utf-8' codec can't decode byte 0xa5 in position 2: invalid start byte
        [DIR] 68
            [FILE] 010f3f7496553a760ee7cbcd34972a0df7d00c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/68/010f3f7496553a760ee7cbcd34972a0df7d00c: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
            [FILE] 5e37802b919c124b2eb85b34aec6b940bbcd97
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/68/5e37802b919c124b2eb85b34aec6b940bbcd97: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 6f
            [FILE] 6874afa144a07171b135f4e6c075e28b6e4657
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/6f/6874afa144a07171b135f4e6c075e28b6e4657: 'utf-8' codec can't decode byte 0x8e in position 3: invalid start byte
        [DIR] 9b
            [FILE] a85d0f7c3834be8553d16a34971acc11f91595
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9b/a85d0f7c3834be8553d16a34971acc11f91595: 'utf-8' codec can't decode byte 0xd3 in position 6: invalid continuation byte
        [DIR] 9e
            [FILE] b54c6b7e6cc0c8f7e166326ab0f145d5c3cd55
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9e/b54c6b7e6cc0c8f7e166326ab0f145d5c3cd55: 'utf-8' codec can't decode byte 0xcd in position 4: invalid continuation byte
            [FILE] 7cfda3befed2ba56d9670c58b982de4a0dd4f5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9e/7cfda3befed2ba56d9670c58b982de4a0dd4f5: 'utf-8' codec can't decode byte 0xbe in position 8: invalid start byte
        [DIR] 04
            [FILE] f9c795736ac0a9d48dd0dc3be03af17d4135b3
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/04/f9c795736ac0a9d48dd0dc3be03af17d4135b3: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] 6a
            [FILE] 826a6b5206b3dfacecb98cd11e93193b3e06bf
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/6a/826a6b5206b3dfacecb98cd11e93193b3e06bf: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 32
            [FILE] 1359ed55d371cf522e00dc07e220646999f3fb
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/32/1359ed55d371cf522e00dc07e220646999f3fb: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte
        [DIR] 69
            [FILE] b1b039c9a2732943f638a98fe4a6b4d506639b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/69/b1b039c9a2732943f638a98fe4a6b4d506639b: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 56
            [FILE] 8f18f2a9845a6e20607669a964851f82e1cdff
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/56/8f18f2a9845a6e20607669a964851f82e1cdff: 'utf-8' codec can't decode byte 0xb3 in position 9: invalid start byte
        [DIR] 51
            [FILE] cfbf63d882ca718910854e43a86b28f39e6296
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/51/cfbf63d882ca718910854e43a86b28f39e6296: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 0b
            [FILE] 8a0bb03005df3cf0b49fd672d8205427d41ae0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/0b/8a0bb03005df3cf0b49fd672d8205427d41ae0: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 93
            [FILE] 7622e3d936090a5c53fba4b1f119e0e0f77c32
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/93/7622e3d936090a5c53fba4b1f119e0e0f77c32: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 94
            [FILE] 85c33c65a5cfd6b3c817fffcee4c0420285b1f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/94/85c33c65a5cfd6b3c817fffcee4c0420285b1f: 'utf-8' codec can't decode byte 0x92 in position 3: invalid start byte
        [DIR] 0e
            [FILE] dd7639aff628988f18396c26687069be4aa165
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/0e/dd7639aff628988f18396c26687069be4aa165: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 60
            [FILE] 384cd606551b15c473daafa011c14909868b6f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/60/384cd606551b15c473daafa011c14909868b6f: 'utf-8' codec can't decode byte 0xb4 in position 8: invalid start byte
        [DIR] 5a
            [FILE] 7af98f69218ea298c082bb52c92569c171e755
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/5a/7af98f69218ea298c082bb52c92569c171e755: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] 5f
            [FILE] 39e955fcca45d107d32d658bb6ff33fd258cd5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/5f/39e955fcca45d107d32d658bb6ff33fd258cd5: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte
        [DIR] 9d
            [FILE] abc21c73ae872aa55c4e60cb7d750443ac073d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9d/abc21c73ae872aa55c4e60cb7d750443ac073d: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
            [FILE] 20b9d5cd51552ee0d9ed0126304bb17d5d352d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9d/20b9d5cd51552ee0d9ed0126304bb17d5d352d: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
            [FILE] 1dcfdaf1a6857c5f83dc27019c7600e1ffaff8
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9d/1dcfdaf1a6857c5f83dc27019c7600e1ffaff8: 'utf-8' codec can't decode byte 0xb6 in position 8: invalid start byte
        [DIR] 9c
            [FILE] 3349a5fe8e771cac95d48b8dd8febc30f11d70
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9c/3349a5fe8e771cac95d48b8dd8febc30f11d70: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte
            [FILE] f56dc4ea10c71c63bd33cf9dd01866f9b5a57b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9c/f56dc4ea10c71c63bd33cf9dd01866f9b5a57b: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 02
            [FILE] afee2fa719e958d252ff79f23d67d751347d89
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/02/afee2fa719e958d252ff79f23d67d751347d89: 'utf-8' codec can't decode byte 0xbd in position 2: invalid start byte
            [FILE] f762f28ab9ed673cd3060b1a6b3d004c9b569a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/02/f762f28ab9ed673cd3060b1a6b3d004c9b569a: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] a4
            [FILE] 6855bd30d3663c6060a9a895691b0e0b5a8cac
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/a4/6855bd30d3663c6060a9a895691b0e0b5a8cac: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] a3
            [FILE] 3297f09a9e8e9cd8898e94e0167fbe8fe5cf52
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/a3/3297f09a9e8e9cd8898e94e0167fbe8fe5cf52: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] bb
            [FILE] 21c0672315fe1486a599508897ea658a92e15f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/bb/21c0672315fe1486a599508897ea658a92e15f: 'utf-8' codec can't decode byte 0xf1 in position 22: invalid continuation byte
        [DIR] d7
            [FILE] 13fbbb0c53f196aa5d638d26cf0bf9610a89bd
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/d7/13fbbb0c53f196aa5d638d26cf0bf9610a89bd: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] df
            [FILE] 3a05a480f7cd5b32d137353889233c22fe6def
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/df/3a05a480f7cd5b32d137353889233c22fe6def: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] ae
            [FILE] 6b0f3830f28c40fd62e587ab22c1a02337df12
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ae/6b0f3830f28c40fd62e587ab22c1a02337df12: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
        [DIR] d8
            [FILE] 8ef66d332481a00d23f9767237ee0231e84b3b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/d8/8ef66d332481a00d23f9767237ee0231e84b3b: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] e5
            [FILE] d0be848fc7143cb268bd81f16068eed27239dd
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e5/d0be848fc7143cb268bd81f16068eed27239dd: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] e2
            [FILE] f9c578f9cb6ae20c04c421d8e3ae426b25b628
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e2/f9c578f9cb6ae20c04c421d8e3ae426b25b628: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
            [FILE] 13d5cdb7b933bad81f2ddffc4c4ac79c1c173a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e2/13d5cdb7b933bad81f2ddffc4c4ac79c1c173a: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] c0
            [FILE] 5d22dbb5fa3fac50e7b4c34e50a5eadd1ec902
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c0/5d22dbb5fa3fac50e7b4c34e50a5eadd1ec902: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] c9
            [FILE] a2ee1d74ef3473c58e3dfbc2058a5fc1457e3d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c9/a2ee1d74ef3473c58e3dfbc2058a5fc1457e3d: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
        [DIR] fc
            [FILE] 63aa649cec5ae958a984a47afca6d40b23f39a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/fc/63aa649cec5ae958a984a47afca6d40b23f39a: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] fd
            [FILE] a6e763fd247cd70fe6af55fb7ead808d04c7e1
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/fd/a6e763fd247cd70fe6af55fb7ead808d04c7e1: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
        [DIR] f2
            [FILE] feed8e9d550a5aa2a66b2dc77cf8a0e7ce6b7b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f2/feed8e9d550a5aa2a66b2dc77cf8a0e7ce6b7b: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
            [FILE] 34fd6d56e016c2e97d26b84c326b7feb6a0ef2
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f2/34fd6d56e016c2e97d26b84c326b7feb6a0ef2: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] cf
            [FILE] 5044764a769064d88697d6cd9a985ff6cd17fa
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cf/5044764a769064d88697d6cd9a985ff6cd17fa: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] c1
            [FILE] 3192e01e56da992a4fa22291a34d5d258905b6
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c1/3192e01e56da992a4fa22291a34d5d258905b6: 'utf-8' codec can't decode byte 0x91 in position 3: invalid start byte
        [DIR] ec
            [FILE] 70d70f83e76f4a93a3f27b33e5ff4ba602345c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ec/70d70f83e76f4a93a3f27b33e5ff4ba602345c: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
            [FILE] 998c6cfe2c5e981c4cddf1edcf3fa83b71f1dd
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ec/998c6cfe2c5e981c4cddf1edcf3fa83b71f1dd: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
            [FILE] c42423819e9acced2e69bac2d18df6fe51ea74
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ec/c42423819e9acced2e69bac2d18df6fe51ea74: 'utf-8' codec can't decode byte 0xb0 in position 9: invalid start byte
        [DIR] 4e
            [FILE] 89459c0e6b633a928695f873c0632ce4a5f3bc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/4e/89459c0e6b633a928695f873c0632ce4a5f3bc: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 27
            [FILE] 95830ead9845dd973cb3fc1b02edff7186a0ff
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/27/95830ead9845dd973cb3fc1b02edff7186a0ff: 'utf-8' codec can't decode byte 0xb3 in position 9: invalid start byte
        [DIR] pack
        [DIR] 11
            [FILE] 52edf3fa0d9c9789fabff2b702cff767759466
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/11/52edf3fa0d9c9789fabff2b702cff767759466: 'utf-8' codec can't decode byte 0x91 in position 3: invalid start byte
        [DIR] 29
            [FILE] 08d0451a6b4bd25e183defe5d7aff92f23c02b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/29/08d0451a6b4bd25e183defe5d7aff92f23c02b: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
            [FILE] cbe8f5ed51f01a2470ca08c53052a2e94a637f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/29/cbe8f5ed51f01a2470ca08c53052a2e94a637f: 'utf-8' codec can't decode byte 0xcd in position 4: invalid continuation byte
        [DIR] 7c
            [FILE] 7892c932ceb9aa47f03af65172c919c036af1a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/7c/7892c932ceb9aa47f03af65172c919c036af1a: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
            [FILE] 17d33157b96c9e868f08c2f0ef9dda1634f0e0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/7c/17d33157b96c9e868f08c2f0ef9dda1634f0e0: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 16
            [FILE] 1d55be0255a00dcfb33dc545f8deffbfa0cff3
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/16/1d55be0255a00dcfb33dc545f8deffbfa0cff3: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 45
            [FILE] e7fcd7fe6556e4aaa5c3df75c5c5fd6330304f
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/45/e7fcd7fe6556e4aaa5c3df75c5c5fd6330304f: 'utf-8' codec can't decode byte 0xcf in position 20: invalid continuation byte
        [DIR] 1a
            [FILE] a06092e7e39629f36cc0f0f7c140d18bbc4164
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/1a/a06092e7e39629f36cc0f0f7c140d18bbc4164: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 17
            [FILE] abe132ee28bfe69d4edbd17acba5ddc9921507
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/17/abe132ee28bfe69d4edbd17acba5ddc9921507: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
            [FILE] acb067dfac37f34172c44cc8c475120eb042f0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/17/acb067dfac37f34172c44cc8c475120eb042f0: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] 8f
            [FILE] 5516207ae507e81f444653449bb4c268409bad
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/8f/5516207ae507e81f444653449bb4c268409bad: 'utf-8' codec can't decode byte 0xb2 in position 9: invalid start byte
        [DIR] 7e
            [FILE] 3e6d94fe146fc2680a20b0a117aaa01b72f873
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/7e/3e6d94fe146fc2680a20b0a117aaa01b72f873: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 10
            [FILE] dcaed500b48299671096e86d1e01caeec45922
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/10/dcaed500b48299671096e86d1e01caeec45922: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 19
            [FILE] a355399ff8fd4a89738aa17417083636baecf1
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/19/a355399ff8fd4a89738aa17417083636baecf1: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
        [DIR] 21
            [FILE] 390e6b3e9b7a82a9660b7f5596562fbd038c5c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/21/390e6b3e9b7a82a9660b7f5596562fbd038c5c: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
            [FILE] 73bc11886c10b6c8a1bdd098ca26856e55b3a7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/21/73bc11886c10b6c8a1bdd098ca26856e55b3a7: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
            [FILE] 76a093b970ce5f55037c464c6b08418f898192
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/21/76a093b970ce5f55037c464c6b08418f898192: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] 81
            [FILE] 241d6954702f470c4c8420bc8a186562a40b90
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/81/241d6954702f470c4c8420bc8a186562a40b90: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 86
            [FILE] efd2a5281ce895b1c2578dc23e0020a7ec2501
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/86/efd2a5281ce895b1c2578dc23e0020a7ec2501: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
        [DIR] 9f
            [FILE] d07816909727b7698f1095b27b24a3c13b00ce
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9f/d07816909727b7698f1095b27b24a3c13b00ce: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] 6b
            [FILE] 4bdd90643fc93bf877ae6a504b3c632ab03e34
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/6b/4bdd90643fc93bf877ae6a504b3c632ab03e34: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
            [FILE] 8f46805f29a9dd296b8a0a58dfe43f5a05e6c2
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/6b/8f46805f29a9dd296b8a0a58dfe43f5a05e6c2: 'utf-8' codec can't decode byte 0xb3 in position 9: invalid start byte
        [DIR] 07
            [FILE] bb878864fbccba366696d8162b128650517f52
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/07/bb878864fbccba366696d8162b128650517f52: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] 00
            [FILE] 73405fe55ad935fbb590aa312fed33dc85b03c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/00/73405fe55ad935fbb590aa312fed33dc85b03c: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
            [FILE] 0dcd6b909232463a5595b50e159780be20789c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/00/0dcd6b909232463a5595b50e159780be20789c: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 9a
            [FILE] 0fa1a8212ad220a62d509ee289357dfbc9f62c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/9a/0fa1a8212ad220a62d509ee289357dfbc9f62c: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
        [DIR] 36
            [FILE] e466124cfd65ae89a7d364173221cf8f6cfd2c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/36/e466124cfd65ae89a7d364173221cf8f6cfd2c: 'utf-8' codec can't decode byte 0xc8 in position 17: invalid continuation byte
        [DIR] 5c
            [FILE] 1aaad07b50f92f54caab5f11126106e93619fb
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/5c/1aaad07b50f92f54caab5f11126106e93619fb: 'utf-8' codec can't decode byte 0xce in position 18: invalid continuation byte
        [DIR] 31
            [FILE] 1fd2ad316cbb8ad3ad6ae4672163e260fbf048
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/31/1fd2ad316cbb8ad3ad6ae4672163e260fbf048: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] info
        [DIR] 91
            [FILE] 1533d365aeed0c93b0acf0cfa65cbd9e878636
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/91/1533d365aeed0c93b0acf0cfa65cbd9e878636: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 54
            [FILE] 06edc51f6f84581bcca2f236200c073105507b
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/54/06edc51f6f84581bcca2f236200c073105507b: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
        [DIR] 98
            [FILE] 65d80db456c5c4934cf854a1e97edd23a67c67
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/98/65d80db456c5c4934cf854a1e97edd23a67c67: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
            [FILE] b816f9994f378b6ec203c1b56af3bf115927a7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/98/b816f9994f378b6ec203c1b56af3bf115927a7: 'utf-8' codec can't decode byte 0xb3 in position 9: invalid start byte
        [DIR] 53
            [FILE] 3da9602d3b097714dedb191e4c7c9e4d9efbcf
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/53/3da9602d3b097714dedb191e4c7c9e4d9efbcf: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
            [FILE] f70283c7a0fe1bc215e2f1d0f6d63859f48498
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/53/f70283c7a0fe1bc215e2f1d0f6d63859f48498: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] 30
            [FILE] 6f243c4564d0aa66161262050fbc3f0712afc8
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/30/6f243c4564d0aa66161262050fbc3f0712afc8: 'utf-8' codec can't decode byte 0xf1 in position 22: invalid continuation byte
        [DIR] 5e
            [FILE] b90e7f39281327ab3f1e4ff4b0439c2b26faf5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/5e/b90e7f39281327ab3f1e4ff4b0439c2b26faf5: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 39
            [FILE] 8198302175e14eee675c15e2bf2b51ef21648a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/39/8198302175e14eee675c15e2bf2b51ef21648a: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
            [FILE] 27e56ad9902338dccccf9d8772c76730866fc9
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/39/27e56ad9902338dccccf9d8772c76730866fc9: 'utf-8' codec can't decode byte 0x92 in position 3: invalid start byte
        [DIR] 99
            [FILE] 25de5e4d3e31a36f8116df2b4c97592734188a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/99/25de5e4d3e31a36f8116df2b4c97592734188a: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] 0f
            [FILE] 9dde269911058dafa917a604e6dcc22fbdb002
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/0f/9dde269911058dafa917a604e6dcc22fbdb002: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] bf
            [FILE] 63b629e0832e0712ce6a9af0ddc511e8334ae1
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/bf/63b629e0832e0712ce6a9af0ddc511e8334ae1: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
            [FILE] 17637827cce769ee205f8d4bada91dfcf67df7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/bf/17637827cce769ee205f8d4bada91dfcf67df7: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] a0
            [FILE] 8f7e5b08279005a0d321381958da5fe989c15d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/a0/8f7e5b08279005a0d321381958da5fe989c15d: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] b8
            [FILE] bbe24011e44738a7989f9918ab25dd7c0fc8c9
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/b8/bbe24011e44738a7989f9918ab25dd7c0fc8c9: 'utf-8' codec can't decode byte 0xf1 in position 22: invalid continuation byte
        [DIR] b1
            [FILE] 9871130cde3397fa55c2c1728827b6cd5cd8e9
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/b1/9871130cde3397fa55c2c1728827b6cd5cd8e9: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
        [DIR] dd
            [FILE] b03f669af0c573510bb922c6f49b8ed632fb14
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/dd/b03f669af0c573510bb922c6f49b8ed632fb14: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
            [FILE] e58ab9c9228d94c1c9d9c5e82fd53e2e5a4639
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/dd/e58ab9c9228d94c1c9d9c5e82fd53e2e5a4639: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] dc
            [FILE] f4aa1a765f37862e733d975095b97c4a741632
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/dc/f4aa1a765f37862e733d975095b97c4a741632: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] b6
            [FILE] 52f63ceeb5616db0d7381758be00e16b40251d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/b6/52f63ceeb5616db0d7381758be00e16b40251d: 'utf-8' codec can't decode bytes in position 2-3: invalid continuation byte
        [DIR] d5
            [FILE] bba6bc68eca06c08b02bd3508757fff1d2b247
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/d5/bba6bc68eca06c08b02bd3508757fff1d2b247: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte
        [DIR] d2
            [FILE] ce36499b3dda0d5b8fc6fc5bbe9b1e912c027e
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/d2/ce36499b3dda0d5b8fc6fc5bbe9b1e912c027e: 'utf-8' codec can't decode byte 0xce in position 19: invalid continuation byte
        [DIR] b7
            [FILE] 3d84cb5f71a515c0f3a3b0d05343ee9ffe90e7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/b7/3d84cb5f71a515c0f3a3b0d05343ee9ffe90e7: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] a1
            [FILE] c86ac1a4b3d08da6177ff8538dada13ed11286
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/a1/c86ac1a4b3d08da6177ff8538dada13ed11286: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
        [DIR] c3
            [FILE] 806b620a66c6d49b434ad782e01fb242fa162d
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c3/806b620a66c6d49b434ad782e01fb242fa162d: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] c4
            [FILE] 766937cb6d28e4736ead02ef6e8d89a9dbe999
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c4/766937cb6d28e4736ead02ef6e8d89a9dbe999: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
        [DIR] ea
            [FILE] d999d516a440e1432391a0dc1693de6a8c60fb
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/ea/d999d516a440e1432391a0dc1693de6a8c60fb: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] cd
            [FILE] 19a5300d8992f1b4a85ff875afad33bc865cf7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cd/19a5300d8992f1b4a85ff875afad33bc865cf7: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
            [FILE] 813d66fe2a1edb83ec813bd46abc0dbd405000
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cd/813d66fe2a1edb83ec813bd46abc0dbd405000: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] cc
            [FILE] 6fcb7fed7105a75939c460c6aabd6a65759838
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cc/6fcb7fed7105a75939c460c6aabd6a65759838: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] e6
            [FILE] 6407638d6e2537dee45cb5a330655856b55144
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e6/6407638d6e2537dee45cb5a330655856b55144: 'utf-8' codec can't decode byte 0xf1 in position 22: invalid continuation byte
            [FILE] 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
        [DIR] f0
            [FILE] f72c9e06562db09401ea8045b0382b15f4288a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f0/f72c9e06562db09401ea8045b0382b15f4288a: 'utf-8' codec can't decode byte 0xcb in position 4: invalid continuation byte
        [DIR] e8
            [FILE] ad39d178eca07669f48e5547c41cee73c19cb3
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e8/ad39d178eca07669f48e5547c41cee73c19cb3: 'utf-8' codec can't decode byte 0xcc in position 19: invalid continuation byte
        [DIR] fa
            [FILE] bc41b26fff4a9067c6844ca8238c78c512d694
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/fa/bc41b26fff4a9067c6844ca8238c78c512d694: 'utf-8' codec can't decode byte 0xb0 in position 9: invalid start byte
        [DIR] c5
            [FILE] 0e35eb7e7e6936ff62dff42e3a4eea28547957
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c5/0e35eb7e7e6936ff62dff42e3a4eea28547957: 'utf-8' codec can't decode byte 0xb4 in position 8: invalid start byte
        [DIR] c2
            [FILE] a48dac6ee7771555fdbf7e2882f52c9629c138
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c2/a48dac6ee7771555fdbf7e2882f52c9629c138: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
            [FILE] eb54148762f2dfbe5d5a406fc8710befe21a83
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/c2/eb54148762f2dfbe5d5a406fc8710befe21a83: 'utf-8' codec can't decode bytes in position 2-3: invalid continuation byte
        [DIR] f6
            [FILE] c4136d8286ed7a1aefc7960f2cc13406a294ff
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f6/c4136d8286ed7a1aefc7960f2cc13406a294ff: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
            [FILE] 4c0a0dda24de3aa3787111adac0f7de2763bdf
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/f6/4c0a0dda24de3aa3787111adac0f7de2763bdf: 'utf-8' codec can't decode byte 0xc3 in position 6: invalid continuation byte
        [DIR] e9
            [FILE] a23b7351e956dcf5ef5940f40eb6bfef8fa5a8
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/e9/a23b7351e956dcf5ef5940f40eb6bfef8fa5a8: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
        [DIR] cb
            [FILE] 382bbeeac4f792778cbd3d2df847ae2c82ad23
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/cb/382bbeeac4f792778cbd3d2df847ae2c82ad23: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
        [DIR] 79
            [FILE] 09901bb36f68f9047b9bfb86524b960b1852ad
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/79/09901bb36f68f9047b9bfb86524b960b1852ad: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
        [DIR] 2d
            [FILE] 8c0b262ee07cd87d4cae5e69eb7ebf4d22bdd5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/2d/8c0b262ee07cd87d4cae5e69eb7ebf4d22bdd5: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
        [DIR] 41
            [FILE] 1aada76fc50a9a396da900bcf0745fc74d3d86
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/41/1aada76fc50a9a396da900bcf0745fc74d3d86: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] 1b
            [FILE] cf7bd5266b143b6773b42d5336b1cadffa6840
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/1b/cf7bd5266b143b6773b42d5336b1cadffa6840: 'utf-8' codec can't decode byte 0x91 in position 3: invalid start byte
        [DIR] 48
            [FILE] a19dfb642ff9e88c69529636c8850de553b1d0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/48/a19dfb642ff9e88c69529636c8850de553b1d0: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 1e
            [FILE] cd2bb99d9a3eb49df234bf712baa48428fbcef
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/1e/cd2bb99d9a3eb49df234bf712baa48428fbcef: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte
        [DIR] 24
            [FILE] f1856ac81f9db5c040ed835f979ee25b431af4
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/24/f1856ac81f9db5c040ed835f979ee25b431af4: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte
            [FILE] 8b435491bc0c548b3a5f3b3e262cbc8025495a
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/24/8b435491bc0c548b3a5f3b3e262cbc8025495a: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte
        [DIR] 23
            [FILE] 13797a3843de3a5048c454fd9c3d546c64ae9c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/23/13797a3843de3a5048c454fd9c3d546c64ae9c: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
        [DIR] 4f
            [FILE] 56dc1fe98c84b39dc81787052644aba25d6f87
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/4f/56dc1fe98c84b39dc81787052644aba25d6f87: 'utf-8' codec can't decode byte 0xc8 in position 17: invalid continuation byte
        [DIR] 8d
            [FILE] dc567bf866fabb7c201ec4e7f5bc5d8ffb1c23
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/8d/dc567bf866fabb7c201ec4e7f5bc5d8ffb1c23: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
            [FILE] d5a5a9302a6832875d50a7ff0379f4af3716b0
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/8d/d5a5a9302a6832875d50a7ff0379f4af3716b0: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] 15
            [FILE] 43ae6703233c87185a23de3881157dc0297180
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/15/43ae6703233c87185a23de3881157dc0297180: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] 85
            [FILE] 506ee4343a010964040c430ca06d8a9f44d5de
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/85/506ee4343a010964040c430ca06d8a9f44d5de: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
        [DIR] 1d
            [FILE] d3252a3ccf409f82cb203dd0ef098e03b8f4a5
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/1d/d3252a3ccf409f82cb203dd0ef098e03b8f4a5: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
        [DIR] 40
            [FILE] 3a3aa7af7609c5127020a6b8fa99358ee93c4c
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/40/3a3aa7af7609c5127020a6b8fa99358ee93c4c: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte
            [FILE] a91dd036e7a64733156515fd4320060fcd06ea
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/40/a91dd036e7a64733156515fd4320060fcd06ea: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
        [DIR] 7f
            [FILE] 86e39aa2b4399ca085972d929987e18bfbe9a9
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/7f/86e39aa2b4399ca085972d929987e18bfbe9a9: 'utf-8' codec can't decode byte 0x85 in position 15: invalid start byte
        [DIR] 14
            [FILE] 38c01a74e6a5b774a68609f4f3957964b522a7
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/14/38c01a74e6a5b774a68609f4f3957964b522a7: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
            [FILE] 2066071676f004de4f568d8b8de0e8965f3c01
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/14/2066071676f004de4f568d8b8de0e8965f3c01: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
        [DIR] 8e
            [FILE] 43a26b08a7ab41d24e63142978cd3008599614
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/8e/43a26b08a7ab41d24e63142978cd3008599614: 'utf-8' codec can't decode byte 0xcc in position 19: invalid continuation byte
        [DIR] 22
            [FILE] d5ed30217761c3b700c180dfbe4909d1bed401
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/objects/22/d5ed30217761c3b700c180dfbe4909d1bed401: 'utf-8' codec can't decode byte 0x91 in position 3: invalid start byte
    [FILE] HEAD

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/HEAD ---
ref: refs/heads/main


    [DIR] info
        [FILE] exclude

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/info/exclude ---
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~


    [DIR] logs
        [FILE] HEAD

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/logs/HEAD ---
0000000000000000000000000000000000000000 142066071676f004de4f568d8b8de0e8965f3c01 kolotjob <jobkolot@gmail.com> 1736031501 +0330	commit (initial): structura
142066071676f004de4f568d8b8de0e8965f3c01 cf5044764a769064d88697d6cd9a985ff6cd17fa kolotjob <jobkolot@gmail.com> 1736597546 +0330	commit: updates
cf5044764a769064d88697d6cd9a985ff6cd17fa dcf4aa1a765f37862e733d975095b97c4a741632 kolotjob <jobkolot@gmail.com> 1736803972 +0100	commit: add functions
dcf4aa1a765f37862e733d975095b97c4a741632 8dd5a5a9302a6832875d50a7ff0379f4af3716b0 kolotjob <jobkolot@gmail.com> 1736814206 +0100	commit: add editig profile
8dd5a5a9302a6832875d50a7ff0379f4af3716b0 398198302175e14eee675c15e2bf2b51ef21648a kolotjob <jobkolot@gmail.com> 1736876885 +0100	commit: ddd
398198302175e14eee675c15e2bf2b51ef21648a 411aada76fc50a9a396da900bcf0745fc74d3d86 kolotjob <jobkolot@gmail.com> 1736889885 +0100	commit: hggj


        [DIR] refs
            [DIR] heads
                [FILE] main

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/logs/refs/heads/main ---
0000000000000000000000000000000000000000 142066071676f004de4f568d8b8de0e8965f3c01 kolotjob <jobkolot@gmail.com> 1736031501 +0330	commit (initial): structura
142066071676f004de4f568d8b8de0e8965f3c01 cf5044764a769064d88697d6cd9a985ff6cd17fa kolotjob <jobkolot@gmail.com> 1736597546 +0330	commit: updates
cf5044764a769064d88697d6cd9a985ff6cd17fa dcf4aa1a765f37862e733d975095b97c4a741632 kolotjob <jobkolot@gmail.com> 1736803972 +0100	commit: add functions
dcf4aa1a765f37862e733d975095b97c4a741632 8dd5a5a9302a6832875d50a7ff0379f4af3716b0 kolotjob <jobkolot@gmail.com> 1736814206 +0100	commit: add editig profile
8dd5a5a9302a6832875d50a7ff0379f4af3716b0 398198302175e14eee675c15e2bf2b51ef21648a kolotjob <jobkolot@gmail.com> 1736876885 +0100	commit: ddd
398198302175e14eee675c15e2bf2b51ef21648a 411aada76fc50a9a396da900bcf0745fc74d3d86 kolotjob <jobkolot@gmail.com> 1736889885 +0100	commit: hggj


            [DIR] remotes
                [DIR] origin
                    [FILE] main

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/logs/refs/remotes/origin/main ---
0000000000000000000000000000000000000000 142066071676f004de4f568d8b8de0e8965f3c01 kolotjob <jobkolot@gmail.com> 1736031505 +0330	update by push
142066071676f004de4f568d8b8de0e8965f3c01 cf5044764a769064d88697d6cd9a985ff6cd17fa kolotjob <jobkolot@gmail.com> 1736597547 +0330	update by push
cf5044764a769064d88697d6cd9a985ff6cd17fa dcf4aa1a765f37862e733d975095b97c4a741632 kolotjob <jobkolot@gmail.com> 1736803975 +0100	update by push
dcf4aa1a765f37862e733d975095b97c4a741632 8dd5a5a9302a6832875d50a7ff0379f4af3716b0 kolotjob <jobkolot@gmail.com> 1736814208 +0100	update by push
8dd5a5a9302a6832875d50a7ff0379f4af3716b0 398198302175e14eee675c15e2bf2b51ef21648a kolotjob <jobkolot@gmail.com> 1736876887 +0100	update by push
398198302175e14eee675c15e2bf2b51ef21648a 411aada76fc50a9a396da900bcf0745fc74d3d86 kolotjob <jobkolot@gmail.com> 1736889889 +0100	update by push


    [FILE] description

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/description ---
Unnamed repository; edit this file 'description' to name the repository.


    [DIR] hooks
        [FILE] commit-msg.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/commit-msg.sample ---
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}


        [FILE] pre-rebase.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-rebase.sample ---
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END


        [FILE] pre-commit.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-commit.sample ---
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --


        [FILE] applypatch-msg.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/applypatch-msg.sample ---
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:


        [FILE] fsmonitor-watchman.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/fsmonitor-watchman.sample ---
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}


        [FILE] pre-receive.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-receive.sample ---
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi


        [FILE] prepare-commit-msg.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/prepare-commit-msg.sample ---
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi


        [FILE] post-update.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/post-update.sample ---
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info


        [FILE] pre-merge-commit.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-merge-commit.sample ---
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:


        [FILE] pre-applypatch.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-applypatch.sample ---
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:


        [FILE] pre-push.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/pre-push.sample ---
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0


        [FILE] update.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/update.sample ---
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0


        [FILE] push-to-checkout.sample

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/hooks/push-to-checkout.sample ---
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi


    [DIR] refs
        [DIR] heads
            [FILE] main

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/refs/heads/main ---
411aada76fc50a9a396da900bcf0745fc74d3d86


        [DIR] tags
        [DIR] remotes
            [DIR] origin
                [FILE] main

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/refs/remotes/origin/main ---
411aada76fc50a9a396da900bcf0745fc74d3d86


    [FILE] index
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/index: 'utf-8' codec can't decode byte 0xb1 in position 15: invalid start byte
    [FILE] COMMIT_EDITMSG

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/.git/COMMIT_EDITMSG ---
hggj


[FILE] __main__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/__main__.py ---
from aiogram import Bot, Dispatcher
from tortoise import Tortoise
import asyncio
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode

# Импортируем конфигурацию базы данных
from config import BOT_TOKEN, TORTOISE_ORM
from src.bot.handlers.registration import router as registration_router
from src.bot.handlers.anketa import router as anketa_router
from aiogram.exceptions import TelegramBadRequest
from src.utils.middleware import LoggingMiddleware, CallbackMiddleware
from src.utils.album import AlbumMiddleware, groupmedia, router as router_album
from src.utils.comands import router as router_comands
from aerich import Command
from src.bot.handlers.myprofile import router as myprofile_router
from src.bot.handlers.edit_profile import router as edit_profile_router
from src.bot.handlers.serch import router as search_router


# async def delete_webhook(bot: Bot):
#     try:
#         await bot.delete_webhook(drop_pending_updates=True)
#         print("Webhook successfully deleted.")
#     except TelegramBadRequest as e:
#         if "Not Found" in str(e):
#             print("Webhook is not set or already deleted.")
#         else:
#             print(f"Failed to delete webhook: {e}")
# Функция для инициализации базы данных
async def init_db():
    try:
        command = Command(
            tortoise_config=TORTOISE_ORM,
            app="models",
            location="./migrations"
        )
        await command.init()
        await command.upgrade()
        print("Database migrations applied successfully.")
    except Exception as e:
        print(f"Error while applying migrations: {e}")
    try:
        await Tortoise.init(config=TORTOISE_ORM)
        await Tortoise.generate_schemas()
        
        print("Database connection established and schemas generated.")
    except Exception as e:
        print(f"Error connecting to the database: {e}")

# Основной цикл бота
async def main():
    bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    dp = Dispatcher()
    dp.message.middleware(LoggingMiddleware())
    dp.callback_query.middleware(CallbackMiddleware())
    dp.message.middleware(AlbumMiddleware(groupmedia_handler=groupmedia))  # Пер
    # Подключаем маршруты (обработчики)
    dp.include_routers(registration_router,search_router, anketa_router, router_album, myprofile_router,router_comands, edit_profile_router)

    # Инициализируем базу данных
    await init_db()

    print("Bot is running...")
    try:
        # await delete_webhook(bot)
        await dp.start_polling(bot)
    finally:
        # Закрываем соединение с базой данных
        await Tortoise.close_connections()

# Запуск бота
if __name__ == "__main__":
    asyncio.run(main())


[DIR] src
    [FILE] models.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/models.py ---
from tortoise.models import Model
from tortoise import fields



class User(Model):
    user_id = fields.BigIntField(pk=True, unique=True)  # Уникальный Telegram ID пользователя
    uid_code = fields.CharField(max_length=50, unique=True)  # Уникальный код пользователя
    status_block = fields.CharField(max_length=255, default="Active")  # Статус (например, "Active", "Blocked")
    name = fields.CharField(max_length=50, null=True)  # Имя
    age = fields.IntField(null=True)  # Возраст
    orientation = fields.CharField(max_length=255, null=True)
    gender = fields.CharField(max_length=10, null=True)  # Пол (например, "male", "female", "other")
    medias = fields.JSONField(null=True)  # Ссылки на медиа (фото/видео)
    about = fields.TextField(null=True)  # Описание "О себе"
    location = fields.CharField(max_length=255, null=True)  # Локация
    preferences = fields.CharField(max_length=255, null=True)  # Кого ищет (например, "friends", "relationship")
    hobbies = fields.JSONField(null=True)  # Список увлечений (до 5)
    for_whom = fields.CharField(max_length=255, null=True)  # Кого показывать (например, "all", "man" , 'girl')
    subscription = fields.CharField(max_length=50, default="Free") 
    localstatus = fields.CharField(max_length=50, default="active") 

     # Тариф подписки (например, "Free", "Premium")
    subscription_start = fields.DatetimeField(null=True)  # Дата начала подписки (только для платных)
    subscription_end = fields.DatetimeField(null=True)  # Дата окончания подписки
    referral_uid = fields.CharField(max_length=50, unique=True, null=True)  # Telegram ID реферера
    balance = fields.DecimalField(max_digits=10, decimal_places=2, default=0.0)  # Баланс
    level = fields.DecimalField(max_digits=5, decimal_places=2, default=0.0)  # % от реферальной программы
    date_registered = fields.DatetimeField(auto_now_add=True)  # Дата регистрации
    lang = fields.CharField(max_length=50, default="nochoise") #язык поользователя
    class Meta:
        table = "users"





class Like(Model):
    like_id = fields.IntField(pk=True)  # Уникальный ID лайка
    from_user = fields.ForeignKeyField("models.User", related_name="sent_likes")  # Кто лайкнул
    to_user = fields.ForeignKeyField("models.User", related_name="received_likes")  # Кто получил лайк
    is_superlike = fields.BooleanField(default=False)  # Это суперлайк или обычный лайк
    message = fields.TextField(null=True)  # Сообщение, если было отправлено
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата создания лайка

    class Meta:
        table = "likes"


class Block(Model):
    block_id = fields.IntField(pk=True)  # Уникальный ID блокировки
    from_user = fields.ForeignKeyField("models.User", related_name="blocked_users")  # Кто заблокировал
    to_user = fields.ForeignKeyField("models.User", related_name="blocked_by")  # Кто заблокирован
    can_message = fields.BooleanField(default=False)  # Разрешены ли сообщения
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата блокировки

    class Meta:
        table = "blocks"


class Statement(Model):
    statement_id = fields.IntField(pk=True)  # Уникальный ID записи
    user = fields.ForeignKeyField("models.User", related_name="statements")  # Пользователь
    referral_count = fields.IntField(default=0)  # Количество рефералов
    subscription_level = fields.CharField(max_length=20, default="basic")  # Уровень подписки
    price = fields.DecimalField(max_digits=10, decimal_places=2, default=0.0)  # Цена подписки/транзакции
    referral_percentage = fields.DecimalField(max_digits=5, decimal_places=2, default=0.0)  # Процент отчислений за реферал
    payment_method = fields.CharField(max_length=50, null=True)  # Метод оплаты (например, "card", "paypal")
    transaction_id = fields.CharField(max_length=255, null=True)  # Уникальный ID транзакции
    status = fields.CharField(max_length=20, default="pending")  # Статус транзакции (успешно, ошибка)
    created_at = fields.DatetimeField(auto_now_add=True)  # Дата создания записи

    class Meta:
        table = "statements"


    [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/__init__.py ---


    [DIR] utils
        [FILE] generate_uid.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/generate_uid.py ---
import random
import string

async def generate_uid_code(uids ):
    length=5
    uid=""
    while uid =="":

        """
        Генерирует уникальный код указанной длины, содержащий латинские заглавные и строчные буквы и цифры.

        :param length: Длина кода (по умолчанию 5).
        :return: Сгенерированный код.
        """
        characters = string.ascii_letters + string.digits  # Латинские буквы (верхний и нижний регистр) + цифры
        x_code=''.join(random.choices(characters, k=length))
        if x_code not in uids:
            uid = x_code
        else:
            continue
    return uid

# Пример использования



        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__init__.py ---


        [DIR] __pycache__
            [FILE] album.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/album.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] generate_uid.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/generate_uid.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] state.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/state.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] comands.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/comands.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] add_profile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/add_profile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] middleware.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/__pycache__/middleware.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] album.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/album.py ---
from aiogram import BaseMiddleware, types
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from typing import Callable, Awaitable, Dict, Any, List, Optional
from cachetools import TTLCache
from asyncio import sleep
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType
from src.utils.comands import set_user_specific_commands


DEFAULT_LATENCY = 0.2
DEFAULT_TTL = 0.600

router = Router()
# Middleware для обработки меди-альбомов
class AlbumMiddleware(BaseMiddleware):
    def __init__(
        self,
        groupmedia_handler: Callable[[Message, List[Dict[str, str]], List[int]], Awaitable[Any]],
        latency: float = DEFAULT_LATENCY,
        ttl: float = DEFAULT_TTL,
    ) -> None:
        super().__init__()
        self.groupmedia_handler = groupmedia_handler
        self.latency = latency
        self.cache: TTLCache = TTLCache(maxsize=10_000, ttl=ttl)

    @staticmethod
    async def get_media_data(message: Message) -> Optional[Dict[str, str]]:
        if message.photo:
            return {"file_id": message.photo[-1].file_id, "type": "photo", "message_id": message.message_id}
        if message.video:
            return {"file_id": message.video.file_id, "type": "video", "message_id": message.message_id}
        return None

    async def __call__(
        self,
        handler: Callable[[types.TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: types.TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        if isinstance(event, Message) and event.media_group_id is not None:
            state: FSMContext = data.get("state")

            if not state:
                return await handler(event, data)

            current_state: Optional[State] = await state.get_state()

            # Проверяем, находится ли пользователь в состоянии RegState.media
            if current_state != "RegState:media":
                return 403

            key = event.media_group_id
            media_data = await self.get_media_data(event)

            if not media_data:
                return await handler(event, data)

            # Если альбом уже собирается, добавляем текущий файл
            if key in self.cache:
                self.cache[key]["media_data"].append(media_data)
                return None

            # Создаем новый альбом в кэше
            self.cache[key] = {
                "media_data": [media_data]
            }

            # Ждем, пока все части альбома дойдут
            await sleep(self.latency)

            # Передаем собранный альбом и message_id для удаления в groupmedia_handler
            media_data_list = self.cache.pop(key)["media_data"]
            message_ids = [media["message_id"] for media in media_data_list]
            return await self.groupmedia_handler(event, media_data_list, message_ids, state)

        return await handler(event, data)
    




# Функция для обработки одиночного медиа
@router.message(RegState.media)
async def set_media(message: types.Message, user: User, state: FSMContext, lang: str):
    if message.media_group_id is None and (message.photo or message.video):  
        # Проверяем одиночные фото/видео
        if user:
            media = user.medias or []
            if len(media) < 3:
                media_data = {
                    "file_id": message.photo[-1].file_id if message.photo else message.video.file_id,
                    "type": "photo" if message.photo else "video"
                }
                await message.bot.delete_message(message.from_user.id, message.message_id)
                media.append(media_data)
                user.medias = media
                await user.save()

                

                # Обновляем сообщение прогресса
                data = await state.get_data()
                msg_id = None
                if "idmsg_media" in data:
                    msg_id=data["idmsg_media"]
                count = len(media)
                if count ==3:
                    txt = (
                    f"Сохранено {count}/3 медиа. Нажмите 'Сохранить'." 
                    if lang == "ru" 
                    else f"Saved {count}/3 media. Click 'Save'."
                )
                else:   
                    txt = (
                        f"Сохранено {count}/3 медиа. Отправьте ещё одно или нажмите 'Сохранить'." 
                        if lang == "ru" 
                        else f"Saved {count}/3 media. Send another one or click 'Save'."
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="Сохранить ✅" if lang == "ru" else "Save ✅", callback_data="save_album")]
                ])

                if msg_id:
                    try:
                        await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
                    except:
                        sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                        await state.update_data(idmsg_media=sent_message.message_id)
                else:
                    sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                    await state.update_data(idmsg_media=sent_message.message_id)
            else:
                txt = "Вы уже отправили максимальное количество медиа! 📸" if lang == "ru" else "You have already sent the maximum amount of media! 📸"
                await message.answer(txt)

# Функция для обработки меди-альбомов
async def groupmedia(message: Message, media_data_list: List[Dict[str, str]], message_ids , state: FSMContext):
    
    chat_id = message.chat.id  # Или используйте другой chat_id, если нужно
    print(message_ids)
    # Проверяем количество файлов в базе данных
    for id in message_ids:
        await message.bot.delete_message(message.from_user.id, id)
    user = await User.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer("Ошибка: пользователь не найден.")
        return
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Сохранить ✅" if user.lang == "ru" else "Save ✅", callback_data="save_album")]
    ])
    existing_files = user.medias or []

    # Если уже есть 2 файла, добавляем только первый файл из альбома
    if len(existing_files) == 2:
        existing_files.append(media_data_list[0])
        user.medias = existing_files
        await user.save()

        # Удаляем сообщение с медиа

        # Обновляем сообщение прогресса
        txt = (
            "Сохранён только первый файл из альбома. Теперь у вас 3/3 медиа. Нажмите 'Сохранить'." 
            if user.lang == "ru" 
            else "Only the first file from the album has been saved. You now have 3/3 media. Click 'Save'."
        )
        data = await state.get_data()
        msg_id = None
        if "idmsg_media" in data:
            msg_id=data["idmsg_media"]

        if msg_id:
            try:
                await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
            except:
                sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                await state.update_data(idmsg_media=sent_message.message_id)
        else:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
        return

    # Если альбом содержит больше 3 файлов, сохраняем только первые 3
    if len(existing_files) + len(media_data_list) > 3:
        remaining_slots = 3 - len(existing_files)
        existing_files.extend(media_data_list[:remaining_slots])
        user.medias = existing_files
        await user.save()

        # Удаляем сообщение с медиа
        # await message.delete()

        # Обновляем сообщение прогресса
        txt = (
            f"Сохранены только первые {remaining_slots} файла из альбома. Теперь у вас 3/3 медиа. Нажмите 'Сохранить'."
            if user.lang == "ru" 
            else f"Only the first {remaining_slots} files from the album have been saved. You now have 3/3 media. Click 'Save'."
        )
        data = await state.get_data()
        msg_id = None
        if "idmsg_media" in data:
            msg_id=data["idmsg_media"]

        if msg_id:
            try:
                await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
            except:
                sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
                await state.update_data(idmsg_media=sent_message.message_id)
        else:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
        return

    # Если всё в порядке, сохраняем весь альбом
    existing_files.extend(media_data_list)
    user.medias = existing_files
    await user.save()

    # Удаляем сообщение с медиа

    # Обновляем сообщение прогресса
    if existing_files==3:
        txt = (
        f"Сохранено {len(existing_files)}/3 медиа. Нажать 'Сохранить'."
        if user.lang == "ru" 
        else f"Saved {len(existing_files)}/3 media. Click 'Save'."
    )
    else:
        txt = (
            f"Сохранено {len(existing_files)}/3 медиа. Можете отправить ещё одно или нажать 'Сохранить'."
            if user.lang == "ru" 
            else f"Saved {len(existing_files)}/3 media. You can send another one or click 'Save'."
        )

    

    # await message.answer(txt, reply_markup=keyboard)÷
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]

    if msg_id:
        try:
            await message.bot.edit_message_text(chat_id=message.chat.id, message_id=msg_id, text=txt, reply_markup=keyboard)
        except:
            sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await message.bot.send_message(chat_id=message.chat.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)


def create_start_search_keyboard(lang: str) -> ReplyKeyboardMarkup:
    """
    Создает клавиатуру с кнопкой "Начать поиск" на русском или английском языке.

    :param lang: Язык клавиатуры ('ru' или 'en').
    :return: Объект ReplyKeyboardMarkup.
    """
    if lang == "ru":
        button_text = "🚀 Начать поиск"
    else:
        button_text = "🚀 Start Search"

    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=button_text)]
        ],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    return keyboard

@router.callback_query(lambda c: "skip_album" in c.data, RegState.media)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    # print()
    await state.set_state(RegState.done)
    media = user.medias or []
    file_id='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'
    media_data = {
                    "file_id": file_id,
                    "type": "photo" 
                }
    media.append(media_data)
    user.medias = media
    await user.save()
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]
    txt='''🎉 <b>Профиль успешно заполнен! ✅</b>  

Теперь вы готовы начать находить интересных людей! 🌟  
➡️ Используйте меню внизу и нажмите "Начать поиск", чтобы приступить.  
Удачи! 🍀''' if lang == 'ru' else '''🎉 <b>Profile successfully completed! ✅</b>  

You’re now ready to start finding interesting people! 🌟  
➡️ Use the menu below and tap "Start Search" to begin.  
Good luck! 🍀
'''

    keyboard = create_start_search_keyboard(lang)
    await set_user_specific_commands(callback_query.bot, callback_query.from_user.id, lang )

    if msg_id:
        try:
            await callback_query.bot.edit_message_text(chat_id=callback_query.from_user.id, message_id=msg_id, text=txt, reply_markup=keyboard)
        except:
            sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
            await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)


@router.callback_query(lambda c: "save_album" in c.data, RegState.media)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
    await state.set_state(RegState.done)
    data = await state.get_data()
    msg_id = None
    if "idmsg_media" in data:
        msg_id=data["idmsg_media"]
    txt='''🎉 <b>Профиль успешно заполнен! ✅</b>  

Теперь вы готовы начать находить интересных людей! 🌟  
➡️ Используйте меню внизу и нажмите "Начать поиск", чтобы приступить.  
Удачи! 🍀''' if lang == 'ru' else '''🎉 <b>Profile successfully completed! ✅</b>  

You’re now ready to start finding interesting people! 🌟  
➡️ Use the menu below and tap "Start Search" to begin.  
Good luck! 🍀
'''

    keyboard = create_start_search_keyboard(lang)
    await set_user_specific_commands(callback_query.bot, callback_query.from_user.id, lang )
    if msg_id:
        try:
            try:
                await callback_query.message.edit_reply_markup(reply_markup=None)
                sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)

            except:
                await callback_query.message.delete()
                sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
                
                
        except:
            sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)
    else:
        sent_message = await callback_query.bot.send_message(chat_id=callback_query.from_user.id, text=txt, reply_markup=keyboard)
        await state.update_data(idmsg_media=sent_message.message_id)

        [FILE] comands.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/comands.py ---
from aiogram import Bot, Dispatcher, types
from aiogram.types import BotCommand, BotCommandScopeChat
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType


router = Router()



@router.message(Command("lang"))
async def set_name(message: types.Message, state: FSMContext, lang: str):
    user = await User.get_or_none(user_id=message.from_user.id)
    if user.lang:
        if user.lang=="ru":
            lang='en'
            user.lang=lang
            await user.save()
        else:
            lang='ru'
            user.lang=lang
            await user.save()
        await set_user_specific_commands(message.bot, message.from_user.id, lang)
        if lang == "ru":
            button_text = "🚀 Начать поиск"
        else:
            button_text = "🚀 Start Search"

        keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text=button_text)]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        txt ="""Вы измменили язык ✅
        
ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль.""" if lang=='ru' else"""You have changed the language ✅

ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."""

        await message.answer(txt, reply_markup=keyboard)





async def set_user_specific_commands(bot:Bot, user_id, lang):
    # Определяем команды для пользователя
    user_specific_commands = [
        
        BotCommand(command="myprofile", description="Профиль" if lang=='ru' else "Profile"),
        BotCommand(command="help", description="Помощь"if lang=='ru' else "Help"),
        BotCommand(command="subs", description="Подписка" if lang=='ru' else "Subscription"),
        BotCommand(command="ref", description="Реф. программа" if lang=='ru' else "Ref. program"),
        BotCommand(command="lang", description="Изменить язык" if lang=='ru' else "Change language")
    ]

    # Устанавливаем команды только для указанного пользователя
    await bot.set_my_commands(
        commands=user_specific_commands,
        scope=BotCommandScopeChat(chat_id=user_id)
    )

async def delete_user_specific_commands(bot: Bot, user_id: int):
    """
    Удаляет команды, установленные для конкретного пользователя.
    """
    await bot.delete_my_commands(
        scope=BotCommandScopeChat(chat_id=user_id)
    )

        [FILE] add_profile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/add_profile.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.types import InputMediaPhoto, InputMediaVideo
from src.utils.state import RegState
from src.utils.comands import set_user_specific_commands, delete_user_specific_commands

async def add_profile(message: types.Message, state: FSMContext, lang: str, user: User):
    if user:
        # Если имя не указано
        if user.name is None:
            txt = (
                "<b>🎉</b>\nТеперь давай настроим твой профиль, чтобы ты мог(ла) быстрее найти интересных людей. 🌟\n\n➡️ Укажи свое имя, чтобы мы могли начать!"
                if lang == "ru" else
                "<b>🎉</b>\nNow let’s set up your profile so you can start meeting interesting people faster. 🌟\n\n➡️ Please provide your name to get started!"
            )
            await state.set_state(RegState.name)
            await message.answer(txt)
            return

        # Если имя указано, но пол не выбран
        if user.gender is None:
            txt = (
                f"<b>Отлично,{user.name}</b>\nТеперь укажи свой пол! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                f"<b>Great,{user.name}</b>\nNow specify your gender! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другой" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.gender)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если пол указан, но ориентация не выбрана
        if user.orientation is None:
            txt = (
                "Теперь укажи свою ориентацию! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                "Now specify your orientation! 🌟\n\n➡️ Choose one of the options:"
            )
            if user.gender == 'mal':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'fem':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'oth':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если ориентация указана, но не указаны предпочтения для просмотра
        if user.for_whom is None:
            txt = (
"Теперь укажи, кого ты хочешь видеть! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
"Now specify who you want to see! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_girls")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_boys")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_everyone")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await message.answer(txt, reply_markup=keyboard)
            return
        # Если предпочтения для просмотра указаны, но возраст не указан
        elif user.age is None:
            txt = (
                "Теперь укажи свой возраст! 🌟\n\n➡️ Введите ваш возраст (минимум 16 лет):"
                if lang == "ru" else
                "Now specify your age! 🌟\n\n➡️ Enter your age (minimum 16 years):"
            )
            await state.set_state(RegState.age)
            await message.answer(txt)
            return
        # Если все данные собраны, переходим к следующему шагу
        if user.preferences is None:
            txt = (
                "Теперь укажи свои цели! 🌟\n\n➡️ Выбери цели из предложенных вариантов:"
                if lang == "ru" else
                "Now specify your goals! 🌟\n\n➡️ Choose your goals from the options provided:"
            )
            inline_keyboard=[]
            if lang =="ru":
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
            else:
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.preferences)
            await message.answer(txt, reply_markup=keyboard)
            return
        if user.location is None:

            keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )

            if lang == "ru":
                txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
            else:
                txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

            await state.set_state(RegState.location)
            msg = await message.bot.send_message(message.from_user.id ,text=txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)
            return
        if user.about is None:
            if lang == "ru":
                txt = """
Теперь расскажи немного о себе. 🌟

➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
"""
            else:
                txt = """
Now tell us a bit about yourself. 🌟

➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
"""
            await state.set_state(RegState.about)
            await message.bot.send_message(message.from_user.id, txt)
            return
        if user.hobbies is None:
            state_data = await state.get_data()
            current_page = state_data.get("current_page", 1)
            hobbies = state_data.get("selected_hobbies", [])  # Загружаем хобби из состояния или базы

            if len(hobbies) < 5:
                await state.set_state(RegState.hobbies)

                # Увлечения на двух языках с номерами
                interests = [
                    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
                    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
                    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
                    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
                    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
                    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
                    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
                    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
                    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
                    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
                    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
                    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
                    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
                    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
                    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
                    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
                ]
                page_size = 10
                start_index = (current_page - 1) * page_size
                end_index = start_index + page_size

                # Генерация кнопок для текущей страницы
                inlinekeyboard = []
                row = []

                for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
                    text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
                    row.append(InlineKeyboardButton(
                        text=text,
                        callback_data=f"intrs_{number}"
                    ))
                    if len(row) == 2 or i == len(interests[start_index:end_index]):
                        inlinekeyboard.append(row)
                        row = []

                # Добавляем кнопки навигации
                navigation_buttons = []
                if current_page > 1:
                    navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
                if end_index < len(interests):
                    navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
                if navigation_buttons:
                    inlinekeyboard.append(navigation_buttons)

                if len(hobbies) == 5:
                    inlinekeyboard.append(
                        [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)

                if lang == "ru":
                    if hobbies:
                        txt = f"<b>У вас уже выбрано {len(hobbies)}/5 увлечений ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми \"<b>Сохранить✅</b>\"."
                else:
                    if hobbies:
                        txt = f"<b>You have already selected {len(hobbies)}/5 hobbies ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\"."

                await state.update_data(current_page=current_page, hobbies=hobbies)  # Сохраняем данные в состояние
                await message.answer(txt, reply_markup=keyboard)
                return


        if user.medias is None:

            txt = """

Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """

Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
Or press "Skip" to continue. ⏩"""
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
            ])
            await state.set_state(RegState.media)
            data = await state.get_data()

            msg = await message.bot.send_message(chat_id=message.from_user.id, text=txt, reply_markup=keyboard)
            data["idmsg_media"] = msg.message_id
            await state.update_data(data=data)
            return
        else:
            
            if lang == "ru":
                button_text = "🚀 Начать поиск"
            else:
                button_text = "🚀 Start Search"

            keyboard = ReplyKeyboardMarkup(
                keyboard=[
                    [KeyboardButton(text=button_text)]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            )
            await set_user_specific_commands(message.bot, message.from_user.id, lang )
            response = (
        "ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль." 
        if lang == "ru" 
        else "ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."
    )
            await message.answer(response, reply_markup=keyboard)

            

        [FILE] middleware.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/middleware.py ---
import logging
from aiogram import BaseMiddleware, types
from aiogram.types import Update
from typing import Callable, Any, Awaitable
from aiogram.fsm.context import FSMContext
from src.models import User
from aiogram.types import CallbackQuery
from src.utils.generate_uid import generate_uid_code
from src.bot.handlers.registration import choise_lang


class LoggingMiddleware(BaseMiddleware):
    """
    Middleware for logging all incoming updates and outgoing responses,
    ensuring user profile completeness and language setup.
    """

    async def __call__(
        self,
        handler: Callable[[Update, dict], Awaitable[Any]],
        event: Update,
        data: dict,
    ) -> Any:
        # Логируем входящее событие
        logging.info(f"Incoming update: {event}")
        state: FSMContext
        state: FSMContext = data.get("state")  # FSMContext передается через data
        current_state = await state.get_state() if state else None
        # Получаем user_id из обновления
        user_id = event.from_user.id if event.from_user else None

        if user_id:
            # Проверяем, существует ли пользователь в базе данных
            user = await User.get_or_none(user_id=user_id)
            if user:
                if user.status_block == "Active":
                    data["user"] = user
                    
                    # Устанавливаем язык
                    if user.lang == "nochoise":
                        data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                        return await choise_lang(event, data)
                    else:
                        data["lang"] = user.lang

                    # Проверка на полноту профиля
                    
                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias
                    ]) and event.text and ("/start" not in event.text and "/del" not in event.text) and current_state is None:
                        message_text = (
                            "Кажется, ваш профиль заполнен не до конца. \u2028"
                            "Нажмите /start, чтобы заполнить профиль и скорее приступить к поиску нужных людей."
                            if user.lang == "ru" else
                            "It seems your profile is incomplete. \u2028"
                            "Press /start to complete your profile and start connecting with people."
                        )
                        if isinstance(event, types.Message):
                            await event.answer(message_text)
                        return
                else:
                    # Если пользователь заблокирован, возвращаем статус 403
                    if isinstance(event, types.Message):
                        await event.answer("Ваш аккаунт заблокирован." if user.lang == "ru" else "Your account is blocked.")
                    return 403
            else:
                # Новый пользователь
                uid_ref = None
                if event.text and "/start" in event.text:
                    parts = event.text.split(" ")
                    if len(parts) > 1:
                        uid_ref = parts[1]
                        ref_user = await User.get_or_none(uid_code=uid_ref)
                        if ref_user:
                            if ref_user.lang == "ru":
                                await event.bot.send_message(ref_user.user_id, "У вас новый реферал")
                            else:
                                await event.bot.send_message(ref_user.user_id, "You have a new referral")

                # Генерация UID
                users = await User.all().values_list("uid_code", flat=True)
                uid = await generate_uid_code(uids=users)

                # Создание нового пользователя
                user = await User.create(user_id=user_id, uid_code=uid, referral_uid=uid_ref)
                data["user"] = user
                data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                return await choise_lang(event, data)

        # Передаём управление следующему обработчику
        response = await handler(event, data)

        # Логируем ответ
        logging.info(f"Outgoing response: {response}")

        return response




class CallbackMiddleware(BaseMiddleware):
    """
    Middleware для обработки callback-запросов.
    Проверяет статус пользователя и передаёт язык пользователя.
    """

    async def __call__(
        self,
        handler: Callable[[CallbackQuery, dict], Awaitable[Any]],
        event: CallbackQuery,
        data: dict,
    ) -> Any:
        # Логируем входящее событие
        logging.info(f"Incoming callback query: {event}")

        # Получаем user_id из callback
        user_id = event.from_user.id if event.from_user else None

        if user_id:
            # Проверяем, существует ли пользователь в базе данных
            user = await User.get_or_none(user_id=user_id)
            if user:
                if user.status_block == "Active":
                    data["user"] = user
                    data["lang"] = user.lang or ("ru" if event.from_user.language_code in ["ru", "uk"] else "en")
                else:
                    # Если пользователь заблокирован, отправляем сообщение и возвращаем статус 403
                    await event.answer("Ваш аккаунт заблокирован.", show_alert=True)
                    return 403
            else:
                # Если пользователь отсутствует, предлагаем выбрать язык
                data["lang"] = "ru" if event.from_user.language_code in ["ru", "uk"] else "en"
                if event.data == "lang_ru" or event.data == "lang_en":
                    data["lang"] = "ru" if event.data == "lang_ru" else "en"
                    return await handler(event, data)
                return await choise_lang(event.message, data)

        # Передаём управление следующему обработчику
        response = await handler(event, data)

        # Логируем ответ
        logging.info(f"Outgoing response for callback query: {response}")

        return response


        [FILE] state.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/utils/state.py ---
from aiogram.fsm.state import StatesGroup
from aiogram.fsm.state import State


class RegState(StatesGroup):

    name =State()
    age = State()
    gender = State()
    preferences = State()
    location = State()
    about = State()
    media = State()
    hobbies = State()
    show = State()
    orientation = State()
    done = State()




class SearchPeople(StatesGroup):
    search = State()
    like = State()
    superlike = State()
    dislike = State()
    block = State()
    report = State()
    stop = State()
    message = State()
    show = State()
    show_profile = State()
    show_media = State()
    show_hobbies = State()
    show_about = State()
    show_location = State()
    show_preferences = State()


class ReditState(StatesGroup):

    name =State()
    age = State()
    gender = State()
    preferences = State()
    location = State()
    about = State()
    media = State()
    hobbies = State()
    show = State()
    orientation = State()
    done = State()
 

    [DIR] __pycache__
        [FILE] models.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/__pycache__/models.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [FILE] __init__.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/__pycache__/__init__.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
    [DIR] bot
        [DIR] __pycache__
            [FILE] config.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/__pycache__/config.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
        [DIR] handlers
            [FILE] registration.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/registration.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.types import InputMediaPhoto, InputMediaVideo
from src.utils.state import RegState
from src.utils.generate_uid import generate_uid_code

from src.utils.comands import set_user_specific_commands, delete_user_specific_commands
import random

from aiogram.types import WebAppInfo, InlineKeyboardMarkup, InlineKeyboardButton

def get_web_app_button():
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(
                text="🔍 Найти пользователей",
                web_app=WebAppInfo(url="https://ffa0-162-213-64-84.ngrok-free.app/profile/cards/")
            )]
        ]
    )
router = Router()

@router.message(Command("search"))
async def start_search(message: types.Message):
    button = get_web_app_button()
    await message.answer("Нажмите кнопку ниже, чтобы начать поиск пользователей:", reply_markup=button)



@router.message(CommandStart())
async def handle_message1(message: types.Message, state: FSMContext, lang: str, user: User = None, user_none: bool = False):
    if user:
        # Если имя не указано
        if user.name is None:
            txt = (
                "<b>🎉</b>\nТеперь давай настроим твой профиль, чтобы ты мог(ла) быстрее найти интересных людей. 🌟\n\n➡️ Укажи свое имя, чтобы мы могли начать!"
                if lang == "ru" else
                "<b>🎉</b>\nNow let’s set up your profile so you can start meeting interesting people faster. 🌟\n\n➡️ Please provide your name to get started!"
            )
            await state.set_state(RegState.name)
            await message.answer(txt)

        # Если имя указано, но пол не выбран
        elif user.name is not None and user.gender is None:
            txt = (
                f"<b>Отлично,{user.name}</b>\nТеперь укажи свой пол! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                f"<b>Great,{user.name}</b>\nNow specify your gender! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другой" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.gender)
            await message.answer(txt, reply_markup=keyboard)

        # Если пол указан, но ориентация не выбрана
        elif user.name is not None and user.gender is not None and user.orientation is None:
            txt = (
                "Теперь укажи свою ориентацию! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
                "Now specify your orientation! 🌟\n\n➡️ Choose one of the options:"
            )
            if user.gender == 'mal':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'fem':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender == 'oth':
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await message.answer(txt, reply_markup=keyboard)

        # Если ориентация указана, но не указаны предпочтения для просмотра
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is None:
            txt = (
"Теперь укажи, кого ты хочешь видеть! 🌟\n\n➡️ Выбери один из вариантов:"
                if lang == "ru" else
"Now specify who you want to see! 🌟\n\n➡️ Choose one of the options:"
            )
            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_everyone")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await message.answer(txt, reply_markup=keyboard)

        # Если предпочтения для просмотра указаны, но возраст не указан
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.age is None:
            txt = (
                "Теперь укажи свой возраст! 🌟\n\n➡️ Введите ваш возраст (минимум 16 лет):"
                if lang == "ru" else
                "Now specify your age! 🌟\n\n➡️ Enter your age (minimum 16 years):"
            )
            await state.set_state(RegState.age)
            await message.answer(txt)

        # Если все данные собраны, переходим к следующему шагу
        elif user.name is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.age is not None and user.preferences is None:
            txt = (
                "Теперь укажи свои цели! 🌟\n\n➡️ Выбери цели из предложенных вариантов:"
                if lang == "ru" else
                "Now specify your goals! 🌟\n\n➡️ Choose your goals from the options provided:"
            )
            inline_keyboard=[]
            if lang =="ru":
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
            else:
                inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.preferences)
            await message.answer(txt, reply_markup=keyboard)
        elif user.name is not None and user.age is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is None:

            keyboard = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )

            if lang == "ru":
                txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
            else:
                txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

            await state.set_state(RegState.location)
            msg = await message.bot.send_message(message.from_user.id ,text=txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)

        elif user.name is not None and user.age is not None and user.gender is not None and  user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is None:
            if lang == "ru":
                txt = """
Теперь расскажи немного о себе. 🌟

➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
"""
            else:
                txt = """
Now tell us a bit about yourself. 🌟

➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
"""
            await state.set_state(RegState.about)
            await message.bot.send_message(message.from_user.id, txt)
        elif user.name is not None and user.age is not None and user.gender is not None and user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is not None and user.hobbies is None:
            state_data = await state.get_data()
            current_page = state_data.get("current_page", 1)
            hobbies = state_data.get("selected_hobbies", [])  # Загружаем хобби из состояния или базы

            if len(hobbies) < 5:
                await state.set_state(RegState.hobbies)

                # Увлечения на двух языках с номерами
                interests = [
                    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
                    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
                    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
                    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
                    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
                    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
                    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
                    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
                    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
                    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
                    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
                    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
                    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
                    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
                    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
                    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
                ]
                page_size = 10
                start_index = (current_page - 1) * page_size
                end_index = start_index + page_size

                # Генерация кнопок для текущей страницы
                inlinekeyboard = []
                row = []

                for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
                    text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
                    row.append(InlineKeyboardButton(
                        text=text,
                        callback_data=f"intrs_{number}"
                    ))
                    if len(row) == 2 or i == len(interests[start_index:end_index]):
                        inlinekeyboard.append(row)
                        row = []

                # Добавляем кнопки навигации
                navigation_buttons = []
                if current_page > 1:
                    navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
                if end_index < len(interests):
                    navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
                if navigation_buttons:
                    inlinekeyboard.append(navigation_buttons)

                if len(hobbies) == 5:
                    inlinekeyboard.append(
                        [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
                    )

                keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)

                if lang == "ru":
                    if hobbies:
                        txt = f"<b>У вас уже выбрано {len(hobbies)}/5 увлечений ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми \"<b>Сохранить✅</b>\"."
                else:
                    if hobbies:
                        txt = f"<b>You have already selected {len(hobbies)}/5 hobbies ✅</b>\n"
                    else:
                        txt = ""
                    txt += "Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\"."

                await state.update_data(current_page=current_page, hobbies=hobbies)  # Сохраняем данные в состояние
                await message.answer(txt, reply_markup=keyboard)


        elif user.name is not None and user.age is not None and user.gender is not None and user.orientation is not None and user.for_whom is not None and user.preferences is not None and user.location is not None and user.about is not None and user.hobbies is not None and user.medias is None:

            txt = """

Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """

Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
Or press "Skip" to continue. ⏩"""
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
            ])
            await state.set_state(RegState.media)
            data = await state.get_data()

            msg = await message.bot.send_message(chat_id=message.from_user.id, text=txt, reply_markup=keyboard)
            data["idmsg_media"] = msg.message_id
            await state.update_data(data=data)

        else:
            
            if lang == "ru":
                button_text = "🚀 Начать поиск"
            else:
                button_text = "🚀 Start Search"

            keyboard = ReplyKeyboardMarkup(
                keyboard=[
                    [KeyboardButton(text=button_text)]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            )
            await set_user_specific_commands(message.bot, message.from_user.id, lang )
            response = (
        "ℹ️ Воспользуйтесь боковым меню ↙️\nчтобы открыть детали подписки или посмотреть профиль." 
        if lang == "ru" 
        else "ℹ️ Use the side menu ↙️\nto access subscription details or view your profile."
    )
            await message.answer(response, reply_markup=keyboard)

            
        









@router.message(Command("block"))
async def handle_message(message: types.Message, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    # if user:
    #     user.status_block="Deactive"
    #     await user.save()
    await delete_user_specific_commands(message.bot, message.from_user.id)

    

@router.message(Command("del"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    
    if user:
        await user.delete()
        # await user.save()


# Список столиц мира с их координатами
WORLD_CAPITALS = [
    ("Moscow", 55.7558, 37.6173),
    ("Washington, D.C.", 38.9072, -77.0369),
    ("London", 51.5074, -0.1278),
    ("Tokyo", 35.6895, 139.6917),
    ("Paris", 48.8566, 2.3522),
    ("Berlin", 52.5200, 13.4050),
    ("Beijing", 39.9042, 116.4074),
    ("Canberra", -35.2809, 149.1300),
    ("Ottawa", 45.4215, -75.6972),
    ("Brasília", -15.8267, -47.9218)
]
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"fem":"👩 Девушки",
    "mal":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "fem":"👩 Girls",
    "mal":"👨 Boys",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"💫Другая",
                "skip":"Не указана"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"💫Other",
                "skip":"Not specified"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}


async def generate_random_profiles():
    interests = [interest[1] for interest in INTERESTS]

    for _ in range(200):
        # Случайный выбор пола, ориентации и других параметров
        gender = random.choice(list(GENDER["en"].keys()))
        orientation = random.choice(list(ORI["en"].keys()))
        for_whom = random.choice(list(WHO["en"].keys()))
        preference = random.choice(list(PREFERENCES["en"].keys()))

        # Случайная локация
        city, latitude, longitude = random.choice(WORLD_CAPITALS)
        location = f"{latitude},{longitude}"

        # Случайные увлечения (до 5)
        hobbies = random.sample(interests, k=random.randint(1, 5))

        # Случайное имя и описание
        name = f"User{random.randint(1000, 9999)}"
        about = "I love " + ", ".join(random.sample(interests, k=2)) + "."
        media=[]
        media_data = {
                    "file_id": 'AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ',
                    "type": "photo" 
                }
        users = await User.all().values_list("uid_code", flat=True)
        uid = await generate_uid_code(uids=users)
        media.append(media_data)
        # Создание пользователя
        await User.create(
            name=name,
            age=random.randint(18, 50),
            gender=gender,
            orientation=orientation,
            for_whom=for_whom,
            preferences=preference,
            location=location,
            about=about,
            hobbies=hobbies,
            medias=None,
            uid_code=uid,
            lang='ru' # Медиаданные остаются пустыми

        )

    print("200 random profiles created successfully!")
@router.message(Command("add"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    await generate_random_profiles()
    await message.answer("200 случайных профилей успешно созданы!")

        
@router.message(Command("del1"))
async def handle_message(message: types.Message, state: FSMContext, user: User = None, user_none: bool = False):
    user= await User.get_or_none(user_id=message.from_user.id)
    
    if user:
        user.age=None
        await user.save()


async def choise_lang(message: types.Message, lang: str):
    if lang['lang']=="ru":
    
        txt="""<b>Привет! 👋</b>
На связи <b>💖Emi-Date💖</b> — твой помощник в мире знакомств для людей в эмиграции. 🌍✨

Чтобы начать, пожалуйста, выбери язык, который тебе удобен:
"""
    else:
        txt="""<b>Hi there! 👋</b>
Welcome to <b>💖Emi-Date💖</b> — your go-to bot for connecting with people in emigration. 🌍✨

To get started, please select your preferred language:
"""
    
    # Кнопки для выбора языка
    
    inline_keyboard=[]
    inline_keyboard.append([InlineKeyboardButton(text="🇷🇺 Русский", callback_data="lang_ru")])
    inline_keyboard.append([InlineKeyboardButton(text="🇺🇸 English", callback_data="lang_en")])

    keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)

    await message.answer(text=txt, reply_markup=keyboard)




@router.message(Command("album"))
async def handle_message(message: types.Message, user: User = None, user_none: bool = False):

    media_files = [
        InputMediaPhoto(media='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'),
        InputMediaPhoto(media='AgACAgIAAxkBAAICWWeDyb_A6JZaMM-rKWzrIlO9r5UuAAJ-7zEbmgYZSItKXWCHjlf_AQADAgADeQADNgQ'),
        # Добавьте до 10 медиафайлов
    ]

    # Отправка медиа-группы
    await message.bot.send_media_group(chat_id=message.from_user.id, media=media_files)










@router.callback_query(lambda c: "lang_" in c.data)
async def callback_handler(callback_query: CallbackQuery, state: FSMContext, lang: str):
    lang = (callback_query.data.split("_"))[1]
    user_id = callback_query.from_user.id
    user= await User.get_or_none(user_id=user_id)
    if user:
        user.lang=lang
        await user.save()
    if user.name==None:
        keyboard = None
        if lang == "ru":
            txt = """<b>Отлично! 🎉</b>
Нажми /start, чтобы быстрее найти интересных людей. 🌟

"""
        else:
            txt = """<b>Great! 🎉</b
Tap /start to quickly find interesting people. 🌟
    """
        await callback_query.bot.edit_message_text(text=txt, chat_id=user_id, message_id=callback_query.message.message_id, reply_markup=None)
        
       


  







            [FILE] likes.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/likes.py ---


            [FILE] anketa.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/anketa.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from src.utils.add_profile import add_profile
from aiogram.types import ContentType


router = Router()
BAD_WORDS = [
    # Наркотики
    "наркотик", "наркота", "косяк", "травка", "гашиш", "героин", "кокаин", "амфетамин", "экстази",
    "марихуана", "спайс", "лсд", "шишки", "опиум", "план", "кристалл", "мефедрон", "drugs", "drug",
    "weed", "marijuana", "cocaine", "heroin", "ecstasy", "meth", "amphetamine", "hash", "spice",
    "lsd", "crystal", "meph", "opium", "j0int", "dr@g", "tr@vka",

    # CP
    "детская порнография", "детское порно", "запрещенное видео", "нелегальный контент", "порнография с детьми",
    "cp", "child porn", "child pornography", "illegal content", "b@nned video", "ch!ld p0rn",

    # Оружие
    "оружие", "пистолет", "винтовка", "автомат", "пулемет", "граната", "мина", "бомба", "арсенал",
    "ружье", "ствол", "калашников", "ак-47", "глок", "гранатомет", "weapon", "gun", "pistol", "rifle",
    "machine gun", "grenade", "bomb", "landmine", "arsenal", "shotgun", "kalashnikov", "ak47",
    "glock", "rocket launcher", "we@pon", "glock-19", "b0mb",

    # Additional prohibited words
    "explosive", "tnt", "c4", "detonator", "silencer", "sniper", "assault rifle", "pipe bomb",
    "наркот", "герич", "герыч", "доза", "спайсы", "соли", "фен", "скорость",
    "запрещенка", "порно с детьми", "порево", "kill", "murder", "mass shooting", "terrorist", "attack"
]






# ++++++++++++++++ NAME +++++++++++++++

@router.message(RegState.name)
async def set_name(message: types.Message, state: FSMContext, lang: str):
    user = await User.get_or_none(user_id=message.from_user.id)
    global BAD_WORDS
    if user:
        
        if message.text not in BAD_WORDS:
            user.name = message.text.strip()
            await user.save()
            if user.gender is None:
                
                if lang == "ru":
                    txt = """<b>Имя указано! ✅</b>
    Отлично, теперь укажи свой пол! 🌟

    ➡️ Выбери один из вариантов:
    """
                else:
                    txt = """<b>Name provided! ✅</b>
    Great, now specify your gender! 🌟

    ➡️ Choose one of the options:
    """

                inline_keyboard = [
                    [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                    [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                    [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
                ]

                keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
                await state.set_state(RegState.gender)
                await message.answer(txt, reply_markup=keyboard)
            else:
                txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
                await state.set_state(state=None)

                
                if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=message, state=state , user=user, lang=lang)
                else:
                    await message.answer(txt)

        else:
            txt = """<❌ <b>Ошибка:</b> Ваше имя содержит запрещенные слова. Пожалуйста, выберите другое имя. ✍️""" if lang == "ru" else """<❌ <b>Error:</b> Your name contains prohibited words. Please choose another name. ✍️"""
            await state.set_state(RegState.name)
            await message.answer(txt)
        
# ++++++++++++++++ GENDER +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("gender_"), RegState.gender)
async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.gender = callback_query.data.split("_")[1]
        await user.save()
        if user.orientation is None:
            if lang == "ru":
                txt = """<b>Пол указан! ✅</b>
    Теперь укажи свою ориентацию! 🌟

    ➡️ Выбери один из вариантов:
    """
            else:
                txt = """<b>Gender saved! ✅</b>
    Now specify your orientation! 🌟

    ➡️ Choose one of the options:
    """
            if user.gender =='mal':

                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender =="fem":
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]
            elif user.gender=="oth":
                inline_keyboard = [
                    [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                    [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                    [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
                ]

            inline_keyboard.append([InlineKeyboardButton(text="💫Другая" if lang == "ru" else "💫Other", callback_data="orientation_oth")])
            inline_keyboard.append([InlineKeyboardButton(text="Пропустить ➡️" if lang == "ru" else "Skip ➡️", callback_data="orientation_skip")])
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.orientation)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)
# ++++++++++++++++ ORIENTATION +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("orientation_"), RegState.orientation)
async def set_orientation(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.orientation = callback_query.data.split("_")[1]
        await user.save()
        if user.for_whom is None:
            if lang == "ru":
                txt = """<b>Ориентация указана! ✅</b>
    Теперь укажи, кого ты хочешь видеть! 🌟

    ➡️ Выбери один из вариантов:
    """
            else:
                txt = """<b>Orientation saved! ✅</b>
    Now specify who you want to see! 🌟

    ➡️ Choose one of the options:
    """

            inline_keyboard = [
                [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
                [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
                [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")]
            ]

            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await state.set_state(RegState.show)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ SHOW PREFERENCES +++++++++++++++

@router.callback_query(lambda c: c.data.startswith("show_"), RegState.show)
async def set_show_preferences(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    if user:
        user.for_whom = callback_query.data.split("_")[1]
        await user.save()
        if user.age is None:
            if lang == "ru":
                txt = """<b>Параметры просмотра указаны! ✅</b>
    Теперь укажи свой возраст! 🌟

    ➡️ Введите ваш возраст (минимум 16 лет):
    """
            else:
                txt = """<b>Viewing preferences saved! ✅</b>
    Now specify your age! 🌟

    ➡️ Enter your age (minimum 16 years):
    """

            await state.set_state(RegState.age)
            await callback_query.message.edit_text(txt)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ AGE +++++++++++++++

@router.message(RegState.age)
async def set_age(message: types.Message, user: User, state: FSMContext, lang: str):
    if user:
        if message.text.isdigit():
            age = int(message.text)
            if age >= 16:
                user.age = age
                await user.save()
                if user.preferences is None:
                    if lang == "ru":
                        txt = """<b>Возраст указан! ✅</b>
    Теперь укажи свои цели! 🌟

    ➡️ Выбери цели из предложенных вариантов:
    """
                    else:
                        txt = """<b>Age saved! ✅</b>
    Now specify your goals! 🌟

    ➡️ Choose your goals from the options provided:
    """
                    inline_keyboard=[]
                    if lang =="ru":
                        inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
                        inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
                        inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
                        inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
                    else:
                        inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
                        inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
                        inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
                        inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])


                    keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
                    await state.set_state(RegState.preferences)
                    await message.answer(txt, reply_markup=keyboard)
                else:
                    txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
                    await state.set_state(state=None)

                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                        await add_profile(message=message, state=state , user=user, lang=lang)
                    else:
                        await message.answer(txt)
            else:
                txt = """❌ <b>Ошибка:</b> Возраст должен быть не менее 16 лет. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be at least 16 years. 🔢"""
                await message.answer(txt)
        else:
            txt = """❌ <b>Ошибка:</b> Возраст должен быть числом. Пожалуйста, введите корректное значение. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be a number. Please enter a valid value. 🔢"""
            await message.answer(txt)


# ++++++++++++++++ PREFERENCES +++++++++++++++

@router.callback_query(lambda c: "interest_" in c.data, RegState.preferences)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
    if user:
        pref = callback_query.data.split("_")[1]
        user.preferences=pref
        await user.save()
        if user.location is None:
            keyboard = ReplyKeyboardMarkup(
                keyboard=[[ KeyboardButton(text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",request_location=True)]],resize_keyboard=True,one_time_keyboard=True)

            if lang == "ru":
                txt = """<b>Цели поиска указаны! ✅</b>
    Отлично, теперь нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍

    ⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

    💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
    Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

    ➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
    """
            else:
                txt = """<b>Search goals saved! ✅</b>
    Great, now we need your location to suggest people nearby. 🌍

    ⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

    💡 <b>Note:</b> You can send your current location by pressing the button below. 
    If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

    ➡️ Please press the button below to share your location or choose a point on the map.
    """

            await state.set_state(RegState.location)
            await callback_query.bot.delete_message(callback_query.from_user.id, callback_query.message.message_id)
            msg= await callback_query.bot.send_message(callback_query.from_user.id, txt, reply_markup=keyboard)
            data = await state.get_data()
            data['idmsg_local']=msg.message_id
            await state.update_data(data)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
            else:
                await callback_query.message.edit_text(txt, reply_markup=None)

# ++++++++++++++++ LOCATION +++++++++++++++

@router.message(RegState.location, lambda message: message.content_type == ContentType.LOCATION)
async def set_location(message: types.Message, user: User, state: FSMContext, lang: str):
    
    if user:
        print(f"\n\n\n\n\n\n\n\n\n\n\n\n\n\n{message.location}\n\n\n\n\n\n\n\n\n\n\n\n{message.location.model_config}")
        user.location = f"{message.location.latitude},{message.location.longitude}"
        await user.save()
        if user.about is None:
            if lang == "ru":
                txt = """<b>Локация указана! ✅</b>
    Отлично, теперь расскажи немного о себе. 🌟

    ➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
    """
            else:
                txt = """<b>Location saved! ✅</b>
    Great, now tell us a bit about yourself. 🌟

    ➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
    """
            await state.set_state(RegState.about)
            data = await state.get_data()
            if "idmsg_local" in data: 
                await message.bot.delete_message(message.from_user.id, data["idmsg_local"])
            data["idmsg_local"]=''
            await state.update_data(data)
            await message.bot.delete_message(message.from_user.id, message.message_id)
            await message.bot.send_message(message.from_user.id, txt)
        else:
            txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."                
            await state.set_state(state=None)

            
            if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=message, state=state , user=user, lang=lang)
            else:
                await message.answer(txt)
# ++++++++++++++++ ABOUT +++++++++++++++

@router.message(RegState.about)
async def set_about(message: types.Message, user: User, state: FSMContext, lang: str):
    global BAD_WORDS
    if user:
        if message.text:
            if message.text not in BAD_WORDS:
                user.about = message.text
                await user.save()
                if user.hobbies is None:
                
                    await state.set_state(RegState.hobbies)
                # Увлечения на двух языках с номерами
                    interests = [
                        (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
                        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
                        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
                        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
                        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
                    ]
                    inlinekeyboard = []
                    row = []

                    # Формируем кнопки для увлечений, по 3 в ряд
                    for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
                        row.append(InlineKeyboardButton(
                            text=interest_ru if lang == "ru" else interest_en,
                            callback_data=f"intrs_{number}"
                        ))
                        # Если добавлено 3 кнопки или это последняя кнопка в списке
                        if len(row) == 2 or i == len(interests[:10]):
                            inlinekeyboard.append(row)
                            row = []  # Сбрасываем строку для следующего ряда

                    # Добавляем стрелки навигации в последнюю строку
                    inlinekeyboard.append([
                        InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
                        InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
                    ])

                    keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
                    
                    if lang == "ru":
                        txt = """<b>Записали ✅</b>
    Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟

    ➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
        """
                    else:
                        txt = """<b>Saved ✅</b>
    Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
    """


                    await message.answer(txt, reply_markup=keyboard)
                else:
                    txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."
                    await state.set_state(state=None)

                    
                    if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                        await add_profile(message=message, state=state , user=user, lang=lang)
                    else:
                        await message.answer(txt)
            else:
                if lang == "ru":
                    txt = """❌ <b>Ошибка:</b> Описание содержит запрещенные слова. Пожалуйста, введите другое описание и попробуйте снова. ✍️"""
                else:
                    txt = """❌ <b>Error:</b> The description contains prohibited words. Please enter another description and try again. ✍️"""
                await message.answer(txt)
                await state.set_state(RegState.about)
        else:
                if lang == "ru":
                    txt = """❌ <b>Ошибка:</b> Описание долджно содержать текст ✍️"""
                else:
                    
                    txt = """❌ <b>Error:</b> The description must contain text. Please write something ✍️"""
                await message.answer(txt)
                await state.set_state(RegState.about)

# ++++++++++++++++ HOBBIES +++++++++++++++

@router.callback_query(lambda c: "intrs_" in c.data or c.data.startswith("intrs_page") or c.data == "intrs_done", RegState.hobbies)
async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    # Загружаем список интересов
    interests = [
        (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]

    # Обработка страниц
    state_data = await state.get_data()
    current_page = state_data.get("current_page", 1)
    hobbies = state_data.get("selected_hobbies", [])

    if callback_query.data.startswith("intrs_page"):
        if "next" in callback_query.data:
            current_page += 1
        elif "back" in callback_query.data:
            current_page -= 1
        await state.update_data(current_page=current_page)

    elif callback_query.data.startswith("intrs_") and callback_query.data != "intrs_done":
        interest = callback_query.data.split("_")[1]
        if interest in hobbies:
            hobbies.remove(interest)
        else:
            if len(hobbies) < 5:
                hobbies.append(interest)
            else:
                txt1 = "Выбрано максимальное количество! Уберите один интерес или нажмите 'Сохранить'." if lang == "ru" else "Maximum number selected! Remove one interest or click 'Save'."
                await callback_query.answer(
                    txt1,
                    show_alert=True
                )
                return
        await state.update_data(selected_hobbies=hobbies)

    elif callback_query.data == "intrs_done":
        if len(hobbies) < 5:
            txt2 = "Вы должны выбрать минимум 5 интересов, чтобы продолжить!" if lang == "ru" else "You must select at least 5 interests to continue!"
            await callback_query.answer(
                txt2,
                show_alert=True
            )
            return
        else:
            user.hobbies = hobbies  # Сохраняем в базу данных только при завершении
            await user.save()
            if user.medias is None:
                txt3 = "Интересы сохранены! ✅" if lang == "ru" else "Interests saved! ✅"
                await callback_query.answer(txt3, show_alert=True)

                txt = """🎉 <b>Отлично!</b> Ваши хобби успешно сохранены.  

    Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
    Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """🎉 <b>Great!</b> Your hobbies have been successfully saved.  

    Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
    Or press "Skip" to continue. ⏩"""

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
                ])
                data = await state.get_data()
                msg =await callback_query.message.edit_text(txt, reply_markup=keyboard)
                data['idmsg_media']=msg.message_id
                await state.update_data(data)
                await state.set_state(RegState.media)
                return
            else:
                txt="Сохранено ✅\nНажмите /start, чтобы продолжить." if lang == "ru" else "Saved ✅\nClick /start to continue."
                await state.set_state(state=None)
                await callback_query.answer(txt, show_alert=True)

                if not all([
                        user.name,
                        user.age,
                        user.gender,
                        user.orientation,
                        user.for_whom,
                        user.preferences,
                        user.location,
                        user.about,
                        user.hobbies,
                        user.medias]):
                    await add_profile(message=callback_query.message, state=state , user=user, lang=lang)
                else:
                    await callback_query.message.edit_text(txt, reply_markup=None)
                return

    # Генерация кнопок для текущей страницы
    page_size = 10
    start_index = (current_page - 1) * page_size
    end_index = start_index + page_size
    inlinekeyboard = []
    row = []

    for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
        text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
        row.append(InlineKeyboardButton(
            text=text,
            callback_data=f"intrs_{number}"
        ))
        if len(row) == 2 or i == len(interests[start_index:end_index]):
            inlinekeyboard.append(row)
            row = []

    navigation_buttons = []
    if current_page > 1:
        navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
    if end_index < len(interests):
        navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
    if navigation_buttons:
        inlinekeyboard.append(navigation_buttons)

    if len(hobbies) == 5:
        inlinekeyboard.append(
            [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
        )

    keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
    txt = (f"<b>Выбрано {len(hobbies)}/5 увлечений ✅</b>\n" if lang == "ru" else f"<b>Selected {len(hobbies)}/5 hobbies ✅</b>\n")
    txt += "Отлично, выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми 'Сохранить'." if lang == "ru" else "Great, select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click 'Save'."

    await callback_query.message.edit_text(txt, reply_markup=keyboard)

            [FILE] myprofile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/myprofile.py ---
from aiogram import Router, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo
from src.models import User
from aiogram.filters import CommandStart, Command
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState

router = Router()

# Словари переводов
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"fem":"👩 Девушки",
    "mal":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "fem":"👩 fem",
    "mal":"👨 mal",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"💫Другая",
                "skip":"Не указана"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"💫Other",
                "skip":"Not specified"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}

import ssl
import certifi
from geopy.geocoders import Nominatim

def get_location_by_coordinates(latitude, longitude):
    geolocator = Nominatim(
        user_agent="my_geopy_app",
        timeout=10,
        ssl_context=ssl.create_default_context(cafile=certifi.where())
    )
    try:
        location = geolocator.reverse((latitude, longitude), exactly_one=True)
        if location:
            address = location.raw.get('address', {})
            city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
            return city or location.address
        else:
            return "Местоположение не найдено"
    except Exception as e:
        return f"Ошибка при определении местоположения: {e}"
    

@router.message(Command("myprofile"))
async def my_profile_handler(message: types.Message,state: FSMContext):
    user = await User.get_or_none(user_id=message.from_user.id)

    if not user:
        lang = "ru"
        await message.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
        return

    lang = user.lang if user.lang in ["ru", "en"] else "ru"
    hobbies_text = ", ".join([
        (interest[1] if lang == "ru" else interest[2])
        for interest in INTERESTS
        if str(interest[0]) in (user.hobbies or [])
    ])

    location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
    if "," in location_text:
        latitude, longitude = map(float, location_text.split(","))
        location_text = get_location_by_coordinates(latitude, longitude)

    subscription_text = (
        f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
    )
    if user.subscription != "Free":
        subscription_text += (
            f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
        )

    description = (
        f"<b>{'Ваш профиль' if lang == 'ru' else 'Your profile'}:</b>\n\n"
        f"<b>{'Имя' if lang == 'ru' else 'Name'}:</b> {user.name}\n"
        f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
        f"<b>{'Пол' if lang == 'ru' else 'Gender'}:</b> {GENDER[lang][user.gender]}\n"
        f"<b>{'Локация' if lang == 'ru' else 'Location'}:</b> {location_text or ('Локация не указана' if lang == 'ru' else 'Location not provided')}\n\n"
        f"{subscription_text}"
        f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
        f"<b>{'Кого показывать' if lang == 'ru' else 'Viewing Preferences'}:</b> {WHO[lang][user.for_whom]}\n"
        f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
        f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
        f"_________________________\n{user.about or ''}\n"
    )



    media = user.medias or []
    if len(media) == 1:
        media_file = media[0]['file_id']
        if media[0]['type'] == 'photo':
            msg= await message.bot.send_photo(message.from_user.id, media_file, caption=description)
        elif media[0]['type'] == 'video':
            msg= await message.bot.send_video(message.from_user.id, media_file, caption=description)
    else:
        files=[]
        i =0
        for media_file in media:
            
            caption=description if i == 0 else None
            
            if media_file["type"] =="video":
                files.append(InputMediaVideo(media=f"{media_file['file_id']}", caption=caption))
                i = i+1
            elif media_file['type'] == 'photo':
                files.append(InputMediaPhoto(media=f"{media_file['file_id']}", caption=caption))
                i = i+1
            else:
                continue
                 

    # Отправка медиа-группы
        msg= await message.bot.send_media_group(chat_id=message.from_user.id, media=files)
        data= await state.get_data()
        data["id_card_profile"]=None
        await state.update_data(data=data)
    lang = user.lang if user and user.lang in ["ru", "en"] else "ru"
    if user.localstatus == "active":
        btn_local = InlineKeyboardButton(
            text="🌍 Скрыть локацию" if lang == "ru" else "🌍 Hide Location",
            callback_data="location_hish"
        )
    else:
        btn_local = InlineKeyboardButton(
            text="🌍 Показать локацию" if lang == "ru" else "🌍 Show Location",
            callback_data="location_hish"
        )

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="🖋 Имя" if lang == "ru" else "🖋 Name",
                callback_data="fedit_name"
            ),
            InlineKeyboardButton(
                text="🎂 Возраст" if lang == "ru" else "🎂 Age",
                callback_data="fedit_age"
            )
        ],
        [
            InlineKeyboardButton(
                text="📍 Изменить локацию" if lang == "ru" else "📍 Edit Location",
                callback_data="fedit_location"
            ),
            btn_local
        ],
        [
            InlineKeyboardButton(
                text="⚥ Пол" if lang == "ru" else "⚥ Gender",
                callback_data="fedit_gender"
            ),
            InlineKeyboardButton(
                text="🌈 Ориентация" if lang == "ru" else "🌈 Orientation",
                callback_data="fedit_orientation"
            )
        ],
        [
            InlineKeyboardButton(
                text="👁️‍🗨️ Кого показывать" if lang == "ru" else "👁️‍🗨️ Viewing Preferences",
                callback_data="fedit_pref"
            ),
            InlineKeyboardButton(
                text="🎯 Цели" if lang == "ru" else "🎯 Goals",
                callback_data="fedit_goals"
            )
        ],
        [
            InlineKeyboardButton(
                text="🎨 Увлечения" if lang == "ru" else "🎨 Hobbies",
                callback_data="fedit_hobbies"
            ),
            InlineKeyboardButton(
                text="📝 Описание" if lang == "ru" else "📝 Description",
                callback_data="fedit_descr"
            )
        ],[
    InlineKeyboardButton(
        text="🖼️ Изменить медиа" if lang == "ru" else "🖼️ Edit Media",
        callback_data="fedit_media"
    )
],

        [
            InlineKeyboardButton(
                text="🔄 Заполнить заново" if lang == "ru" else "🔄 Refill Profile",
                callback_data="reset_profile"
            )
        ]
    ])


    await message.answer(
        MESSAGES["action_prompt"][lang], 
        reply_markup=keyboard
    )


            [DIR] __pycache__
                [FILE] myproffile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/myproffile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] edit_profile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/edit_profile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] serch.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/serch.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] anketa.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/anketa.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] registration.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/registration.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
                [FILE] myprofile.cpython-312.pyc
Ошибка при чтении файла /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/__pycache__/myprofile.cpython-312.pyc: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte
            [FILE] edit_profile.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/edit_profile.py ---
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import Message
from typing import Callable, Awaitable, Dict, Any, List
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from aiogram.types import ContentType
from src.utils.comands import set_user_specific_commands
from aiogram import Router, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo
from src.models import User
from aiogram.filters import CommandStart, Command
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from src.models import User
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext, BaseStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from src.utils.state import RegState
from src.utils.add_profile import add_profile



# Словари переводов
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
        (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
        (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
        (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
        (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
        (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
        (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
        (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
        (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
        (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
        (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
        (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
        (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
        (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
        (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
        (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
        (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
        (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
        (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
        (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
    ]


PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {
        "fem": "👩 Женский",
        "mal": "👨 Мужской",
        "oth": "🌈 Другое"
    },
    "en": {
        "fem": "👩 Female",
        "mal": "👨 Male",
        "oth": "🌈 Other"
    }
}

WHO = {
    "ru":{"girls":"👩 Девушки",
    "boys":"👨 Парни",
    "all":"🌍 Все"},
    "en":
    {
    "girls":"👩 Girls",
    "boys":"👨 Boys",
    "all":"🌍 Everyone"
    }
}

ORI={
        "ru":{
                "hetero":"❤️ Гетеро",
                "gay":"🌈 Гей",
                "bi":"💛 Би",
                "lesbian":"💖 Лесби",
                "gay_lesbian":"🌈 Гей/Лесби",
                "oth":"Другая"


        },
        "en":{
                "hetero":"❤️ Hetero",
                "gay":"🌈 Gay",
                "bi":"💛 Bi",
                "lesbian":"💖 Lesbian",
                "gay_lesbian":"🌈 Gay/Lesbian",
                "oth":"Other"
        }

}
MESSAGES = {
    "profile_not_found": {
        "ru": "<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.",
        "en": "<b>Profile not found.</b>\nPlease register using the /start command."
    },
    "action_prompt": {
        "ru": "✏️ <b>Выберите действие:</b>",
        "en": "✏️ <b>Select an action:</b>"
    },
    "edit_name": {
        "ru": "Изменить имя",
        "en": "Edit Name"
    },
    "edit_age": {
        "ru": "Изменить возраст",
        "en": "Edit Age"
    },
    "edit_gender": {
        "ru": "Изменить пол",
        "en": "Edit Gender"
    },
    "reset_profile": {
        "ru": "Заполнить заново",
        "en": "Refill Profile"
    }
}

import ssl
import certifi
from geopy.geocoders import Nominatim

def get_location_by_coordinates(latitude, longitude):
    geolocator = Nominatim(
        user_agent="my_geopy_app",
        timeout=10,
        ssl_context=ssl.create_default_context(cafile=certifi.where())
    )
    try:
        location = geolocator.reverse((latitude, longitude), exactly_one=True)
        if location:
            address = location.raw.get('address', {})
            city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
            return city or location.address
        else:
            return "Местоположение не найдено"
    except Exception as e:
        return f"Ошибка при определении местоположения: {e}"

router = Router()

                # "🖋 Имя" if 🖋 Name",callback_data="fedit_name"
                # "🎂 Возраст" if 🎂 Age",callback_data="fedit_age"
                # "📍 Изменить локацию" if 📍 Edit Location",callback_data="fedit_location"
                # "⚥ Пол" if ⚥ Gender",callback_data="fedit_gender"            
                # "🌈 Ориентация" if 🌈 Orientation",callback_data="fedit_orientation"
                # "👁️‍🗨️ Кого показывать" if 👁️‍🗨️ Viewing Preferences",callback_data="fedit_pref"
                # "🎯 Цели" if 🎯 Goals",callback_data="fedit_goals"           
                # "🎨 Увлечения" if 🎨 Hobbies",callback_data="fedit_hobbies"
                # "📝 Описание" if 📝 Description",callback_data="fedit_descr"
            

@router.callback_query(lambda c: c.data.startswith("fedit_"))
async def set_edit_field(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    cb_data = (callback_query.data.split("_"))[1]
    data = await state.get_data()
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="Назад⬅️" if lang == "ru" else "Back⬅️",
                callback_data="fedit_back"
            )
        ]
    ])

    if cb_data == "name":
        txt = "🌟➡️ Укажи свое имя, чтобы мы могли начать!\n\nИли надмите <b>'назад⬅️'</b> чтобы отменить действвие " if lang == "ru" else "🌟➡️ Please provide your name to get started!\n\nOr press <b>'back⬅️'</b> to undo the action"
        data = await state.get_data()
        await state.set_state(RegState.name)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "age":
        txt = "🎂➡️ Укажи свой возраст, чтобы продолжить!\n(минимум 16 лет):\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "🎂➡️ Please provide your age to proceed!\n(minimum 16 years):\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.age)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "location":
        if lang == "ru":
            txt = """<b>Нам нужно знать вашу локацию, чтобы предложить людей рядом. 🌍</b>

⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

💡 <b>Обратите внимание:</b> вы можете отправить свою текущую геолокацию, нажав кнопку ниже. 
Если хотите указать другую точку на карте, выберите её в меню Telegram. Подробная инструкция по смене локации доступна в нашем <a href="https://t.me/your_channel_post">канале</a>. 📍

➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию или выберите точку на карте.
"""
        else:
            txt = """<b>Now we need your location to suggest people nearby. 🌍</b>

⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

💡 <b>Note:</b> You can send your current location by pressing the button below. 
If you’d like to specify another point on the map, select it in the Telegram menu. Detailed instructions for changing the location are available in our <a href="https://t.me/your_channel_post">channel</a>. 📍

➡️ Please press the button below to share your location or choose a point on the map.
"""

        data = await state.get_data()
        keyboard1 = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(
                        text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
                        request_location=True
                    )
                ]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        await state.set_state(RegState.location)
        txt1="Жду локаци..." if lang=="ru" else "Waiting for the location..."
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        msg1 = await callback_query.bot.send_message(callback_query.from_user.id, txt1, reply_markup=keyboard1)
        data["idmsg_local"] = msg1.message_id
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data == "gender":
        txt = "⚥➡️ Укажи свой пол, чтобы мы могли лучше настроить профиль!\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "⚥➡️ Please specify your gender to better customize your profile!\n\nOr press <b>'back⬅️'</b> to undo the action."
        # Добавляем кнопки для выбора пола
        inline_keyboard = [
                [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
                [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
                [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")],
                [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
            ]

        keyboard1 = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        msg= await callback_query.message.edit_text(txt, reply_markup=keyboard1)
        data = await state.get_data()
        await state.set_state(RegState.gender)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "orientation":
        if user.gender =='mal':

            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]
        elif user.gender =="fem":
            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]
        elif user.gender=="oth":
            inline_keyboard = [
                [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
                [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
                [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
            ]


        inline_keyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard1 = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        txt = "🌈➡️ Укажи свою ориентацию, чтобы мы могли найти подходящих людей!\n\nИли нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "🌈➡️ Please specify your orientation so we can find the right people for you!\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.orientation)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard1)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "pref":
        txt = "👁️‍🗨️➡️ Укажи, кого ты хочешь видеть в своей ленте: девушек, парней или всех!\n\nИли нажми <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else "👁️‍🗨️➡️ Specify who you want to see in your feed: girls, boys, or everyone!\n\nOr press <b>'back⬅️'</b> to undo the action."
        data = await state.get_data()
        await state.set_state(RegState.show)
        inline_keyboard = [
            [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
            [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
            [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")],
            [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
        ]

        keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "goals":
        if lang == "ru":
            txt = """Укажи свои цели! 🌟

➡️ Выбери цели из предложенных вариантов:
"""
        else:
            txt = """<Specify your goals! 🌟

➡️ Choose your goals from the options provided:
"""
        inline_keyboard=[]
        if lang =="ru":
            inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
            inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
            inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
            inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
        else:
            inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
            inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
            inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
            inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])

        inline_keyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
        await state.set_state(RegState.preferences)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "hobbies":
    # Увлечения на двух языках с номерами
        interests = [
            (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
            (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
            (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
            (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
            (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
        ]
        inlinekeyboard = []
        row = []

        # Формируем кнопки для увлечений, по 3 в ряд
        for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
            row.append(InlineKeyboardButton(
                text=interest_ru if lang == "ru" else interest_en,
                callback_data=f"intrs_{number}"
            ))
            # Если добавлено 3 кнопки или это последняя кнопка в списке
            if len(row) == 2 or i == len(interests[:10]):
                inlinekeyboard.append(row)
                row = []  # Сбрасываем строку для следующего ряда

        # Добавляем стрелки навигации в последнюю строку
        inlinekeyboard.append([
            InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
            InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
        ])
        inlinekeyboard.append([InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
        if lang == "ru":
            txt = """
Выбери до 5 увлечений, которые описывают тебя. 🌟

➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
"""
        else:
            txt = """
Select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
    """
        await state.set_state(RegState.hobbies)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data == "descr":
        txt = (
"📝➡️ Напиши короткое описание о себе, чтобы другие могли узнать тебя лучше! Укажи свои увлечения, интересы или что-то, что ты хотел бы рассказать о себе. 🌟\n\nИли нажми <b>'назад⬅️'</b>, чтобы отменить действие."
        if lang == "ru"
        else "📝➡️ Write a short description about yourself so others can get to know you better! Share your hobbies, interests, or anything you'd like to tell about yourself. 🌟\n\nOr press <b>'back⬅️'</b> to undo the action."
        )

        data = await state.get_data()
        await state.set_state(RegState.about)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_edit"] = msg.message_id
        await state.update_data(data=data)
    elif cb_data == "media":
        txt = (
"📷 Пожалуйста, отправьте <b>от 1 до 3 медиа</b> (фотографии или видео), чтобы обновить ваш профиль.\n\n"
"Нажмите <b>'назад⬅️'</b>, чтобы отменить действие." if lang == "ru" else
"📷 Please send <b>1 to 3 media</b> (photos or videos) to update your profile.\n\n"
"Press <b>'back⬅️'</b> to cancel the action."
)       
        await state.set_state(RegState.media)
        msg = await callback_query.message.edit_text(txt, reply_markup=keyboard)
        data["idmsg_media"] = msg.message_id
        await state.update_data(data=data)

    elif cb_data =="back":
        await state.set_state(state=None)
        data = await state.get_data()
        if 'idmsg_local' in data:
            if data["idmsg_local"] is not None:
                await callback_query.bot.delete_message(callback_query.from_user.id, data["idmsg_local"])
                data["idmsg_local"]=None
                await state.update_data(data=data)
                await state.clear()
        

        user = await User.get_or_none(user_id=callback_query.from_user.id)

        if not user:
            lang = "ru"
            await callback_query.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
            return

        lang = user.lang if user.lang in ["ru", "en"] else "ru"
        hobbies_text = ", ".join([
            (interest[1] if lang == "ru" else interest[2])
            for interest in INTERESTS
            if str(interest[0]) in (user.hobbies or [])
        ])

        location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
        if "," in location_text:
            latitude, longitude = map(float, location_text.split(","))
            location_text = get_location_by_coordinates(latitude, longitude)

        subscription_text = (
            f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
        )
        if user.subscription != "Free":
            subscription_text += (
                f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
            )

        description = (
            f"<b>{'Ваш профиль' if lang == 'ru' else 'Your profile'}:</b>\n\n"
            f"<b>{'Имя' if lang == 'ru' else 'Name'}:</b> {user.name}\n"
            f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
            f"<b>{'Пол' if lang == 'ru' else 'Gender'}:</b> {GENDER[lang][user.gender]}\n"
            f"<b>{'Локация' if lang == 'ru' else 'Location'}:</b> {location_text or ('Локация не указана' if lang == 'ru' else 'Location not provided')}\n\n"
            f"{subscription_text}"
            f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
            f"<b>{'Кого показывать' if lang == 'ru' else 'Viewing Preferences'}:</b> {WHO[lang][user.for_whom]}\n"
            f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
            f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
            f"_________________________\n{user.about or ''}\n"
        )



        media = user.medias or []
        # if len(media) == 1:
        #     media_file = media[0]['file_id']
        #     if media[0]['type'] == 'photo':
        #         await callback_query.bot.send_photo(callback_query.from_user.id, media_file, caption=description)
        #     elif media[0]['type'] == 'video':
        #         await callback_query.bot.send_video(callback_query.from_user.id, media_file, caption=description)
        lang = user.lang if user and user.lang in ["ru", "en"] else "ru"
        if user.localstatus == "active":
            btn_local = InlineKeyboardButton(
                text="🌍 Скрыть локацию" if lang == "ru" else "🌍 Hide Location",
                callback_data="location_hish"
            )
        else:
            btn_local = InlineKeyboardButton(
                text="🌍 Показать локацию" if lang == "ru" else "🌍 Show Location",
                callback_data="location_hish"
            )

        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="🖋 Имя" if lang == "ru" else "🖋 Name",
                    callback_data="fedit_name"
                ),
                InlineKeyboardButton(
                    text="🎂 Возраст" if lang == "ru" else "🎂 Age",
                    callback_data="fedit_age"
                )
            ],
            [
                InlineKeyboardButton(
                    text="📍 Изменить локацию" if lang == "ru" else "📍 Edit Location",
                    callback_data="fedit_location"
                ),
                btn_local
            ],
            [
                InlineKeyboardButton(
                    text="⚥ Пол" if lang == "ru" else "⚥ Gender",
                    callback_data="fedit_gender"
                ),
                InlineKeyboardButton(
                    text="🌈 Ориентация" if lang == "ru" else "🌈 Orientation",
                    callback_data="fedit_orientation"
                )
            ],
            [
                InlineKeyboardButton(
                    text="👁️‍🗨️ Кого показывать" if lang == "ru" else "👁️‍🗨️ Viewing Preferences",
                    callback_data="fedit_pref"
                ),
                InlineKeyboardButton(
                    text="🎯 Цели" if lang == "ru" else "🎯 Goals",
                    callback_data="fedit_goals"
                )
            ],
            [
                InlineKeyboardButton(
                    text="🎨 Увлечения" if lang == "ru" else "🎨 Hobbies",
                    callback_data="fedit_hobbies"
                ),
                InlineKeyboardButton(
                    text="📝 Описание" if lang == "ru" else "📝 Description",
                    callback_data="fedit_descr"
                )
            ],
            [
                InlineKeyboardButton(
                    text="🔄 Заполнить заново" if lang == "ru" else "🔄 Refill Profile",
                    callback_data="reset_profile"
                )
            ]
        ])


        await callback_query.message.edit_text(
            MESSAGES["action_prompt"][lang], 
            reply_markup=keyboard
        )
    else:
        await callback_query.answer("Неизвестная команда" if lang == "ru" else "Unknown command", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("reset_"))
async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    cb_data = (callback_query.data.split("_"))[1]
    if user:
        if cb_data == "profile":
            
            txt = """<b>Вы собираетесь заполнить профиль заново. ❗️</b>

            После нажатия <b>"ДА"</b> это действие будет <b>необратимо</b>. Все текущие данные профиля будут удалены.

            Вы точно уверены в этом?""" if lang == "ru" else """<b>You are about to refill your profile. ❗️</b>

            Once you press <b>"YES"</b>, this action will be <b>irreversible</b>. All current profile data will be deleted.

            Are you sure about this?"""
            inline_keyboard = [
                [InlineKeyboardButton(text="Да" if lang == "ru" else "Yes", callback_data="reset_yes")],
                [InlineKeyboardButton(text="Назад⬅️" if lang == "ru" else "Back⬅️",callback_data="fedit_back")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
            await callback_query.message.edit_text(txt, reply_markup=keyboard)
        elif cb_data == "yes":  
            user.name=None
            user.age=None
            user.gender=None
            user.orientation=None
            user.for_whom=None
            user.preferences=None
            user.location=None
            user.about=None
            user.hobbies=None
            user.medias=None
            await user.save()
            await state.clear()
            await callback_query.answer("Профиль удален" if lang == "ru" else "Profile deleted", show_alert=True)
            await callback_query.message.edit_reply_markup(reply_markup=None)
            await add_profile(message=callback_query.message, state=state , user=user, lang=lang)








            await callback_query.answer("Профиль удален" if lang == "ru" else "Profile deleted")

# ===+++++=====+++++++=======++++++ HANDLERS ===+++++=====+++++++=======++++++ 

# BAD_WORDS = [
#     # Наркотики
#     "наркотик", "наркота", "косяк", "травка", "гашиш", "героин", "кокаин", "амфетамин", "экстази",
#     "марихуана", "спайс", "лсд", "шишки", "опиум", "план", "кристалл", "мефедрон", "drugs", "drug",
#     "weed", "marijuana", "cocaine", "heroin", "ecstasy", "meth", "amphetamine", "hash", "spice",
#     "lsd", "crystal", "meph", "opium", "j0int", "dr@g", "tr@vka",

#     # CP
#     "детская порнография", "детское порно", "запрещенное видео", "нелегальный контент", "порнография с детьми",
#     "cp", "child porn", "child pornography", "illegal content", "b@nned video", "ch!ld p0rn",

#     # Оружие
#     "оружие", "пистолет", "винтовка", "автомат", "пулемет", "граната", "мина", "бомба", "арсенал",
#     "ружье", "ствол", "калашников", "ак-47", "глок", "гранатомет", "weapon", "gun", "pistol", "rifle",
#     "machine gun", "grenade", "bomb", "landmine", "arsenal", "shotgun", "kalashnikov", "ak47",
#     "glock", "rocket launcher", "we@pon", "glock-19", "b0mb",

#     # Additional prohibited words
#     "explosive", "tnt", "c4", "detonator", "silencer", "sniper", "assault rifle", "pipe bomb",
#     "наркот", "герич", "герыч", "доза", "спайсы", "соли", "фен", "скорость",
#     "запрещенка", "порно с детьми", "порево", "kill", "murder", "mass shooting", "terrorist", "attack"
# ]






# # ++++++++++++++++ NAME +++++++++++++++

# @router.message(RegState.name)
# async def set_name(message: types.Message, state: FSMContext, lang: str):
#     user = await User.get_or_none(user_id=message.from_user.id)
#     global BAD_WORDS
#     if user:
#         if message.text not in BAD_WORDS:
#             user.name = message.text.strip()
#             await user.save()
            
#             if lang == "ru":
#                 txt = """<b>Имя указано! ✅</b>
# Отлично, теперь укажи свой пол! 🌟

# ➡️ Выбери один из вариантов:
# """
#             else:
#                 txt = """<b>Name provided! ✅</b>
# Great, now specify your gender! 🌟

# ➡️ Choose one of the options:
# """

#             inline_keyboard = [
#                 [InlineKeyboardButton(text="👩 Женский" if lang == "ru" else "👩 Female", callback_data="gender_fem")],
#                 [InlineKeyboardButton(text="👨 Мужской" if lang == "ru" else "👨 Male", callback_data="gender_mal")],
#                 [InlineKeyboardButton(text="🌈 Другое" if lang == "ru" else "🌈 Other", callback_data="gender_oth")]
#             ]

#             keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#             await state.set_state(RegState.gender)
#             await message.answer(txt, reply_markup=keyboard)
#         else:
#             txt = """<❌ <b>Ошибка:</b> Ваше имя содержит запрещенные слова. Пожалуйста, выберите другое имя. ✍️""" if lang == "ru" else """<❌ <b>Error:</b> Your name contains prohibited words. Please choose another name. ✍️"""
#             await state.set_state(RegState.name)
#             await message.answer(txt)


# # ++++++++++++++++ GENDER +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("gender_"), RegState.gender)
# async def set_gender(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.gender = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Пол указан! ✅</b>
# Теперь укажи свою ориентацию! 🌟

# ➡️ Выбери один из вариантов:
# """
#         else:
#             txt = """<b>Gender saved! ✅</b>
# Now specify your orientation! 🌟

# ➡️ Choose one of the options:
# """
#         if user.gender =='mal':

#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="🌈 Гей" if lang == "ru" else "🌈 Gay", callback_data="orientation_gay")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]
#         elif user.gender =="fem":
#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="💖 Лесби" if lang == "ru" else "💖 Lesbian", callback_data="orientation_lesbian")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]
#         elif user.gender=="oth":
#             inline_keyboard = [
#                 [InlineKeyboardButton(text="❤️ Гетеро" if lang == "ru" else "❤️ Hetero", callback_data="orientation_hetero")],
#                 [InlineKeyboardButton(text="🌈 Гей/Лесби" if lang == "ru" else "🌈 Gay/Lesbian", callback_data="orientation_gay_lesbian")],
#                 [InlineKeyboardButton(text="💛 Би" if lang == "ru" else "💛 Bi", callback_data="orientation_bi")]
#             ]



#         keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#         await state.set_state(RegState.orientation)
#         await callback_query.message.edit_text(txt, reply_markup=keyboard)


# # ++++++++++++++++ ORIENTATION +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("orientation_"), RegState.orientation)
# async def set_orientation(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.orientation = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Ориентация указана! ✅</b>
# Теперь укажи, кого ты хочешь видеть! 🌟

# ➡️ Выбери один из вариантов:
# """
#         else:
#             txt = """<b>Orientation saved! ✅</b>
# Now specify who you want to see! 🌟

# ➡️ Choose one of the options:
# """

#         inline_keyboard = [
#             [InlineKeyboardButton(text="👩 Девушки" if lang == "ru" else "👩 Girls", callback_data="show_fem")],
#             [InlineKeyboardButton(text="👨 Парни" if lang == "ru" else "👨 Boys", callback_data="show_mal")],
#             [InlineKeyboardButton(text="🌍 Все" if lang == "ru" else "🌍 Everyone", callback_data="show_all")]
#         ]

#         keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#         await state.set_state(RegState.show)
#         await callback_query.message.edit_text(txt, reply_markup=keyboard)


# # ++++++++++++++++ SHOW PREFERENCES +++++++++++++++

# @router.callback_query(lambda c: c.data.startswith("show_"), RegState.show)
# async def set_show_preferences(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     if user:
#         user.for_whom = callback_query.data.split("_")[1]
#         await user.save()

#         if lang == "ru":
#             txt = """<b>Параметры просмотра указаны! ✅</b>
# Теперь укажи свой возраст! 🌟

# ➡️ Введите ваш возраст (минимум 16 лет):
# """
#         else:
#             txt = """<b>Viewing preferences saved! ✅</b>
# Now specify your age! 🌟

# ➡️ Enter your age (minimum 16 years):
# """

#         await state.set_state(RegState.age)
#         await callback_query.message.edit_text(txt)


# # ++++++++++++++++ AGE +++++++++++++++

# @router.message(RegState.age)
# async def set_age(message: types.Message, user: User, state: FSMContext, lang: str):
#     if user:
#         if message.text.isdigit():
#             age = int(message.text)
#             if age >= 16:
#                 user.age = age
#                 await user.save()

#                 if lang == "ru":
#                     txt = """<b>Возраст указан! ✅</b>
# Теперь укажи свои цели! 🌟

# ➡️ Выбери цели из предложенных вариантов:
# """
#                 else:
#                     txt = """<b>Age saved! ✅</b>
# Now specify your goals! 🌟

# ➡️ Choose your goals from the options provided:
# """
#                 inline_keyboard=[]
#                 if lang =="ru":
#                     inline_keyboard.append([InlineKeyboardButton(text="🤝 Дружба", callback_data="interest_friendship")])
#                     inline_keyboard.append([InlineKeyboardButton(text="❤️ Романтические отношения", callback_data="interest_romantic")])
#                     inline_keyboard.append([InlineKeyboardButton(text="💼 Партнерство в проектах", callback_data="interest_partnership")])
#                     inline_keyboard.append([InlineKeyboardButton(text="🌍 Общение на тему эмиграции", callback_data="interest_emigration")])
#                 else:
#                     inline_keyboard.append([InlineKeyboardButton(text="🤝 Friendship", callback_data="interest_friendship")])
#                     inline_keyboard.append([InlineKeyboardButton(text="❤️ Romantic relationships", callback_data="interest_romantic")])
#                     inline_keyboard.append([InlineKeyboardButton(text="💼 Partnership in projects", callback_data="interest_partnership")])
#                     inline_keyboard.append([InlineKeyboardButton(text="🌍 Discussion about emigration", callback_data="interest_emigration")])


#                 keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
#                 await state.set_state(RegState.preferences)
#                 await message.answer(txt, reply_markup=keyboard)
#             else:
#                 txt = """❌ <b>Ошибка:</b> Возраст должен быть не менее 16 лет. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be at least 16 years. 🔢"""
#                 await message.answer(txt)
#         else:
#             txt = """❌ <b>Ошибка:</b> Возраст должен быть числом. Пожалуйста, введите корректное значение. 🔢""" if lang == "ru" else """❌ <b>Error:</b> Age must be a number. Please enter a valid value. 🔢"""
#             await message.answer(txt)


# # ++++++++++++++++ PREFERENCES +++++++++++++++

# @router.callback_query(lambda c: "interest_" in c.data, RegState.preferences)
# async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
    
#     if user:
#         pref = callback_query.data.split("_")[1]
#         user.preferences=pref
#         await user.save()
#         keyboard = ReplyKeyboardMarkup(
#             keyboard=[
#                 [
#                     KeyboardButton(
#                         text="📍 Отправить локацию" if lang == "ru" else "📍 Share Location",
#                         request_location=True
#                     )
#                 ]
#             ],
#             resize_keyboard=True,
#             one_time_keyboard=True
#         )

#         if lang == "ru":
#             txt = """
# Нам нужно знать твою локацию, чтобы предложить людей рядом. 🌍

# ⚠️ <b>Не переживайте:</b> никто из пользователей не узнает ваше реальное местоположение. Они будут видеть только <b>приблизительное расстояние</b> до вас. 🛡️

# 💡 <b>Обратите внимание:</b> с тарифом <b>Pro</b> вы можете указать любую интересующую вас локацию и искать людей в том месте, где вам удобно! Это отличный способ расширить круг общения и найти людей из интересующих вас регионов. 🌎

# ➡️ Пожалуйста, нажмите кнопку ниже, чтобы отправить свою локацию.
# """
#         else:
#             txt = """
# We need your location to suggest people nearby. 🌍

# ⚠️ <b>Don't worry:</b> no one will see your exact location. Users will only see the <b>approximate distance</b> to you. 🛡️

# 💡 <b>Note:</b> With the <b>Pro</b> plan, you can specify any location you’re interested in and search for people in a convenient area! This is a great way to expand your connections and meet people from specific regions. 🌎

# ➡️ Please press the button below to share your location.
# """
#         await state.set_state(RegState.location)
#         await callback_query.bot.delete_message(callback_query.from_user.id, callback_query.message.message_id)
#         msg= await callback_query.bot.send_message(callback_query.from_user.id, txt, reply_markup=keyboard)
#         data = await state.get_data()
#         data['idmsg_local']=msg.message_id
#         await state.update_data(data)

# # ++++++++++++++++ LOCATION +++++++++++++++

# @router.message(RegState.location, lambda message: message.content_type == ContentType.LOCATION)
# async def set_location(message: types.Message, user: User, state: FSMContext, lang: str):
    
#     if user:
#         user.location = f"{message.location.latitude},{message.location.longitude}"
#         await user.save()
#         if lang == "ru":
#             txt = """<b>Локация указана! ✅</b>
# Отлично, теперь расскажи немного о себе. 🌟

# ➡️ Напиши короткое описание о себе: твои интересы, хобби или что-то, что ты хотел бы, чтобы другие знали о тебе.
# """
#         else:
#             txt = """<b>Location saved! ✅</b>
# Great, now tell us a bit about yourself. 🌟

# ➡️ Write a short description about yourself: your interests, hobbies, or anything you’d like others to know about you.
# """
#         await state.set_state(RegState.about)
#         data = await state.get_data()
#         if "idmsg_local" in data: 
#             await message.bot.delete_message(message.from_user.id, data["idmsg_local"])
#         data["idmsg_local"]=''
#         await state.update_data(data)
#         await message.bot.delete_message(message.from_user.id, message.message_id)
#         await message.bot.send_message(message.from_user.id, txt)

# # ++++++++++++++++ ABOUT +++++++++++++++

# @router.message(RegState.about)
# async def set_about(message: types.Message, user: User, state: FSMContext, lang: str):
#     global BAD_WORDS
#     if user:
#         if message.text:
#             if message.text not in BAD_WORDS:
#                 user.about = message.text
#                 await user.save()
                
#                 await state.set_state(RegState.hobbies)
#             # Увлечения на двух языках с номерами
#                 interests = [
#                     (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
#                     (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
#                     (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
#                     (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
#                     (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health")
#                 ]
#                 inlinekeyboard = []
#                 row = []

#                 # Формируем кнопки для увлечений, по 3 в ряд
#                 for i, (number, interest_ru, interest_en) in enumerate(interests[:10], start=1):
#                     row.append(InlineKeyboardButton(
#                         text=interest_ru if lang == "ru" else interest_en,
#                         callback_data=f"intrs_{number}"
#                     ))
#                     # Если добавлено 3 кнопки или это последняя кнопка в списке
#                     if len(row) == 2 or i == len(interests[:10]):
#                         inlinekeyboard.append(row)
#                         row = []  # Сбрасываем строку для следующего ряда

#                 # Добавляем стрелки навигации в последнюю строку
#                 inlinekeyboard.append([
#                     InlineKeyboardButton(text="🚫" if lang == "ru" else "🚫", callback_data="intrs_z"),
#                     InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next")
#                 ])

#                 keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
                
#                 if lang == "ru":
#                     txt = """<b>Записали ✅</b>
#     Отлично, теперь выбери до 5 увлечений, которые описывают тебя. 🌟

#    ➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми "Сохранить✅".
#         """
#                 else:
#                     txt = """<b>Saved ✅</b>
#     Great, now select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click \"<b>Save✅</b>\".
#     """


#                 await message.answer(txt, reply_markup=keyboard)
                
#             else:
#                 if lang == "ru":
#                     txt = """❌ <b>Ошибка:</b> Описание содержит запрещенные слова. Пожалуйста, введите другое описание и попробуйте снова. ✍️"""
#                 else:
#                     txt = """❌ <b>Error:</b> The description contains prohibited words. Please enter another description and try again. ✍️"""
#                 await message.answer(txt)
#                 await state.set_state(RegState.about)
#         else:
#                 if lang == "ru":
#                     txt = """❌ <b>Ошибка:</b> Описание долджно содержать текст ✍️"""
#                 else:
                    
#                     txt = """❌ <b>Error:</b> The description must contain text. Please write something ✍️"""
#                 await message.answer(txt)
#                 await state.set_state(RegState.about)

# # ++++++++++++++++ HOBBIES +++++++++++++++

# @router.callback_query(lambda c: "intrs_" in c.data or c.data.startswith("intrs_page") or c.data == "intrs_done", RegState.hobbies)
# async def callback_handler(callback_query: CallbackQuery, user: User, state: FSMContext, lang: str):
#     # Загружаем список интересов
#     interests = [
#         (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
#         (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
#         (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
#         (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
#         (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
#         (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
#         (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
#         (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
#         (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
#         (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
#         (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
#         (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
#         (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
#         (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
#         (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
#         (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
#         (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
#         (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
#         (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
#         (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), (60, "Языковой обмен", "Language Exchange"),
#     ]

#     # Обработка страниц
#     state_data = await state.get_data()
#     current_page = state_data.get("current_page", 1)
#     hobbies = state_data.get("selected_hobbies", [])

#     if callback_query.data.startswith("intrs_page"):
#         if "next" in callback_query.data:
#             current_page += 1
#         elif "back" in callback_query.data:
#             current_page -= 1
#         await state.update_data(current_page=current_page)

#     elif callback_query.data.startswith("intrs_") and callback_query.data != "intrs_done":
#         interest = callback_query.data.split("_")[1]
#         if interest in hobbies:
#             hobbies.remove(interest)
#         else:
#             if len(hobbies) < 5:
#                 hobbies.append(interest)
#             else:
#                 txt1 = "Выбрано максимальное количество! Уберите один интерес или нажмите 'Сохранить'." if lang == "ru" else "Maximum number selected! Remove one interest or click 'Save'."
#                 await callback_query.answer(
#                     txt1,
#                     show_alert=True
#                 )
#                 return
#         await state.update_data(selected_hobbies=hobbies)

#     elif callback_query.data == "intrs_done":
#         if len(hobbies) < 5:
#             txt2 = "Вы должны выбрать минимум 5 интересов, чтобы продолжить!" if lang == "ru" else "You must select at least 5 interests to continue!"
#             await callback_query.answer(
#                 txt2,
#                 show_alert=True
#             )
#             return
#         else:
#             user.hobbies = hobbies  # Сохраняем в базу данных только при завершении
#             await user.save()

#             txt3 = "Интересы сохранены! ✅" if lang == "ru" else "Interests saved! ✅"
#             await callback_query.answer(txt3, show_alert=True)

#             txt = """🎉 <b>Отлично!</b> Ваши хобби успешно сохранены.  

# Теперь отправьте от <b>1 до 3 медиа</b> (фотографии или видео), чтобы другие могли узнать вас лучше.  
# Или нажмите "Пропустить", чтобы продолжить. ⏩""" if lang == "ru" else """🎉 <b>Great!</b> Your hobbies have been successfully saved.  

# Now, please send <b>1 to 3 media</b> (photos or videos) so others can get to know you better.  
# Or press "Skip" to continue. ⏩"""

#             keyboard = InlineKeyboardMarkup(inline_keyboard=[
#                 [InlineKeyboardButton(text="Пропустить 🔄" if lang == "ru" else "Skip 🔄", callback_data="skip_album")]
#             ])

#             await callback_query.message.edit_text(txt, reply_markup=keyboard)
#             await state.set_state(RegState.media)
#             return

#     # Генерация кнопок для текущей страницы
#     page_size = 10
#     start_index = (current_page - 1) * page_size
#     end_index = start_index + page_size
#     inlinekeyboard = []
#     row = []

#     for i, (number, interest_ru, interest_en) in enumerate(interests[start_index:end_index], start=1):
#         text = ("🔹" if str(number) in hobbies else "") + (interest_ru if lang == "ru" else interest_en)
#         row.append(InlineKeyboardButton(
#             text=text,
#             callback_data=f"intrs_{number}"
#         ))
#         if len(row) == 2 or i == len(interests[start_index:end_index]):
#             inlinekeyboard.append(row)
#             row = []

#     navigation_buttons = []
#     if current_page > 1:
#         navigation_buttons.append(InlineKeyboardButton(text="⬅️" if lang == "ru" else "⬅️ Back", callback_data="intrs_page_back"))
#     if end_index < len(interests):
#         navigation_buttons.append(InlineKeyboardButton(text="➡️" if lang == "ru" else "➡️ Next", callback_data="intrs_page_next"))
#     if navigation_buttons:
#         inlinekeyboard.append(navigation_buttons)

#     if len(hobbies) == 5:
#         inlinekeyboard.append(
#             [InlineKeyboardButton(text=f"Сохранить ({len(hobbies)}/5) ✅" if lang == "ru" else f"Save ({len(hobbies)}/5) ✅", callback_data="intrs_done")]
#         )

#     keyboard = InlineKeyboardMarkup(inline_keyboard=inlinekeyboard)
#     txt = (f"<b>Выбрано {len(hobbies)}/5 увлечений ✅</b>\n" if lang == "ru" else f"<b>Selected {len(hobbies)}/5 hobbies ✅</b>\n")
#     txt += "Отлично, выбери до 5 увлечений, которые описывают тебя. 🌟\n\n➡️ Нажимай на кнопки, чтобы выбрать увлечения. Когда закончишь, нажми 'Сохранить'." if lang == "ru" else "Great, select up to 5 hobbies that describe you. 🌟\n\n➡️ Click on the buttons to select your hobbies. Once you're done, click 'Save'."

#     await callback_query.message.edit_text(txt, reply_markup=keyboard)


        

            [FILE] chat.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/chat.py ---


            [FILE] search.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/search.py ---


# import ssl
# import certifi
# from geopy.geocoders import Nominatim

# def get_location_by_coordinates(latitude, longitude):
#     geolocator = Nominatim(
#         user_agent="my_geopy_app",
#         timeout=10,
#         ssl_context=ssl.create_default_context(cafile=certifi.where())
#     )
#     try:
#         location = geolocator.reverse((latitude, longitude), exactly_one=True)
#         if location:
#             address = location.raw.get('address', {})
#             city = address.get('city') or address.get('town') or address.get('village') or address.get('hamlet')
#             return city or location.address
#         else:
#             return "Местоположение не найдено"
#     except Exception as e:
#         return f"Ошибка при определении местоположения: {e}"
    

# @router.message(Command("myprofile"))
# async def my_profile_handler(message: types.Message,state: FSMContext):
#     user = await User.get_or_none(user_id=message.from_user.id)

#     if not user:
#         lang = "ru"
#         await message.answer("<b>Профиль не найден.</b>\nПожалуйста, зарегистрируйтесь с помощью команды /start.")
#         return

#     lang = user.lang if user.lang in ["ru", "en"] else "ru"
#     hobbies_text = ", ".join([
#         (interest[1] if lang == "ru" else interest[2])
#         for interest in INTERESTS
#         if str(interest[0]) in (user.hobbies or [])
#     ])

#     location_text = user.location or ("Локация не указана" if lang == "ru" else "Location not provided")
#     if "," in location_text:
#         latitude, longitude = map(float, location_text.split(","))
#         location_text = get_location_by_coordinates(latitude, longitude)

#     subscription_text = (
#         f"<b>{'Подписка' if lang == 'ru' else 'Subscription'}:</b> {user.subscription}\n"
#     )
#     if user.subscription != "Free":
#         subscription_text += (
#             f"<b>{'Дата окончания подписки' if lang == 'ru' else 'Subscription end date'}:</b> {user.subscription_end}\n"
#         )

#     description = (
#         f"<b>{user.name}</b> \n"
#         f"<b>{'Возраст' if lang == 'ru' else 'Age'}:</b> {user.age}\n"
#         f"{GENDER[lang][user.gender]}\n"
#         f"<b>{'Ориентация' if lang == 'ru' else 'Orientation'}:</b> {ORI[lang][user.orientation]}\n"
#         f"{location_text}\n"

#         f"<b>{'Цели' if lang == 'ru' else 'Goals'}:</b> {PREFERENCES[lang][user.preferences]}\n"
#         f"<b>{'Увлечения' if lang == 'ru' else 'Hobbies'}:</b> {hobbies_text}\n\n"
#         f"_________________________\n{user.about or ''}\n"
#     )



#     media = user.medias or []
#     if len(media) == 1:
#         media_file = media[0]['file_id']
#         if media[0]['type'] == 'photo':
#             msg= await message.bot.send_photo(message.from_user.id, media_file, caption=description)
#         elif media[0]['type'] == 'video':
#             msg= await message.bot.send_video(message.from_user.id, media_file, caption=description)
#     else:
#         files=[]
#         i =0
#         for media_file in media:
            
#             caption=description if i == 0 else None
            
#             if media_file["type"] =="video":
#                 files.append(InputMediaVideo(media=f"{media_file['file_id']}", caption=caption))
#                 i = i+1
#             elif media_file['type'] == 'photo':
#                 files.append(InputMediaPhoto(media=f"{media_file['file_id']}", caption=caption))
#                 i = i+1
#             else:
#                 continue
                 

#     # Отправка медиа-группы
#         msg= await message.bot.send_media_group(chat_id=message.from_user.id, media=files)
#         data= await state.get_data()
#         data["id_card_profile"]=None
#         await state.update_data(data=data)
    
    

   
        
    


            [FILE] serch.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/serch.py ---
from aiogram import Router, types, F
from aiogram.types import (
    ReplyKeyboardMarkup,
    KeyboardButton,
    InputMediaPhoto,
    InputMediaVideo,
    ReplyKeyboardRemove
)
from aiogram.fsm.context import FSMContext

import math
import ssl
import certifi
from geopy.geocoders import Nominatim
from tortoise.expressions import Q

from src.models import User as Userdb, Like, Block
from src.utils.state import SearchPeople

router = Router()

# -----------------------------
# Словари переводов
# -----------------------------
INTERESTS = [
    (1, "Спорт", "Sport"), (2, "Музыка", "Music"), (3, "Путешествия", "Travel"), 
    (4, "Кино", "Movies"), (5, "Кулинария", "Cooking"), (6, "Искусство", "Art"), 
    (7, "Танцы", "Dancing"), (8, "Технологии", "Technology"), (9, "Литература", "Literature"), 
    (10, "Фотография", "Photography"), (11, "Игры", "Games"), (12, "Природа", "Nature"), 
    (13, "Автомобили", "Cars"), (14, "Мода", "Fashion"), (15, "Здоровье", "Health"),
    (16, "Йога", "Yoga"), (17, "Фитнес", "Fitness"), (18, "Астрономия", "Astronomy"), 
    (19, "История", "History"), (20, "Наука", "Science"), (21, "Театр", "Theater"), 
    (22, "Видеомонтаж", "Video Editing"), (23, "Рыбалка", "Fishing"), (24, "Охота", "Hunting"), 
    (25, "Гаджеты", "Gadgets"), (26, "Киберспорт", "Esports"), (27, "Комиксы", "Comics"), 
    (28, "Рукоделие", "Handcraft"), (29, "Медицина", "Medicine"), (30, "Животные", "Animals"),
    (31, "Астрология", "Astrology"), (32, "Эзотерика", "Esoterics"), (33, "Психология", "Psychology"), 
    (34, "Планирование", "Planning"), (35, "Волонтёрство", "Volunteering"), (36, "Блогинг", "Blogging"), 
    (37, "Дизайн", "Design"), (38, "Флористика", "Floristry"), (39, "Косплей", "Cosplay"), 
    (40, "Программирование", "Programming"), (41, "Мотоспорт", "Motor Sports"), 
    (42, "Философия", "Philosophy"), (43, "Чтение", "Reading"), (44, "Коллекционирование", "Collecting"),
    (45, "Лыжи", "Skiing"), (46, "Сноуборд", "Snowboarding"), (47, "Дайвинг", "Diving"), 
    (48, "Кемпинг", "Camping"), (49, "Плавание", "Swimming"), (50, "Бег", "Running"), 
    (51, "Туризм", "Hiking"), (52, "Стрельба", "Shooting"), (53, "Гольф", "Golf"), 
    (54, "Шахматы", "Chess"), (55, "Настольные игры", "Board Games"), (56, "Журналистика", "Journalism"), 
    (57, "Инвестирование", "Investing"), (58, "Кулинария", "Cooking"), (59, "Садоводство", "Gardening"), 
    (60, "Языковой обмен", "Language Exchange"),
]

PREFERENCES = {
    "ru": {
        "friendship": "🤝 Дружба",
        "romantic": "❤️ Романтические отношения",
        "partnership": "💼 Партнерство в проектах",
        "emigration": "🌍 Общение на тему эмиграции"
    },
    "en": {
        "friendship": "🤝 Friendship",
        "romantic": "❤️ Romantic relationships",
        "partnership": "💼 Partnership in projects",
        "emigration": "🌍 Discussion about emigration"
    }
}

GENDER = {
    "ru": {"fem": "👩 Женский", "mal": "👨 Мужской", "oth": "🌈 Другое"},
    "en": {"fem": "👩 Female", "mal": "👨 Male", "oth": "🌈 Other"}
}

WHO = {
    "ru": {"fem": "👩 Девушки", "mal": "👨 Парни", "all": "🌍 Все"},
    "en": {"fem": "👩 fem", "mal": "👨 mal", "all": "🌍 Everyone"}
}

ORI = {
    "ru": {
        "hetero": "❤️ Гетеро",
        "gay": "🌈 Гей",
        "bi": "💛 Би",
        "lesbian": "💖 Лесби",
        "gay_lesbian": "🌈 Гей/Лесби",
        "oth": "💫 Другая",
        "skip": "Не указана"
    },
    "en": {
        "hetero": "❤️ Hetero",
        "gay": "🌈 Gay",
        "bi": "💛 Bi",
        "lesbian": "💖 Lesbian",
        "gay_lesbian": "🌈 Gay/Lesbian",
        "oth": "💫 Other",
        "skip": "Not specified"
    }
}

# -----------------------------
# Вспомогательные функции
# -----------------------------
@router.message(F.text.in_(["❤️ Лайк", "💖 Суперлайк", "👎🏻 Дизлайк", "🚫 Заблокировать", "❗ Пожаловаться", "⏹ Остановить поиск",
                             "❤️ Like", "💖 Superlike", "👎🏻 Dislike", "🚫 Block", "❗ Report", "⏹ Stop Search"]))
async def handle_reaction(message: types.Message, state: FSMContext):
    user = await Userdb.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer("Профиль не найден.")
        return

    reaction = message.text
    if reaction in ["⏹ Остановить поиск", "⏹ Stop Search"]:
        await state.clear()
        await message.answer("Поиск остановлен.", reply_markup=ReplyKeyboardRemove())
        return

    data = await state.get_data()
    current_candidate_id = data.get("current_candidate_id")
    if not current_candidate_id:
        await message.answer("Нет текущей анкеты для оценки. Попробуйте начать поиск заново.")
        return

    candidate = await Userdb.get_or_none(user_id=current_candidate_id)
    if not candidate:
        await message.answer("Ошибка: кандидат не найден.")
        return

    if reaction in ["❤️ Лайк", "❤️ Like"]:
        await Like.create(from_user=user, to_user=candidate, is_superlike=False)
        # Если у пользователя Free-подписка, уведомляем, что для просмотра полного профиля необходимо оформить подписку.
        if user.subscription.lower() == "free":
            await message.answer("Вы получили лайк! Чтобы увидеть подробности профиля кандидата, необходимо приобрести подписку.")
            # Здесь можно добавить дополнительную логику для перенаправления на страницу покупки подписки.
        else:
            await message.answer("Вы поставили лайк!")
    elif reaction in ["💖 Суперлайк", "💖 Superlike"]:
        if user.subscription.lower() != "free":
            await Like.create(from_user=user, to_user=candidate, is_superlike=True)
            await message.answer("Вы поставили суперлайк!")
        else:
            await message.answer("Суперлайк доступен только при платной подписке.")
    elif reaction in ["👎🏻 Дизлайк", "👎🏻 Dislike"]:
        await message.answer("Вы дизлайкнули кандидата.")
    elif reaction in ["🚫 Заблокировать", "🚫 Block"]:
        await Block.create(from_user=user, to_user=candidate, can_message=False)
        await message.answer("Кандидат заблокирован.")
    elif reaction in ["❗ Пожаловаться", "❗ Report"]:
        # Здесь можно добавить логику обработки жалобы.
        await message.answer("Вы отправили жалобу.")
    else:
        await message.answer("Неверная команда.")

    # После обработки реакции, если реакция не связана с остановкой поиска, показываем следующего кандидата.
    await start_search(user, state, message.bot)

# -----------------------------
# Хендлер для кнопки "Начать поиск"
# -----------------------------
@router.message(F.text.in_(["🚀 Начать поиск", "🚀 Start Search"]))
async def handle_search_start(message: types.Message, state: FSMContext):
    user = await Userdb.get_or_none(user_id=message.from_user.id)
    if not user:
        await message.answer(
            "<b>Профиль не найден.</b> Пожалуйста, зарегистрируйтесь с помощью команды /start."
        )
        return

    lang = user.lang or ("ru" if message.from_user.language_code == "ru" else "en")
    await state.set_state(SearchPeople.search)
    await message.answer(
        "🔎 Поиск начался! Ожидайте…" if lang == "ru" else "🔎 The search has begun! Please wait…"
    )
    await start_search(user, state, message.bot)


            [FILE] SET FOREIGN_KEY_CHECKS = 0; -- Отключаем.sql

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/bot/handlers/SET FOREIGN_KEY_CHECKS = 0; -- Отключаем.sql ---
SET FOREIGN_KEY_CHECKS = 0; -- Отключаем проверку внешних ключей

DROP TABLE IF EXISTS `users`;
DROP TABLE IF EXISTS `likes`;
DROP TABLE IF EXISTS `blocks`;
DROP TABLE IF EXISTS `statements`;
DROP TABLE IF EXISTS `aerich`; -- Если используется Aerich

SET FOREIGN_KEY_CHECKS = 1

    [DIR] data
        [FILE] __init__.py

--- Содержимое файла: /Users/aliroghani/Desktop/PJS/Emi-date/emi-date/src/data/__init__.py ---


[FILE] project_structure_and_code.txt


